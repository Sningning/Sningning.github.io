<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
<meta name="baidu-site-verification" content="jrFWF6ybrX" />
<meta name="google-site-verification" content="pFsBfeKIAL6_5hJXpfcJ9hnJveKoB1Bx53OvTyaW8vU" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo_180x180.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo_32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo_16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="true">
  <meta name="msvalidate.01" content="true">
  <meta name="baidu-site-verification" content="true">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic|Fira Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sningning.github.io","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>



  <meta name="description" content="树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。把它叫做“树”是因为它看起来像一棵倒挂的树。 二分搜索树（Binary Search Tree，BST）相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 O(log n)。二分搜索树是基础性数据结构，用于构建更为抽象的数据结构。 维基百科">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构04-二分搜索树">
<meta property="og:url" content="https://sningning.github.io/posts/523021e3/index.html">
<meta property="og:site_name" content="菜鸟小宋">
<meta property="og:description" content="树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。把它叫做“树”是因为它看起来像一棵倒挂的树。 二分搜索树（Binary Search Tree，BST）相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 O(log n)。二分搜索树是基础性数据结构，用于构建更为抽象的数据结构。 维基百科">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/tree.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/BST.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add1.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add2.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add3.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add4.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add5.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/%E9%81%8D%E5%8E%86.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/preOrder.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/inOrder.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/postOrder.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/preOrderNR.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/levelOrder.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/levelOrder1.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/removeMin.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/removeMin2.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/Algorithms(4th%20edition).png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/visualgo.net.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/remove.gif">
<meta property="article:published_time" content="2020-04-02T01:46:25.000Z">
<meta property="article:modified_time" content="2020-07-01T03:23:41.887Z">
<meta property="article:author" content="Song Ningning">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/tree.png">

<link rel="canonical" href="https://sningning.github.io/posts/523021e3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>数据结构04-二分搜索树 | 菜鸟小宋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>
    
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">菜鸟小宋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    

  <a href="https://github.com/Sningning" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sningning.github.io/posts/523021e3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile_pic.jpg">
      <meta itemprop="name" content="Song Ningning">
      <meta itemprop="description" content="己所不欲 勿施于人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸟小宋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          数据结构04-二分搜索树
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-02 09:46:25" itemprop="dateCreated datePublished" datetime="2020-04-02T09:46:25+08:00">2020-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-01 11:23:41" itemprop="dateModified" datetime="2020-07-01T11:23:41+08:00">2020-07-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          
            <span id="/posts/523021e3/" class="post-meta-item leancloud_visitors" data-flag-title="数据结构04-二分搜索树" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/posts/523021e3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/523021e3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。把它叫做“树”是因为它看起来像一棵倒挂的树。</p>
<p>二分搜索树（Binary Search Tree，BST）相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 <code>O(log n)</code>。二分搜索树是基础性数据结构，用于构建更为抽象的数据结构。</p>
<p><strong><em>维基百科</em></strong></p>
</blockquote>
<a id="more"></a>


<h1 id="1-BST-基础"><a href="#1-BST-基础" class="headerlink" title="1. BST 基础"></a>1. BST 基础</h1><h2 id="1-1-二叉树"><a href="#1-1-二叉树" class="headerlink" title="1.1 二叉树"></a>1.1 二叉树</h2><p>二叉树（Binary tree）是每个结点最多只有两个分支的树结构。通常分支被称作“左孩子”和“右孩子”或“左子树”和“右子树”。</p>
<p>二叉树的性质：</p>
<ul>
<li>二叉树只有一个根结点</li>
<li>二叉树每个结点最多有两个孩子</li>
<li>每个结点最多有一个父亲</li>
<li>每个结点的左孩子也是一个二叉树</li>
<li>每个结点的右孩子也是一个二叉树</li>
</ul>
<p>二叉树不一定是“满”的，一个结点也是一个二叉树，<code>NULL</code> 也是一个二叉树。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/tree.png" width="500px"> </div>

<h2 id="1-2-BST"><a href="#1-2-BST" class="headerlink" title="1.2 BST"></a>1.2 BST</h2><p>二分搜索树是一种二叉树，除了二叉树的性质之外，二分搜索树还有如下性质：</p>
<ul>
<li>二分搜索树中每个结点的值：<ul>
<li>大于其左子树的所有结点的值</li>
<li>小于其右子树的所有结点的值</li>
</ul>
</li>
<li>任意结点的左、右子树也分别为二分搜索树</li>
</ul>
<p>为了能达到搜索的目的，二分搜索树存储的元素必须有可比较性。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/BST.png" width=""> </div>

<p>二分搜索树类中实现的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int getSize()</td>
<td align="center">获取二分搜索树中元素个数</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">返回二分搜索树是否为空</td>
</tr>
<tr>
<td align="center">void add(E e)</td>
<td align="center">向二分搜索树中添加新元素 e</td>
</tr>
<tr>
<td align="center">boolean contains(E e)</td>
<td align="center">查看二分搜索树中是否包含元素 e</td>
</tr>
<tr>
<td align="center">E minimum()</td>
<td align="center">查找二分搜索树的最小元素</td>
</tr>
<tr>
<td align="center">E maximum()</td>
<td align="center">查找二分搜索树的最大元素</td>
</tr>
<tr>
<td align="center">void preOrder()</td>
<td align="center">二分搜索树的前序遍历</td>
</tr>
<tr>
<td align="center">void inOrder()</td>
<td align="center">二分搜索树的中序遍历</td>
</tr>
<tr>
<td align="center">void postOrder()</td>
<td align="center">二分搜索树的后序遍历</td>
</tr>
<tr>
<td align="center">void levelOrder()</td>
<td align="center">二分搜索树的层序遍历</td>
</tr>
<tr>
<td align="center">E removeMin()</td>
<td align="center">从二分搜索树中删除最小值所在的结点，返回最小值</td>
</tr>
<tr>
<td align="center">E removeMax()</td>
<td align="center">从二分搜索树中删除最大值所在的结点，返回最大值</td>
</tr>
<tr>
<td align="center">void remove(E e)</td>
<td align="center">从二分搜索树中删除元素为 e 的结点</td>
</tr>
</tbody></table>
<p>根据二分搜索树的性质，可以将结点信息以及简单的方法先完成。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="2-向-BST-中添加元素"><a href="#2-向-BST-中添加元素" class="headerlink" title="2. 向 BST 中添加元素"></a>2. 向 BST 中添加元素</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void add(E e)</td>
<td align="center">向二分搜索树中添加新元素 e</td>
</tr>
</tbody></table>
<p>如果当前的二分搜索树为空，那么直接可以将新的元素添加，同时维护 <code>size</code>。</p>
<p>如果当前二分搜索树不为空，那么需要从根结点出发，先与根结点比较。</p>
<ul>
<li>比根结点大，往右子树插入；</li>
<li>比根结点小，往左子树插入；</li>
<li>和根结点相等，不做改变；（实现的二分搜索树不包含重复元素）</li>
</ul>
<p>这样依次递归下去，知道要插入的位置为空，那么就可以将该元素正确地添加到树中。因此可以写一个递归的方法来实现添加元素的操作。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add1.gif" width=""> </div>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add2.gif" width=""> </div>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add3.gif" width=""> </div>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add4.gif" width=""> </div>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add5.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向二分搜索树中添加新元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">        root = <span class="keyword">new</span> Node(e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        add(root, e)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向以 node 为根的二分搜索树中插入元素 e，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止的条件</span></span><br><span class="line">    <span class="keyword">if</span>(e.equals(node.e)) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span> &amp;&amp; node.left == <span class="keyword">null</span>) {</span><br><span class="line">        node.left = <span class="keyword">new</span> Node(e);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span> &amp;&amp; node.right == <span class="keyword">null</span>) {</span><br><span class="line">        node.right = <span class="keyword">new</span> Node(e);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归过程</span></span><br><span class="line">    <span class="keyword">if</span>(e.compareTo(node.e) &lt; <span class="number">0</span>) {</span><br><span class="line">        add(node.left, e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {  <span class="comment">//e.compareTo(node.e) &gt; 0</span></span><br><span class="line">        add(node.right, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="3-改进添加操作"><a href="#3-改进添加操作" class="headerlink" title="3. 改进添加操作"></a>3. 改进添加操作</h1><p>前面实现的添加操作中，对于 <code>root == null</code> 的情况进行了单独处理，但是提到过，<strong><code>null</code> 也是一个二分搜索树</strong>。因此，如果待插入的元素走到了一个 <code>null</code> 的位置，肯定要在这里新创建一个结点。</p>
<p>所以将之前递归代码的终止条件中，左右子树为空的条件去掉，让待插入元素再递归一层走到 <code>null</code>，和之前的递归过程相比，相当于多递归了一层，在 <code>null</code> 这个位置新建结点插入，然后将插入结点后的树返回给上一层递归调用，让进入递归前该结点的左子树或右子树接住这个变化，这样完成整个二分搜索树的更新。</p>
<p>如果待插入的元素和某一个结点元素相等，就直接将该结点返回给上层调用就可以了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向二分搜索树中添加新元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    add(root, e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向以 node 为根的二分搜索树中插入元素 e，递归算法</span></span><br><span class="line"><span class="comment">// 返回插入新结点后二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止的条件</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) {</span><br><span class="line">        node.left = add(node.left, e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e.compareTo(node.e) &gt; <span class="number">0</span>) {</span><br><span class="line">        node.right = add(node.right, e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 e.equals(node.e)，上面代码不执行，直接将该结点返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="4-BST-的查询操作"><a href="#4-BST-的查询操作" class="headerlink" title="4. BST 的查询操作"></a>4. BST 的查询操作</h1><p>二分搜索树的查询操作，分为查询指定元素 e 是否存在；查询树中最大元素和最小元素。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean contains(E e)</td>
<td align="center">查看二分搜索树中是否包含元素 e</td>
</tr>
<tr>
<td align="center">E minimum()</td>
<td align="center">查找二分搜索树的最小元素</td>
</tr>
<tr>
<td align="center">E maximum()</td>
<td align="center">查找二分搜索树的最大元素</td>
</tr>
</tbody></table>
<h2 id="4-1-查询指定元素"><a href="#4-1-查询指定元素" class="headerlink" title="4.1 查询指定元素"></a>4.1 查询指定元素</h2><p>要实现在二分搜索树中查询某个特定的元素是否存在，给定元素后，先与根结点比较，后续过程和添加元素操作一样，因此也可以使用递归来实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看二分搜索树中是否包含元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> contains(node, e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看以 node 为根的二分搜索树中是否包含元素 e，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止的条件</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e.equals(node.e)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> contains(node.left, e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> contains(node.right, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="4-2-查询最小元素和最大元素"><a href="#4-2-查询最小元素和最大元素" class="headerlink" title="4.2 查询最小元素和最大元素"></a>4.2 查询最小元素和最大元素</h2><p>根据二分搜索树的性质，当沿着树的左子树一直往下寻找，当到达最左端，也就是结点的左子树为空时，该结点中存储的元素就是整个树中的最小元素，最大元素相反，往右一直寻找。因此，寻找最小元素和最大元素的过程也是递归进行的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找二分搜索树的最小元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">minimum</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"树为空。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minimum(root).e;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回以 node 为根的二分搜索树的最小键值所在的结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止的条件</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找二分搜索树的最大元素（递归实现）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">maximum</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"树为空。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maximum(root).e;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回以 node 为根的二分搜索树的最大键值所在的结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">maximum</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maximum(node.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>在二分搜索树中寻找最小值和最大值的过程其实和对一个链表进行遍历是一样的操作，因此完全可以使用一个循环来找到相应的最小值和最大值。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找二分搜索树的最小元素（非递归实现）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">minimumNR</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"树为空。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur.left != <span class="keyword">null</span>) {</span><br><span class="line">        cur = cur.left;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur.e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找二分搜索树的最大元素（非递归实现）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">maximumNR</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"树为空。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur.right != <span class="keyword">null</span>) {</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur.e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="5-BST-的前、中、后序遍历"><a href="#5-BST-的前、中、后序遍历" class="headerlink" title="5. BST 的前、中、后序遍历"></a>5. BST 的前、中、后序遍历</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void preOrder()</td>
<td align="center">二分搜索树的前序遍历</td>
</tr>
<tr>
<td align="center">void inOrder()</td>
<td align="center">二分搜索树的中序遍历</td>
</tr>
<tr>
<td align="center">void postOrder()</td>
<td align="center">二分搜索树的后序遍历</td>
</tr>
</tbody></table>
<p>与添加和查询操作不同，二分搜索树的遍历操作要将二分搜索树所有的结点都访问一遍，而非仅仅是左子树或右子树。</p>
<p>运用递归操作，依然可以方便地对二分搜索树进行遍历操作。用递归方法遍历以 <code>node</code> 为根的二分搜索树，整体思路如下：</p>
<ul>
<li>开始：<ul>
<li><code>node</code> 为空：直接返回</li>
<li><code>node</code> 不为空：<ul>
<li>访问 <code>node</code></li>
<li>遍历 <code>node.left</code></li>
<li>遍历 <code>node.right</code></li>
</ul>
</li>
</ul>
</li>
<li>结束</li>
</ul>
<p>其中，递归调用发生在遍历左子树和右子树的操作中。根据访问 <code>node</code> 的顺序不同，遍历可以分为前序遍历、中序遍历、后序遍历。这里定义访问 <code>node</code> 的操作为打印 <code>node</code> 结点存储的元素。</p>
<br>

<h2 id="5-1-前序遍历"><a href="#5-1-前序遍历" class="headerlink" title="5.1 前序遍历"></a>5.1 前序遍历</h2><p>最主要的是实现遍历的递归函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>{</span><br><span class="line">    preOrder(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历以 node 为根的二分搜索树，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">    preOrder(node.left);</span><br><span class="line">    preOrder(node.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="5-2-中序遍历"><a href="#5-2-中序遍历" class="headerlink" title="5.2 中序遍历"></a>5.2 中序遍历</h2><p>中序遍历无非是把访问该结点信息的操作放在访问左子树和右子树中间，根据二分搜索树的性质可以知道，该结点左子树均是小于该结点的，右子树都是大于该结点的，因此，二分搜索树中序遍历的结果是顺序的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span> </span>{</span><br><span class="line">    inOrder(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历以 node 为根的二分搜索树，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    inOrder(node.left);</span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">    inOrder(node.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="5-3-后序遍历"><a href="#5-3-后序遍历" class="headerlink" title="5.3 后序遍历"></a>5.3 后序遍历</h2><p>后序遍历就是先访问该结点的左子树，再访问该结点的右子树，最后访问该结点。后序遍历的一个应用就是释放二分搜索树的内存，如果手动释放内存，就需要先将孩子结点的内存释放，最后再释放该结点的内存。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>{</span><br><span class="line">    postOrder(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历以 node 为根的二分搜索树，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    postOrder(node.left);</span><br><span class="line">    postOrder(node.right);</span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="5-4-再理解-BST-的遍历"><a href="#5-4-再理解-BST-的遍历" class="headerlink" title="5.4 再理解 BST 的遍历"></a>5.4 再理解 BST 的遍历</h2><p>对于二分搜索树的遍历，程序编写是简单的，但是如果面对一颗二分搜索树，怎样快速手写出前中后序遍历结果？</p>
<p>对于二分搜索树的每个结点，都有 3 次访问机会，分别是访问该结点左子树之前；访问左子树和右子树之间；访问右子树之后。分别对应下图的 3 个紫色的点。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/遍历.png" width="600px"> </div> <br>

<p>前序遍历过程中，真正打印该结点是在第 1 次访问该结点的时候。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/preOrder.gif" width=""> </div> <br>


<p>中序遍历过程中，真正打印该结点是在第 2 次访问该结点的时候。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/inOrder.gif" width=""> </div> <br>

<p>后序遍历过程中，真正打印该结点是在第 3 次访问该结点的时候。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/postOrder.gif" width=""> </div>

<hr>
<h1 id="6-BST-前序遍历的非递归实现"><a href="#6-BST-前序遍历的非递归实现" class="headerlink" title="6. BST 前序遍历的非递归实现"></a>6. BST 前序遍历的非递归实现</h1><p>利用栈来实现前序遍历，根据栈结构后入先出的性质，栈顶元素是要访问的元素，先访问该元素，然后将该元素弹出栈，随后将该结点的孩子压入栈，入栈顺序是右孩子先入栈，然后左孩子再入栈，这样，栈顶元素就是左孩子，然后访问左孩子，弹出栈，再依次压入它的右孩子和左孩子，依次进行。当栈为空时，完成遍历。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/preOrderNR.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的非递归前序遍历，非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderNR</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Deque&lt;Node&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line"></span><br><span class="line">        Node cur = stack.pop();</span><br><span class="line">        System.out.println(cur.e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) {  <span class="comment">// 右孩子先入栈</span></span><br><span class="line">            stack.push(cur.right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) {</span><br><span class="line">            stack.push(cur.left); </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="7-BST-的层序遍历"><a href="#7-BST-的层序遍历" class="headerlink" title="7. BST 的层序遍历"></a>7. BST 的层序遍历</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void levelOrder()</td>
<td align="center">二分搜索树的层序遍历</td>
</tr>
</tbody></table>
<p>二分搜索树的前中后序遍历都是在树的一侧一插到底，然后往回递归。层序遍历就是对于一个树，一层一层地对每个结点进行操作，层序遍历又称为<strong>广度优先遍历</strong>，相对应的，二分搜索树的前中后序遍历又称为<strong>深度优先遍历</strong>。对于二分搜索树的层序遍历，多是使用非递归实现，这里使用队列这种数据结构来实现二分搜索树的层序遍历。</p>
<p>队首元素是当前需要操作的元素，将队首元素出队，操作完成后，将该元素的左孩子和右孩子依次入队，知道队列为空，此时完成层序遍历。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/levelOrder.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的层序遍历（广度优先遍历）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Queue&lt;E&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line"></span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        System.out.println(cur.e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) {  <span class="comment">// 左孩子先入队</span></span><br><span class="line">            queue.offer(cur.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) { <span class="comment">// 右孩子再入队</span></span><br><span class="line">            queue.offer(cur.right); </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>广度优先遍历有时可以更快的找到指定的元素，如下图所示，当要找的元素在红点位置，但使用深度优先遍历会直接先插到底部从左边寻找，而这是如果采用广度优先遍历便可以很快找到答案。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/levelOrder1.gif" width=""> </div>

<p>在图中也存在深度优先遍历和广度优先遍历，不过在图中进行遍历时，需要记录一下该结点之前是否遍历过，因为对于图来说，每一个结点的前驱可能有多个。</p>
<hr>
<h1 id="8-删除-BST-中最小元素和最大元素"><a href="#8-删除-BST-中最小元素和最大元素" class="headerlink" title="8. 删除 BST 中最小元素和最大元素"></a>8. 删除 BST 中最小元素和最大元素</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">E removeMin()</td>
<td align="center">从二分搜索树中删除最小值所在的结点，返回最小值</td>
</tr>
<tr>
<td align="center">E removeMax()</td>
<td align="center">从二分搜索树中删除最大值所在的结点，返回最大值</td>
</tr>
</tbody></table>
<p>最小元素和最大元素所在的结点可能是叶子结点也可能不是叶子结点。</p>
<h2 id="8-1-删除-BST-中最小元素"><a href="#8-1-删除-BST-中最小元素" class="headerlink" title="8.1 删除 BST 中最小元素"></a>8.1 删除 BST 中最小元素</h2><p>如果最小元素所在的结点是叶子结点，可以直接将其删除。但是当待删除的结点有右子树时，将该结点删除后，还要再把其右子树赋给其父亲结点，也就是该结点左子树的根结点接替了该结点的位置。由于 <code>null</code> 也可以看做一个结点，因此，两个过程可以统一。最后维护 <code>size</code>。这里复用了之前的 <code>minmum()</code> 方法，因此不需要再对空树进行判断。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/removeMin.gif" width=""> </div>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/removeMin2.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从二分搜索树中删除最小值所在的结点，返回最小值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeMin</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    E ret = minmum();</span><br><span class="line">    root = removeMin(root);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除掉以 node 为根的二分搜索树中的最小结点</span></span><br><span class="line"><span class="comment">// 返回删除结点后新的二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) {</span><br><span class="line"></span><br><span class="line">        Node rightNode = node.right;</span><br><span class="line">        node.right = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    node.left = removeMin(node.left);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="8-2-删除-BST-中最大元素"><a href="#8-2-删除-BST-中最大元素" class="headerlink" title="8.2 删除 BST 中最大元素"></a>8.2 删除 BST 中最大元素</h2><p>删除最大元素和删除最小元素刚好相反，只需保存待删除结点的左子树即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从二分搜索树中删除最大值所在的结点，返回最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeMax</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    E ret = maximum();</span><br><span class="line">    root = removeMax(root);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除掉以 node 为根的二分搜索树中的最大结点</span></span><br><span class="line"><span class="comment">// 返回删除结点后新的二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMax</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) {</span><br><span class="line"></span><br><span class="line">        Node leftNode = node.left;</span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> leftNode;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    node.right = removeMax(node.right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="9-删除-BST-中任意元素"><a href="#9-删除-BST-中任意元素" class="headerlink" title="9. 删除 BST 中任意元素"></a>9. 删除 BST 中任意元素</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void remove(E e)</td>
<td align="center">从二分搜索树中删除元素为 e 的结点</td>
</tr>
</tbody></table>
<p>删除任意元素时，也是分成 3 种情况：</p>
<ul>
<li>待删除元素所在结点左子树为空</li>
<li>待删除元素所在结点右子树为空</li>
<li>待删除元素所在结点左右子树都存在</li>
</ul>
<p>前两种情况和删除最小元素和最大元素是类似：<br>如果左子树为空，暂存右子树，将该结点删除，然后将右子树的根结点返回给上一层递归调用；<br>如果右子树为空，暂存左子树，将该结点删除，然后将左子树的根结点返回给上一层递归调用。</p>
<p>当待删除元素所在结点左右子树都存在时，这里采用<strong>Hibbard Deletion</strong>。</p>
<div class="note primary">
            <p><strong>Delete</strong>. We can proceed in a similar manner to delete any node that has one child (or no children), but what can we do to delete a node that has two children? We are left with two links, but have a place in the parent node for only one of them. An answer to this dilemma, first proposed by T. Hibbard in 1962, is to delete a node x by replacing it with its successor. Because x has a right child, its successor is the node with the smallest key in its right subtree. The replacement preserves order in the tree because there are no keys between x.key and the successor’s key. We accomplish the task of replacing x by its successor in four (!) easy steps:</p><ul><li>Save a link to the node to be deleted in t</li><li>Set x to point to its successor min(t.right).</li><li>Set the right link of x (which is supposed to point to the BST containing all the keys larger than x.key) to deleteMin(t.right), the link to the BST containing all the keys that are larger than x.key after the deletion.</li><li>Set the left link of x (which was null) to t.left (all the keys that are less than both the deleted key and its successor).</li></ul><p><strong><em>Algorithms(4th edition) P410</em></strong></p>
          </div>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/Algorithms(4th edition).png" width=""> </div>

<p>再来几个动画演示。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/visualgo.net.gif" width=""> </div> <br>

<p>一句话概括就是，找到待删除结点右子树中的最小值所在结点，用此结点接替待删除的结点。简单描述下过程：</p>
<p>d 为待删除结点</p>
<ul>
<li>找到 s = min( s-&gt;right ), s 是 d 的后继</li>
<li>s-&gt;right = delMin( d-&gt;right )</li>
<li>s-&gt;left = d-&gt;left</li>
<li>删除 d, s 是新的子树的根</li>
</ul>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/remove.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从二分搜索树中删除元素为 e 的结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">remove</span><span class="params">(E e)</span> </span>{</span><br><span class="line">  remove(root, e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除掉以 node 为根的二分搜索树中值为e的结点, 递归算法</span></span><br><span class="line"><span class="comment">// 返回删除结点后新的二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) {</span><br><span class="line">        node.left = remove(node.left, e);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) {</span><br><span class="line">        node.right = remove(node.right, e);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {  <span class="comment">// e.compareTo(node.e) == 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除结点左子树为空的情况</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) {</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除结点右子树为空的情况</span></span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) {</span><br><span class="line">            Node leftNode = node.left;</span><br><span class="line">            node.left = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除结点左右子树均不为空的情况</span></span><br><span class="line">        <span class="comment">// 找到比待删除结点大的最小结点, 即待删除结点右子树的最小结点</span></span><br><span class="line">        <span class="comment">// 用这个结点顶替待删除结点的位置</span></span><br><span class="line">        Node successor = minimum(node.right);</span><br><span class="line">        successor.right = removeMin(node.right);</span><br><span class="line">        successor.left = node.left;</span><br><span class="line">        node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在最后一个 <code>else</code> 语句中，用了 2 个 <code>if</code>，而没有使用 <code>else if</code>，这是因为满足进入第一个 <code>if</code> 之后，里面直接 <code>return</code> 了，不会再去进行另一个 <code>if</code> 了，因此用 2 个 <code>if</code> 是没问题的。</p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://coding.imooc.com/class/207.html" target="_blank" rel="noopener">玩转数据结构</a></li>
<li><a href="https://visualgo.net/zh" target="_blank" rel="noopener">VisuAlgo</a></li>
<li><a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">算法(第4版)</a></li>
<li><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">Algorithms(4th edition)</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Song Ningning 支付宝">
        <p>支付宝</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Song Ningning 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Song Ningning
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://sningning.github.io/posts/523021e3/" title="数据结构04-二分搜索树">https://sningning.github.io/posts/523021e3/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="fa fa-tag"></i> 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/ee7bd491/" rel="prev" title="数据结构03-链表">
      <i class="fa fa-chevron-left"></i> 数据结构03-链表
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/f0688a92/" rel="next" title="软件工具使用技巧、问题">
      软件工具使用技巧、问题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-BST-基础"><span class="nav-text">1. BST 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-二叉树"><span class="nav-text">1.1 二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-BST"><span class="nav-text">1.2 BST</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-向-BST-中添加元素"><span class="nav-text">2. 向 BST 中添加元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-改进添加操作"><span class="nav-text">3. 改进添加操作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-BST-的查询操作"><span class="nav-text">4. BST 的查询操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-查询指定元素"><span class="nav-text">4.1 查询指定元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-查询最小元素和最大元素"><span class="nav-text">4.2 查询最小元素和最大元素</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-BST-的前、中、后序遍历"><span class="nav-text">5. BST 的前、中、后序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-前序遍历"><span class="nav-text">5.1 前序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-中序遍历"><span class="nav-text">5.2 中序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-后序遍历"><span class="nav-text">5.3 后序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-再理解-BST-的遍历"><span class="nav-text">5.4 再理解 BST 的遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-BST-前序遍历的非递归实现"><span class="nav-text">6. BST 前序遍历的非递归实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-BST-的层序遍历"><span class="nav-text">7. BST 的层序遍历</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-删除-BST-中最小元素和最大元素"><span class="nav-text">8. 删除 BST 中最小元素和最大元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-删除-BST-中最小元素"><span class="nav-text">8.1 删除 BST 中最小元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-删除-BST-中最大元素"><span class="nav-text">8.2 删除 BST 中最大元素</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-删除-BST-中任意元素"><span class="nav-text">9. 删除 BST 中任意元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Song Ningning"
      src="/images/profile_pic.jpg">
  <p class="site-author-name" itemprop="name">Song Ningning</p>
  <div class="site-description" itemprop="description">己所不欲 勿施于人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Sningning" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sningning" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/qfsnn1117@126.com" title="E-Mail → qfsnn1117@126.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Song Ningning</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">80k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:13</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'pBbqtWKVEqWEt7mPeHsCoC3Q-gzGzoHsz',
      appKey     : 'Tb92Uo4lbYgTBTGR2aWri46v',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
