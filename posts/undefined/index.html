<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
<meta name="baidu-site-verification" content="jrFWF6ybrX" />
<meta name="google-site-verification" content="pFsBfeKIAL6_5hJXpfcJ9hnJveKoB1Bx53OvTyaW8vU" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo_180x180.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo_32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo_16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="true">
  <meta name="msvalidate.01" content="true">
  <meta name="baidu-site-verification" content="true">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic|Fira Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sningning.github.io","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>



  <meta name="description" content="Java 多线程基础知识学习。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 多线程基础知识">
<meta property="og:url" content="https://sningning.github.io/posts/undefined/index.html">
<meta property="og:site_name" content="菜鸟小宋">
<meta property="og:description" content="Java 多线程基础知识学习。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WithoutSleep1000.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WithoutSleep500.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WithSleep.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WithSleepEveryLoop.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/cantinterrupt.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WrongWayStopThread.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/RightWayStopThreadInProd1.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/RightWayStopThreadInProd2.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WrongWayVolatile.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WrongWayVolatileCantStop.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WrongWayVolatileFixed.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/RightWayInterrupted.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/ThreadStates.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/NewRunnableTerminated_1.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/NewRunnableTerminated_2.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/NewRunnableTerminated_3.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/BlockedWaitingTimedWaiting.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/ThreadStates.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/Wait.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WaitNotifyAll_1.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WaitNotifyAll_2.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WaitNotifyAll_3.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WaitNotifyReleaseOwnMonitor.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/Java_Monator.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/SleepDontReleaseMonitor.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/SleepDontReleaseLock.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/SleepInterrupted.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/Join_1.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/Join_2.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/JoinInterrupt.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/JoinThreadState.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/JoinPrinciple.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/Id.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/ExceptionInChildThread.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/CantCatchDirectly_1.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/CantCatchDirectly_1.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/MyUncaughtExceptionHanlder.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/JavaException.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/a++Error.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/deadlock.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/MultiThreadsError5.png">
<meta property="article:published_time" content="2020-04-27T15:34:01.000Z">
<meta property="article:modified_time" content="2020-09-09T09:16:56.993Z">
<meta property="article:author" content="Song Ningning">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WithoutSleep1000.png">

<link rel="canonical" href="https://sningning.github.io/posts/undefined/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>Java 多线程基础知识 | 菜鸟小宋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>
    
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">菜鸟小宋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    

  <a href="https://github.com/Sningning" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sningning.github.io/posts/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile_pic.jpg">
      <meta itemprop="name" content="Song Ningning">
      <meta itemprop="description" content="己所不欲 勿施于人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸟小宋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          Java 多线程基础知识
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-27 23:34:01" itemprop="dateCreated datePublished" datetime="2020-04-27T23:34:01+08:00">2020-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-09 17:16:56" itemprop="dateModified" datetime="2020-09-09T17:16:56+08:00">2020-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span id="/posts/undefined/" class="post-meta-item leancloud_visitors" data-flag-title="Java 多线程基础知识" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/posts/undefined/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/undefined/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Java 多线程基础知识学习。</p>
<a id="more"></a>

<h1 id="1-创建多线程的方式"><a href="#1-创建多线程的方式" class="headerlink" title="1. 创建多线程的方式"></a>1. 创建多线程的方式</h1><p>实现多线程本质上是两种方式：<strong>继承 Thread 类并重写 run() 方法</strong>和<strong>实现 Runnable 接口</strong>。其他的方法，例如实现 Callable 接口、线程池等，也能新建线程，但是从源码看，其他方式都是这两种方式的变种。</p>
<h2 id="1-1-Thread-类官方文档"><a href="#1-1-Thread-类官方文档" class="headerlink" title="1.1 Thread 类官方文档"></a>1.1 Thread 类官方文档</h2><p>查看下 JDK 1.8 <a href="https://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="noopener">官方文档</a>：</p>
<blockquote>
<p>There are <u><strong>two ways</strong></u> to create a new thread of execution. One is to <u>declare a class to be a subclass of <code>Thread</code></u>. This subclass should override the <code>run</code> method of class <code>Thread</code>. An instance of the subclass can then be allocated and started. For example, a thread that computes primes larger than a stated value could be written as follows:</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> minPrime;</span><br><span class="line">    PrimeThread(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">        <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">         . . .</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>The following code would then create a thread and start it running:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrimeThread p = <span class="keyword">new</span> PrimeThread(<span class="number">143</span>);</span><br><span class="line">p.start();</span><br></pre></td></tr></table></figure>

<p>The other way to create a thread is to declare a class that <u>implements the <code>Runnable</code> interface</u>. That class then implements the <code>run</code> method. An instance of the class can then be allocated, passed as an argument when creating <code>Thread</code>, and started. The same example in this other style looks like the following:</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> minPrime;</span><br><span class="line">    PrimeRun(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">        <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">         . . .</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<p>The following code would then create a thread and start it running:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrimeRun p = <span class="keyword">new</span> PrimeRun(<span class="number">143</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(p).start();</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="1-2-两种创建多线程的方式"><a href="#1-2-两种创建多线程的方式" class="headerlink" title="1.2 两种创建多线程的方式"></a>1.2 两种创建多线程的方式</h2><ul>
<li>用继承 Thread 类方式实现线程：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用继承 Thread 类方式实现线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-04-27 23:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStyle</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用继承 Thread 类方式实现线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadStyle().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用实现 Runnable 接口方式创建线程：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用实现 Runnable 接口方式创建线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-04-27 23:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableStyle</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用实现 Runnable 接口方式创建线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableStyle());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>Thread 类的 run 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再仔细看下源码，可以发现，创建线程最终还是通过继承 Thread 类这种方式。但是类里面的 run 方法有两种方式来实现：</p>
<ul>
<li><p>对于直接继承 Thread 这种方式，是直接重写了 run 方法；</p>
</li>
<li><p>对于实现 Runnable 接口这种方式，是实现 Runnable 接口中的 run 方法，然后把该 Runnable 实例作为 target 传给 Thread 类，最终执行的是 target 中实现的 run 方法。</p>
</li>
</ul>
<p>因此，如果同时用以上两种方法实现一个线程，执行的肯定是被重写的 run 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同时使用 Runnable 和 Thread 两种方式实现线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-04-27 23:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BothRunnableThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Runnable"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Thread"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 输出：Thread</span><br></pre></td></tr></table></figure>


<h2 id="1-3-其他方式"><a href="#1-3-其他方式" class="headerlink" title="1.3 其他方式"></a>1.3 其他方式</h2><p>再看下其他几种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FutureTask + Callable</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-04-30 16:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Callable Style"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> CallableDemo()));</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadPool</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-04-28 23:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"ThreadPool"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TimerTask</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-04-29 0:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimmerTaskDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"TimerTask"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="【问题】实现-Runnable-接口和继承-Thread-类哪种方式更好一些？"><a href="#【问题】实现-Runnable-接口和继承-Thread-类哪种方式更好一些？" class="headerlink" title="【问题】实现 Runnable 接口和继承 Thread 类哪种方式更好一些？"></a>【问题】实现 Runnable 接口和继承 Thread 类哪种方式更好一些？</h2><p>实现 Runnable 接口的方式会更好些。</p>
<ul>
<li><p>从代码架构角度来看，具体的任务（run 方法）应该和 “创建和运行线程的机制（Thread类）” 解耦，用 Runnable 对象可以实现解耦。通过 Runnable 方式实现的 run 方法中的内容是具体执行的任务，可以让一个单独任务类实现 Runnable 接口，然后把对应的实例传入 Thread 类就可以。这样的话，同样的一个任务类，可以传给不同的 Thread，并且任务类也不负责创建线程等工作，是解耦的。</p>
</li>
<li><p>使用继承 Thread 的方式的话，每次新建一个任务，只能新建一个独立的线程，而这样做的损耗会比较大（比如重头开始创建一个线程、执行完毕以后再销毁等。如果线程的实际工作内容，也就是 run() 函数里只是执行一些简单的操作，那么创建线程的损耗可能远大于线程的实际工作内容）。如果使用 Runnable 和线程池，就可以大大减小这样的损耗。</p>
</li>
<li><p>继承 Thread 类以后，由于 Java 语言不支持多继承，这样就无法再继承其他的类，限制了可扩展性。</p>
</li>
</ul>
<p>继承 Thread 类也有几个好处，比如：</p>
<ul>
<li><p>在 run () 方法内获取当前线程可以直接用 this，而无须用 Thread. currentThread () 方法；</p>
</li>
<li><p>继承的类的内部变量不会直接共享，少数不需要共享变量的场景下使用起来会更方便。</p>
</li>
</ul>
<p>但是和其缺点相比，优点就不值一提了。</p>
<hr>
<h1 id="2-启动线程的方式"><a href="#2-启动线程的方式" class="headerlink" title="2. 启动线程的方式"></a>2. 启动线程的方式</h1><p>用<code>start()</code>方法启动线程。</p>
<h2 id="2-1-start-方法含义"><a href="#2-1-start-方法含义" class="headerlink" title="2.1 start() 方法含义"></a>2.1 start() 方法含义</h2><h3 id="2-1-1-启动新线程"><a href="#2-1-1-启动新线程" class="headerlink" title="2.1.1 启动新线程"></a>2.1.1 启动新线程</h3><p>线程对象在初始化之后，调用 start() 方法。实际上，start() 是由当前线程（通常是主线程）来执行的，此时当前线程就会<strong>通知</strong> JVM 在有空闲的情况下来启动新线程。因此，启动新线程的本质就是请求 JVM 来运行新线程。至于什么时候能运行，是由线程调度器来决定的。所以，调用了 start() 方法后，并不意味着新线程就运行了，有可能 Thread-01 先执行了 start()，Thread-02 后执行 start()，但实际是 Thread-02 先运行了。</p>
<h3 id="2-1-2-准备工作"><a href="#2-1-2-准备工作" class="headerlink" title="2.1.2 准备工作"></a>2.1.2 准备工作</h3><p>在执行 start() 方法之后和真正启动该线程之前，还有很多准备工作。该线程会处于就绪状态，这表明，该线程已经获得了除 CPU 以外的其他资源，在做完准备工作之后，才可能被 CPU 调度到执行状态，等待获取 CPU 资源，然后才会真正进入到运行状态来执行 run() 方法中的代码。</p>
<h3 id="2-1-3-重复调用-start-方法"><a href="#2-1-3-重复调用-start-方法" class="headerlink" title="2.1.3 重复调用 start() 方法"></a>2.1.3 重复调用 start() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不能两次调用start方法，否则会报错</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-04-29 17:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CantStartTwice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码调用了两次 start() 方法，抛出的异常是</p>
<p> <code>Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException</code></p>
<p>执行了 start() 方法之后，线程状态从 <code>New</code> 进入到后续的状态，一旦线程执行完毕，线程就会进入<code>Teminated</code>状态，此时就不能再返回了。 </p>
<h2 id="2-2-start-源码"><a href="#2-2-start-源码" class="headerlink" title="2.2 start() 源码"></a>2.2 start() 源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is not invoked for the main method thread or "system"</span></span><br><span class="line"><span class="comment">     * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">     * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">     * and the group's unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 native 的 start0() 方法</span></span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>检查线程状态</p>
<p>Thread 类的 start() 方法源码中，执行的第一件事就是检查线程状态。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br></pre></td></tr></table></figure>
<p>  threadStatus 定义在 Thread 类中，0 代表线程刚刚初始化完成，还没有启动。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Java thread status for tools,</span></span><br><span class="line"><span class="comment"> * initialized to indicate thread 'not yet started'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> threadStatus = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>因此，只有<code>New</code>状态下的线程才能继续执行后面的内容，否则会抛出 <code>IllegalThreadStateException</code>。</p>
</li>
<li><p>加入线程组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment"> * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment"> * and the group's unstarted count can be decremented. */</span></span><br><span class="line">group.add(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 start0() 方法</p>
<p>start0() 方法是个 native 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="3-停止线程的方式"><a href="#3-停止线程的方式" class="headerlink" title="3. 停止线程的方式"></a>3. 停止线程的方式</h1><h2 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h2><p><strong>使用 interrupt 来通知，而不是强制。</strong></p>
<p>线程大部分是会运行到结束，自然停止。有些时候会主动停止线程，比如用户主动取消、服务被突然关闭、运行超时或者出错等。</p>
<p>Java 没有正确、安全停止线程的机制，但是 Java  提供了 interrupt 这种合作机制，即用一个线程 <strong>通知</strong> 另一个线程让其停止当前工作。因此，在 Java 中，要想停止一个线程，能做的就是通知其中断，但被中断线程本身有决定权，可以决定何时响应中断、何时停止、以及是否停止。所以，想停止线程的一方是没有能力去强制停止一个线程的。</p>
<p>因为对于想要停止线程的一方来说，其对被停止线程的逻辑可能是不了解的，只有被停止线程本身才是最熟悉自身的，他自身更清楚该如何执行后续的停止和清理工作，因此 Java 将停止线程的主动权交给被停止线程本身。</p>
<p>所以，想要正确停止线程，其实是如何正确用 interrupt 通知被停止线程，以及被停止线程如何配合。</p>
<h2 id="3-2-正确停止线程-star"><a href="#3-2-正确停止线程-star" class="headerlink" title="3.2 正确停止线程(:star:)"></a>3.2 正确停止线程(:star:)</h2><h3 id="3-2-1-线程会在什么情况下停止"><a href="#3-2-1-线程会在什么情况下停止" class="headerlink" title="3.2.1 线程会在什么情况下停止"></a>3.2.1 线程会在什么情况下停止</h3><ul>
<li>run() 方法所有代码执行完毕</li>
<li>出现异常，而且没有被捕获</li>
</ul>
<h3 id="3-2-2-正确的停止方法：interrupt"><a href="#3-2-2-正确的停止方法：interrupt" class="headerlink" title="3.2.2 正确的停止方法：interrupt"></a>3.2.2 正确的停止方法：interrupt</h3><ul>
<li>通常情况下如何停止</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * run 方法内没有 sleep 或 wait 方法时，停止线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-04-30 19:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWaysStopThreadWithoutSleep</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; </span><br><span class="line">               num &lt;= (Integer.MAX_VALUE &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            System.out.println(num + <span class="string">"是 10000 的倍数"</span>);</span><br><span class="line">            num += <span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"运行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightWaysStopThreadWithoutSleep());</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Thread.sleep(1000)</code>时</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WithoutSleep1000.png" width=""/> </div>

<p><code>Thread.sleep(500)</code>时</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WithoutSleep500.png" width=""/> </div>

<p>线程的 run 方法是从 10000 开始，一直输出 10000 的倍数，直到小于等于 Integer.MAX_VALUE 的一半，在执行到 1 s 后，调用 interrupt 方法，为了能让线程响应中断，run 方法的循环条件中加上<code>!Thread.currentThread().isInterrupted()</code>判断，即不被中断才继续执行。</p>
<ul>
<li>线程可能被阻塞</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * run 方法中带有 sleep 的中断线程的写法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-04-30 23:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWaysStopThreadWithSleep</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (num &lt;= <span class="number">300</span> &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(num + <span class="string">" 是 100 的倍数"</span>);</span><br><span class="line">                    num += <span class="number">100</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WithSleep.png" width=""/> </div>

<p>run 方法执行完循环之后，调用 sleep 方法进入阻塞状态，在线程处于阻塞状态时，请求中断。休眠过程中收到请求中断的信号时，此时响应的方式就是抛出异常并被捕获：<code>InterruptedException: sleep interrupted</code>。</p>
<ul>
<li>线程在每次迭代后都阻塞</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果在执行过程中，每次循环都会调用 sleep 或 wait 等方法，</span></span><br><span class="line"><span class="comment"> * 那么不需要每次迭代都检查是否已中断</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-04-30 23:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadWithSleepEveryLoop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (num &lt;= <span class="number">10000</span>) &#123;</span><br><span class="line">                    System.out.println(num + <span class="string">" 是 100 的倍数"</span>);</span><br><span class="line">                    num += <span class="number">100</span>;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WithSleepEveryLoop.png" width=""/> </div>

<p>如果每次循环中都加入 sleep，即每次迭代都会阻塞，此时不再需要在循环条件中添加<code>!Thread.currentThread().isInterrupted()</code>的判断。抛出异常并被捕获：<code>InterruptedException: sleep interrupted</code>。</p>
<p><strong>while 内 try / catch 的问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果 while 里面放 try/catch，会导致中断失效</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-01 0:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CantInterrupt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">10000</span> &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(num + <span class="string">" 是 100 的倍数"</span>);</span><br><span class="line">                num += <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/cantinterrupt.png" width="650px"/> </div>

<p>如果将 try / catch 放在 while 循环里面，在当前轮的循环中响应了中断请求，但循环还是会继续。即便在循环条件中加入<code>!Thread.currentThread().isInterrupted()</code>判断，依然无法停止线程，这是因为 sleep 方法一旦响应中断，便会把 interrupt 标志位清除，导致 while 循环的判断条件检测不到中断状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Causes the currently executing thread to sleep (temporarily cease</span></span><br><span class="line"><span class="comment"> * execution) for the specified number of milliseconds, subject to</span></span><br><span class="line"><span class="comment"> * the precision and accuracy of system timers and schedulers. The thread</span></span><br><span class="line"><span class="comment"> * does not lose ownership of any monitors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment"> *         the length of time to sleep in milliseconds</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment"> *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment"> *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-3-两种较好的停止线程方式"><a href="#3-2-3-两种较好的停止线程方式" class="headerlink" title="3.2.3 两种较好的停止线程方式"></a>3.2.3 两种较好的停止线程方式</h3><h4 id="3-2-3-1-优先选择：传递中断"><a href="#3-2-3-1-优先选择：传递中断" class="headerlink" title="3.2.3.1 优先选择：传递中断"></a>3.2.3.1 优先选择：传递中断</h4><p>反例：在低级层次处理异常。</p>
<p>下面的 Demo 中，线程在执行 throwInMethod 方法时被中断，同时，将异常在 throwInMethod 方法中进行了处理，将异常“吞掉了”，并没有“上报”给调用它的线程，实际上应该是由调用  throwInMethod 的线程来处理中断请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadInProd1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 反例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span> &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"go"</span>);</span><br><span class="line">            throwInMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">throwInMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightWayStopThreadInProd1());</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WrongWayStopThread.png" width=""/> </div>

<p>因此，对于设计  throwInMethod 方法的人来说，最好是将异常抛出，由调用者来处理。对于设计 run 方法的人来说，应该检查  throwInMethod 方法是否错误的处理了中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * catch 住 InterruptedExcetion 之后的优先选择：</span></span><br><span class="line"><span class="comment"> * 在方法签名中抛出异常，在 run() 就会强制 try/catch</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-01 1:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadInProd1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span> &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"go"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                throwInMethod();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 响应中断的操作</span></span><br><span class="line">                <span class="comment">// 保存日志、停止程序等</span></span><br><span class="line">                System.out.println(<span class="string">"正确处理了中断请求"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">throwInMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightWayStopThreadInProd1());</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/RightWayStopThreadInProd1.png" width="500px"/></div>



<h4 id="3-2-3-2-不想或无法传递：恢复中断"><a href="#3-2-3-2-不想或无法传递：恢复中断" class="headerlink" title="3.2.3.2 不想或无法传递：恢复中断"></a>3.2.3.2 不想或无法传递：恢复中断</h4><p>如果不抛出异常，就应该在 catch 子语句中调用 Thread.currentThread().interrupt() 来恢复设置中断状态，以便于在后续的执行中，依然能够检查到刚才发生了中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 catch 子语句中调用 Thread.currentThread().interrupt() 来恢复设置中断状态，</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-01 23:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadInProd2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Interrupted，程序运行结束"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"go"</span>);</span><br><span class="line">            reInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 恢复中断状态</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightWayStopThreadInProd2());</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/RightWayStopThreadInProd2.png" width="500px"/> </div>

<p><strong>一句话总结就是：不应屏蔽中断。</strong></p>
<table>
<thead>
<tr>
<th align="left">响应中断的方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Object. wait()/ wait( long)/ wait( long, int)</td>
</tr>
<tr>
<td align="left">Thread. sleep( long) /sleep( long, int)</td>
</tr>
<tr>
<td align="left">Thread. join()/ join( long)/ join( long, int)</td>
</tr>
<tr>
<td align="left">java. util. concurrent. BlockingQueue. take() /put( E)</td>
</tr>
<tr>
<td align="left">java. util. concurrent. locks. Lock. lockInterruptibly()</td>
</tr>
<tr>
<td align="left">java. util. concurrent. CountDownLatch. await()</td>
</tr>
<tr>
<td align="left">java. util. concurrent. CyclicBarrier. await()</td>
</tr>
<tr>
<td align="left">java. util. concurrent. Exchanger. exchange(V)</td>
</tr>
<tr>
<td align="left">java.nio.channels.InterruptibleChannel相关方法</td>
</tr>
<tr>
<td align="left">java.nio.channels.Selector的相关方法</td>
</tr>
</tbody></table>
<h3 id="【问题】正确停止线程的好处？"><a href="#【问题】正确停止线程的好处？" class="headerlink" title="【问题】正确停止线程的好处？"></a>【问题】正确停止线程的好处？</h3><p>被中断的线程自身拥有如何响应中断的权利，因为有些线程的某些代码是很重要的，必须要等待这些线程处理完之后，再由线程自己去主动终止。因此不应该鲁莽的使用 stop 方法，而是通过使用 interrupt 来发出一个信号，让线程自己去处理，这样使线程代码在实际中更加安全。</p>
<h2 id="3-3-错误停止线程方式-star"><a href="#3-3-错误停止线程方式-star" class="headerlink" title="3.3 错误停止线程方式(:star:)"></a>3.3 错误停止线程方式(:star:)</h2><h3 id="3-3-1-被弃用的-stop、suspend-和-resume-方法"><a href="#3-3-1-被弃用的-stop、suspend-和-resume-方法" class="headerlink" title="3.3.1 被弃用的 stop、suspend 和 resume 方法"></a>3.3.1 被弃用的 stop、suspend 和 resume 方法</h3><p>stop 被弃用是因为该方法本质是不安全的，不过该方法是会释放掉所有监视器的。参考：<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html" target="_blank" rel="noopener">Java Thread Primitive Deprecation</a></p>
<blockquote>
<p>This method is inherently unsafe.  Stopping a thread with <code>Thread.stop</code> causes it to unlock all of the monitors that it has locked (as a natural consequence of the unchecked <code>ThreadDeath</code> exception propagating up the stack).</p>
</blockquote>
<p>suspend 和 resume 方法可能会造成死锁。</p>
<blockquote>
<p>This method has been deprecated, as it is inherently deadlock-prone.</p>
</blockquote>
<h3 id="3-3-2-用-volatile-设置-boolean-标记位"><a href="#3-3-2-用-volatile-设置-boolean-标记位" class="headerlink" title="3.3.2 用 volatile 设置 boolean 标记位"></a>3.3.2 用 volatile 设置 boolean 标记位</h3><ul>
<li><strong>看似可行</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示用 volatile 的局限：看似可行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-03 1:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongWayVolatile</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">100000</span> &amp;&amp; !canceled) &#123;</span><br><span class="line">                System.out.println(num + <span class="string">"是 100 的倍数"</span>);</span><br><span class="line">                num += <span class="number">100</span>;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        WrongWayVolatile r = <span class="keyword">new</span> WrongWayVolatile();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        r.canceled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WrongWayVolatile.png" width=""/> </div>

<ul>
<li><strong>错误之处</strong></li>
</ul>
<p>用 volatile 设置 boolean 标记位无法处理长时间阻塞的情况。</p>
<p>Demo 中，生产者生产 100 的倍数 put 到阻塞队列中，消费者从中消费 ；生产者生产速度快于消费者消费速度，所以阻塞队列满了以后，生产者会阻塞，等待消费者进一步消费。消费者中的 needMoreNums 有一定概率会将生产者中的 canceled 置为 true，意图使生产者停止生产。但实际运行情况可以看到，当消费者将 canceled 置为 true 之后，”生产者结束运行” 这条语句并没有输出，生产者依然没有停止生产。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示用 volatile 的局限：陷入阻塞时，volatile是无法停止线程的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-05 22:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongWayVolatileCantStop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayBlockingQueue&lt;Integer&gt; storage = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产</span></span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Thread producerThread = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">        producerThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(storage);</span><br><span class="line">        <span class="keyword">while</span> (consumer.needMoreNums()) &#123;</span><br><span class="line">            System.out.println(consumer.storage.take() + <span class="string">"被消费了"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"消费者不需要更多数据了"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一旦消费不需要更多数据了，应该尝试让生产者也停下来</span></span><br><span class="line">        producer.canceled = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(producer.canceled);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line">        BlockingQueue storage;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.storage = storage;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (num &lt;= <span class="number">10000</span> &amp;&amp; !canceled) &#123;</span><br><span class="line">                    storage.put(num);</span><br><span class="line">                    System.out.println(num + <span class="string">"是 100 的倍数，已被加到仓库中"</span>);</span><br><span class="line">                    num += <span class="number">100</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"生产者结束运行"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue storage;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.storage = storage;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needMoreNums</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.95</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WrongWayVolatileCantStop.png" width="400px"/></div>

<ul>
<li><strong>修正方案</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用中断来修复 WrongWayVolatileCantStop 中无尽等待问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-05 23:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongWayVolatileFixed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayBlockingQueue storage = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Thread producerThread = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">        producerThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(storage);</span><br><span class="line">        <span class="keyword">while</span> (consumer.needMoreNums()) &#123;</span><br><span class="line">            System.out.println(consumer.storage.take() + <span class="string">"被消费了"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"消费者不需要更多数据了"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一旦消费不需要更多数据了，应该让生产者也停下来</span></span><br><span class="line">        producerThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue storage;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.storage = storage;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (num &lt;= <span class="number">10000</span> &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    storage.put(num);</span><br><span class="line">                    System.out.println(num + <span class="string">"是 100 的倍数，已被加到仓库中"</span>);</span><br><span class="line">                    num += <span class="number">100</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"生产者结束运行"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue storage;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.storage = storage;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needMoreNums</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.95</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WrongWayVolatileFixed.png" width="500px"/></div>

<h2 id="3-4-几个方法"><a href="#3-4-几个方法" class="headerlink" title="3.4 几个方法"></a>3.4 几个方法</h2><h3 id="3-4-1-interrupt"><a href="#3-4-1-interrupt" class="headerlink" title="3.4.1 interrupt()"></a>3.4.1 interrupt()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到 blockerLock</span></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">interrupt0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>都需要调用 interrupt0() 方法，而 interrupt0()  是个 native 方法。</p>
<h3 id="3-4-2-判断是否已被中断的-2-个方法"><a href="#3-4-2-判断是否已被中断的-2-个方法" class="headerlink" title="3.4.2 判断是否已被中断的 2 个方法"></a>3.4.2 判断是否已被中断的 2 个方法</h3><p><code>public static boolean interrupted()</code></p>
<p>该方法是静态方法，内部调用当前线程的 isInterrupted() 方法，获取<strong>当前线程</strong>的中断状态，并且会清除线程的状态标记。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tests whether the current thread has been interrupted.  The</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tests if some Thread has been interrupted.  The interrupted state</span></span><br><span class="line"><span class="comment"> * is reset or not based on the value of ClearInterrupted that is</span></span><br><span class="line"><span class="comment"> * passed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>



<p><code>public boolean isInterrupted()</code></p>
<p>该方法是一个实例方法，获取<strong>调用该方法的对象所表示的线程</strong>的中断状态，不会清除线程的状态标记。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted</span></span><br><span class="line"><span class="comment"> * status&lt;/i&gt; of the thread is unaffected by this method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Thread.interrupted() 的目标对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 Thread.interrupted() 方法的目标对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-06 0:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayInterrupted</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        threadOne.start();</span><br><span class="line">        <span class="comment">//设置中断标志</span></span><br><span class="line">        threadOne.interrupt();</span><br><span class="line">        <span class="comment">//获取中断标志---①</span></span><br><span class="line">        System.out.println(<span class="string">"isInterrupted: "</span> + threadOne.isInterrupted());</span><br><span class="line">        <span class="comment">//获取中断标志并重置---②</span></span><br><span class="line">        System.out.println(<span class="string">"isInterrupted: "</span> + threadOne.interrupted());</span><br><span class="line">        <span class="comment">//获取中断标志并重置---③</span></span><br><span class="line">        System.out.println(<span class="string">"isInterrupted: "</span> + Thread.interrupted());</span><br><span class="line">        <span class="comment">//获取中断标志---④</span></span><br><span class="line">        System.out.println(<span class="string">"isInterrupted: "</span> + threadOne.isInterrupted());</span><br><span class="line">        threadOne.join();</span><br><span class="line">        System.out.println(<span class="string">"Main thread is over."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态的 interrupted() 方法的目标对象是“当前线程”，而不管本方法来自于哪个对象。</p>
<p>由于 threadOne 被中断了，因此 ① 处 isInterrupted() 检测到了，返回 true；</p>
<p>②、③ 处，虽然一个是 threadOne 调用 interrupted()，一个是 Thread 调用 interrupted()，但 interrupted() 静态方法返回的是“当前线程”的状态，由于当前主线程没有被中断过，所以 ②、③ 均返回 false；</p>
<p>由于 ① 处使用的 isInterrupted() 方法并不会清楚线程状态，所以 ④ 处还是返回 true。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/RightWayInterrupted.png" width=""/> </div>

<hr>
<h1 id="4-线程的生命周期"><a href="#4-线程的生命周期" class="headerlink" title="4. 线程的生命周期"></a>4. 线程的生命周期</h1><h2 id="4-1-线程的-6-种状态"><a href="#4-1-线程的-6-种状态" class="headerlink" title="4.1 线程的 6 种状态"></a>4.1 线程的 6 种状态</h2><p><strong>New</strong>：new 出一个线程后，调用 start() 之前，线程是新建状态。</p>
<p><strong>Runnable</strong>：线程对象调用 start() 方法时，会被线程调度器来执行，即交给操作系统来执行，此时线程处于可运行状态。该状态包括操作系统线程状态中 Ready 和 Running。如果一直没拿到时间片，就一直是Ready 状态；当线程调度选中该线程、并分配了CPU时间片后，线程处于Running 状态。注意：线程处在 Running 状态时，如果 CPU 资源突然被拿走（线程被<strong>挂起</strong>），此时线程就回从 Running 转成 Ready，不过此时线程还是处于 Runnable 状态。比如：调用 yiled() 时线程由 Running 状态转为 Ready 状态，线程被线程调度器选中执行的时候又会从 Ready 状态转换为 Running 状态。</p>
<p><strong>Blocked</strong>：线程进入到被 synchronized 修饰的代码（代码块或方法）时，并且没有拿到锁就会进入阻塞状态。</p>
<p><strong>Waiting</strong>：线程在运行时，如果调用了 Object.wait()、Thread.join()、LockSupport.park() 就会进入等待状态，如果再调用了 Object.notify()、Object.notifyAll()、LockSupport.unpark()，又会回到 Runnable 状态。</p>
<p><strong>Timed_Waiting</strong>：线程在运行时，如果调用了 Thread.sleep(time)、Object.wait(time)、Thread.join(time)、LockSupport.parkNanos(time)、LockSupport.parkUntil(time)，线程进入计时等待状态；当等待时间结束或调用 Object.notify()、Object.notifyAll()、LockSupport.unpark()，线程又会进入 Runnable 状态。  </p>
<p><strong>Terminated</strong>：线程顺利执行完毕就会进入终止状态；或出现了未被捕获的异常，导致意外终止。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/ThreadStates.png" width=""/></div>

<p><strong>Demo 1</strong> : 展示线程的 New、Runnable、Terminated 状态。根据结果可以知道，即使是正在运行，也是 Runnable 状态，而不是 Running。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 展示线程的 New、Runnable、Terminated 状态。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-08 0:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewRunnableTerminated</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> NewRunnableTerminated());</span><br><span class="line">        <span class="comment">// NEW</span></span><br><span class="line">        System.out.println(<span class="string">"调用 start() 之前的状态："</span> + thread.getState());</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// RUNNABLE</span></span><br><span class="line">        System.out.println(<span class="string">"调用 start() 之后的状态："</span> + thread.getState());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// RUNNABLE</span></span><br><span class="line">        System.out.println(<span class="string">"休眠 5ms 后，处于运行中时的状态："</span> + thread.getState());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TERMINATED</span></span><br><span class="line">        System.out.println(<span class="string">"run() 方法正常执行完之后的状态："</span> + thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/NewRunnableTerminated_1.png" width=""/></div></br>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/NewRunnableTerminated_2.png" width="410px"/></div></br>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/NewRunnableTerminated_3.png" width="410px"/></div>

<p><strong>Demo 2</strong> : 展示 Blocked, Waiting, TimedWaiting 状态。① 处打印出 TIMED_WAITING状态，是因为正在执行run() 方法中的 Thread.sleep(1000)；② 处打印出 BLOCKED 状态，是因为 thread2 没有拿到 sync() 的锁；③ 处打印出 WAITING 状态，是因为执行了 wait()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 展示 Blocked, Waiting, TimedWaiting</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-08 0:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockedWaitingTimedWaiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockedWaitingTimedWaiting runnable = <span class="keyword">new</span> BlockedWaitingTimedWaiting();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TIMED_WAITING---①</span></span><br><span class="line">        System.out.println(<span class="string">"thread1 的状态："</span> + thread1.getState());</span><br><span class="line">        <span class="comment">// BLOCKED---②</span></span><br><span class="line">        System.out.println(<span class="string">"thread2 的状态："</span> + thread2.getState());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// WAITING---③</span></span><br><span class="line">        System.out.println(<span class="string">"thread1 的状态："</span> + thread1.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        syn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/BlockedWaitingTimedWaiting.png" width=""/></div>

<h2 id="4-2-阻塞状态"><a href="#4-2-阻塞状态" class="headerlink" title="4.2 阻塞状态"></a>4.2 阻塞状态</h2><p>一般来说，把 Blocked、Waiting、Timed_Waiting 都称为阻塞状态。</p>
<h2 id="4-3-线程状态总结"><a href="#4-3-线程状态总结" class="headerlink" title="4.3 线程状态总结"></a>4.3 线程状态总结</h2><h3 id="4-3-1-6-种状态"><a href="#4-3-1-6-种状态" class="headerlink" title="4.3.1 6 种状态"></a>4.3.1 6 种状态</h3><p>Java 中定义了线程的 6 种状态，分别是 NEW、RUNNABLE、 BLOCKED、 WAITING、 TIMED_WAITING、TERMINATED。</p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Thread.State.html" target="_blank" rel="noopener">Thread.State 官方文档</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> Thread.State</span><br><span class="line">extends Enum&lt;Thread.State&gt;</span><br><span class="line">A thread state. A thread can be in one of the following states:</span><br><span class="line">	- NEW</span><br><span class="line">	  A thread that has not yet started is in <span class="keyword">this</span> state.</span><br><span class="line">	- RUNNABLE</span><br><span class="line">	  A thread executing in the Java virtual machine is in <span class="keyword">this</span> state.</span><br><span class="line">	- BLOCKED</span><br><span class="line">	  A thread that is blocked waiting <span class="keyword">for</span> a monitor lock is in <span class="keyword">this</span> state.</span><br><span class="line">	- WAITING</span><br><span class="line">	  A thread that is waiting indefinitely <span class="keyword">for</span> another thread to perform a particular action is in <span class="keyword">this</span> state.</span><br><span class="line">	- TIMED_WAITING</span><br><span class="line">	  A thread that is waiting <span class="keyword">for</span> another thread to perform an action <span class="keyword">for</span> up to a specified waiting time is in <span class="keyword">this</span> state.</span><br><span class="line">	- TERMINATED</span><br><span class="line">	  A thread that has exited is in <span class="keyword">this</span> state.</span><br><span class="line">A thread can be in only one state at a given point in time. These states are virtual machine states which <span class="keyword">do</span> not reflect any operating system thread states.</span><br></pre></td></tr></table></figure>

<h3 id="4-3-1-转换关系和转换条件"><a href="#4-3-1-转换关系和转换条件" class="headerlink" title="4.3.1 转换关系和转换条件"></a>4.3.1 转换关系和转换条件</h3><div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/ThreadStates.png" width=""/></div>

<ul>
<li><p>NEW 只能往走到 RUNNABLE，而不能直接跳跃到其他状态;</p>
</li>
<li><p>线程生命周期不可回头：一旦到了  RUNNABLE 就不能回到 NEW ，一旦状态为 TERMINATED， 就不能再有任何状态的变化。所以一个线程只能有一次 NEW 和 TERMINATED 状态。线程是不可以重复执行的，当它运行完了之后便会结束，一旦一个线程进入了 TERMINATED 状态，它便不可以重新变回 RUNNABLE 等状态，这个不可重复执行的性质和线程池是一样的。如果还想执行该任务，可以选择重新创建一个线程，而原对象会被 JVM 回收。</p>
</li>
<li><p>2 个特殊情况：</p>
<ul>
<li><p>如果发生异常， 可以直接跳到 TERMINATED 状态，不必再遵循路径，比如可以从 WAITING 直接到 TERMINATED。</p>
</li>
<li><p>从 Object. wait() 刚被唤醒时，通常不能立刻抢到 monitor 锁，就会从 WATING 先进入 BLOCKED 状态，抢到锁后再转换到 RUNNABLE 状态。（因为某个线程被唤醒一定是其他的线程将其唤醒，而其他线程要唤醒它也需要持有同一把锁，通常在唤醒一个线程之后并不会释放掉锁。）</p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="noopener">Thread.State 官方文档</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BLOCKED</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread.State BLOCKED</span><br><span class="line">Thread state <span class="keyword">for</span> a thread blocked waiting <span class="keyword">for</span> a monitor lock. A thread in the blocked state is waiting <span class="keyword">for</span> a monitor lock to enter a <span class="keyword">synchronized</span> block/method or reenter a <span class="keyword">synchronized</span> block/method after calling Object.wait.</span><br></pre></td></tr></table></figure>

<p>根据官方文档的说明可知，有两种途径可以进入 BLOCKED 状态，一是线程进入到被 synchronized 修饰的代码块或方法，但没有拿到锁；二是调用了 wait 方法之后，线程被唤醒重新进入被 synchronized 修饰的代码块或方法，此时线程又会进入 BLOCKED 状态。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="5-Thread-和-Object-类中线程相关方法"><a href="#5-Thread-和-Object-类中线程相关方法" class="headerlink" title="5. Thread 和 Object 类中线程相关方法"></a>5. Thread 和 Object 类中线程相关方法</h1><h2 id="5-1-概览"><a href="#5-1-概览" class="headerlink" title="5.1 概览"></a>5.1 概览</h2><table>
   <tr align="center">
      <th>类</th>
      <th>方法名</th>
      <th>描述</th>
   </tr>
   <tr>
      <td align="center" rowspan="7">Thread</td>
      <td>sleep 相关</td>
       <td>让当前“正在执行的线程”休眠</td>
   </tr>
   <tr>
      <td>join</td>
      <td>等待其他线程执行完毕</td>
   </tr>
   <tr>
      <td>yield 相关</td>
      <td>放弃已经获取到的 CPU 资源</td>
   </tr>
   <tr>
      <td>currentThread</td>
      <td>获取当前执行线程的引用</td>
   </tr>
   <tr>
      <td>start、run 相关</td>
      <td>启动线程相关</td>
   </tr>
   <tr>
      <td>interrupt 相关</td>
      <td>中断线程</td>
   </tr>
   <tr>
      <td>stop、suspend、resume</td>
      <td>已废弃</td>
   </tr>
   <tr>
      <td align="center">Object</td>
      <td>wait、notify、notifyAll 相关</td>
      <td>让线程暂时休眠或唤醒</td>
   </tr>
</table>
## 5.2 wait、notify、notifyAll

<h3 id="5-2-1-作用"><a href="#5-2-1-作用" class="headerlink" title="5.2.1 作用"></a>5.2.1 作用</h3><p><strong>阻塞阶段</strong>：在 <strong>synchronized 内部</strong>可以调用 wait() 使线程进入阻塞状态，不再参与线程调度；必须在已获得的锁对象上调用 wait() 方法。</p>
<p>直到以下 4 种情况之一发生时,才会被唤醒；</p>
<ol>
<li><p>另一个线程调用这个对象的 notify() 方法且刚好被唤醒的是本线程;</p>
</li>
<li><p>另一个线程调用这个对象的 notifyAll() 方法;</p>
</li>
<li><p>过了 wait(long timeout) 规定的超时时间,如果传入 0 就是永久等待;</p>
</li>
<li><p>线程自身调用了 interrupt() </p>
</li>
</ol>
<p><strong>唤醒阶段</strong>：在 <strong>synchronized 内部</strong>可以调用 notify() 或 notifyAll() 唤醒其他等待线程；必须在已获得的锁对象上调用 notify() 或 notifyAll() 方法。</p>
<h3 id="5-2-2-几个-Demo"><a href="#5-2-2-几个-Demo" class="headerlink" title="5.2.2 几个 Demo"></a>5.2.2 几个 Demo</h3><p><strong>Demo 1</strong> : 演示 wait 和 notify 的基本用法</p>
<p>从代码执行结果看出，wait() 会释放锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 wait 和 notify 的基本用法</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-08 16:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object OBJ = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (OBJ) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 开始执行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    OBJ.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 又获取到了锁"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (OBJ) &#123;</span><br><span class="line">                OBJ.notify();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 调用了 notify()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread1 thread1 = <span class="keyword">new</span> Thread1();</span><br><span class="line">        Thread2 thread2 = <span class="keyword">new</span> Thread2();</span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/Wait.png" width=""/> </div>

<p><strong>Demo 2</strong> : 演示 notify 和 notifyAll</p>
<p>3 个线程，线程 0 和线程 1 首先被阻塞，线程 2 唤醒它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 notify 和 notifyAll</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-08 17:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyAll</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object OBJ = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (OBJ) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 拿到了锁"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 等待被唤醒"</span>);</span><br><span class="line">                OBJ.wait();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 执行完毕"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        WaitNotifyAll r = <span class="keyword">new</span> WaitNotifyAll();</span><br><span class="line"></span><br><span class="line">        Thread thread0 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (OBJ) &#123;</span><br><span class="line">                OBJ.notifyAll();</span><br><span class="line">                System.out.println(<span class="string">"Thread2 中执行了 notifyAll()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WaitNotifyAll_1.png" width=""/> </div>

<p>如果将第 33 行代码的 notifyAll() 改为 notify()，只会唤醒一个被阻塞的线程，另一个线程会一直处于阻塞状态等待被唤醒。运行结果如下图： </p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WaitNotifyAll_2.png" width=""/> </div>

<p>如果 notifyAll() 不变，将 main 方法中的<code>Thread.sleep(200)</code>去掉，则无法保证 Thread2 最后被启动，执行结果如下图，可以看到 Thread2 先于 Thread1 执行，对于 Thread0 来说，可以被正常唤醒，但 Thread1 阻塞之后没有线程来唤醒它了。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WaitNotifyAll_3.png" width=""/> </div>

<p><strong>Demo 3</strong> : 只会释放当前 monitor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 wait 只释放当前的那把锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-08 17:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyReleaseOwnMonitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object ObjA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object ObjB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (ObjA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Thread-1 拿到了 ObjA 锁"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (ObjB) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Thread-1 拿到了 ObjB 锁"</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"Thread-1 释放了 ObjA 锁"</span>);</span><br><span class="line">                            ObjA.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (ObjA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Thread-2 拿到了 ObjA 锁"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"Thread-2 尝试拿到 ObjB 锁"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (ObjB) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Thread-2 拿到了 ObjB 锁"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/WaitNotifyReleaseOwnMonitor.png" width=""/> </div>

<h3 id="5-2-2-wait-notify-notifyAll-特点、性质"><a href="#5-2-2-wait-notify-notifyAll-特点、性质" class="headerlink" title="5.2.2 wait, notify, notifyAll 特点、性质"></a>5.2.2 wait, notify, notifyAll 特点、性质</h3><ol>
<li>必须在已获得的锁对象上调用 wait、notify、notifyAll 方法，即必须先拥有 monitor。否则会抛出<code>IllegalMonitorStateException</code>异常。</li>
<li>notify 只能唤醒一个被阻塞的线程，而 notifyAll 是唤醒所有被阻塞的线程。</li>
<li>三个方法都属于 Object 类。</li>
<li>wait, notify, notifyAll 是相对底层的功能，JDK 封装了一个有类似功能的 Condition 接口。</li>
<li>notify, notifyAll 只会释放当前的那把锁。</li>
</ol>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/Java_Monator.png" width=""/> </div>

<p>上图为 Java 中线程抢锁的示意图，绿色区域为入口集 Entry Set，蓝色和红色区域为等待集 Wait Set。某个线程想要抢锁，此时进入 Entry Set，Entry Set 中原来可能已经有很多线程也准备抢锁，当其中某个线程 ② 抢到锁后时，进入到了紫色区域，该线程有两种方式会释放锁，一种是正确执行完该线程，然后释放锁退出；另一种是被 wait 之后，就会释放锁，其他线程又有机会抢到锁，该线程则会进入蓝色的 Wait Set 中等待被唤醒，如果该线程被 notify 了，就会进如红色的 Wait Set 中，此时该线程和绿的 Entry Set 中线程一样，都在等待持有锁的线程去释放锁，再去抢锁。</p>
<h3 id="【问题】如何选择用-notify-还是-nofityAll"><a href="#【问题】如何选择用-notify-还是-nofityAll" class="headerlink" title="【问题】如何选择用 notify 还是 nofityAll ?"></a>【问题】如何选择用 notify 还是 nofityAll ?</h3><p>Object.notify 可能导致信号丢失这样的正确性问题，而 Object.notifyAll 虽然效率不太高(把不需要唤醒的等待线程也给唤醒了)，但是其在正确性方面有保障。因此实现通知的一种比较流行的保守性方法是优先使用Object.notifyAll 以保障正确性，只有在有证据表明使用Object.notify 足够的情况下才使用Object.notify。</p>
<p>只有在满足下列两个条件的情况下才能够用 Object.notify 替代 notifyAll 方法。</p>
<ol>
<li>一次通知仅需要唤醒至多一个线程。</li>
<li>相应对象上的所有等待线程都是同质等待线程。所谓同质等待线程指这些线程使用同一个保护条件，并且这些线程在 Object.wait 调用返回之后的处理逻辑一致。最为典型的同质线程是使用同一个 Runnable 接口实例创建的不同线程(实例)或者从同一个 Thread 子类 new 出来的多个实例。</li>
</ol>
<h3 id="【Demo】生产者消费者设计模式"><a href="#【Demo】生产者消费者设计模式" class="headerlink" title="【Demo】生产者消费者设计模式"></a>【Demo】生产者消费者设计模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用 wait/notify 来实现生产者消费者模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-08 20:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        EventStorage storage = <span class="keyword">new</span> EventStorage();</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(storage);</span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventStorage storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(EventStorage storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            storage.put();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventStorage storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(EventStorage storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            storage.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventStorage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Date&gt; storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventStorage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">this</span>.storage = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (storage.size() == maxSize) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        storage.add(<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(<span class="string">"仓库中现有 "</span> + storage.size() + <span class="string">" 个产品。"</span>);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (storage.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"取走了 ["</span> + storage.pollFirst() + <span class="string">"], 仓库还剩下 "</span> + storage.size() + <span class="string">"个产品。"</span>);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【Demo】使用两个线程交替打印-1-100-的奇偶数。"><a href="#【Demo】使用两个线程交替打印-1-100-的奇偶数。" class="headerlink" title="【Demo】使用两个线程交替打印 1-100 的奇偶数。"></a>【Demo】使用两个线程交替打印 1-100 的奇偶数。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个线程交替打印0~100的奇偶数，用 wait 和 notify</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-08 21:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyPrintOddEveNum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object OBJ = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintNumber(), <span class="string">"线程 1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintNumber(), <span class="string">"线程 2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintNumber</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (OBJ) &#123;</span><br><span class="line">                    <span class="comment">// 唤醒其他线程</span></span><br><span class="line">                    OBJ.notify();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + count++);</span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 如果任务还未结束，就休眠并释放锁</span></span><br><span class="line">                            OBJ.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【问题】为什么-wait-必须在同步（synchronized）方法-代码块使用"><a href="#【问题】为什么-wait-必须在同步（synchronized）方法-代码块使用" class="headerlink" title="【问题】为什么 wait 必须在同步（synchronized）方法/代码块使用?"></a>【问题】为什么 wait 必须在同步（synchronized）方法/代码块使用?</h3><p>对于对象的非同步方法而言，任意时刻可以有任意个线程调用该方法。在同步方法或同步代码块中使用会使线程更安全，避免死锁或永久等待。例如下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; buffer = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">give</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        buffer.add(data);</span><br><span class="line">        notify();  <span class="comment">// Since someone may be waiting in take</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (buffer.isEmpty())  <span class="comment">// Avoid "if" due to spurious wakeups</span></span><br><span class="line">            wait();</span><br><span class="line">        <span class="keyword">return</span> buffer.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么可能发生如下的错误:</p>
<ol>
<li>消费者线程调用 take() 并看到了 buffer. isEimpty()。</li>
<li>在消费者线程继续 wait() 之前，生产者线程调用一个完整的 give()，也就是 buffer. add (data) 和notify();</li>
<li>消费者线程现在调用 wait()，但是错过了刚才的 notify()。</li>
<li>如果运气不好， 即使有可用的数据，但是没有更多生产者生产的话，那么消费者会陷入 wait 的无限期等待。</li>
</ol>
<p>解决方案就是用 synchronized 来确保 notify 永远不会在 isEmpty 和 wait 之间被调用。</p>
<p><a href="https://programming.guide/java/why-wait-must-be-in-synchronized.html" target="_blank" rel="noopener">参考资料</a></p>
<h3 id="【问题】为什么线程通信的方法wait，notify-和notifyAll-被定义在-Object-类里"><a href="#【问题】为什么线程通信的方法wait，notify-和notifyAll-被定义在-Object-类里" class="headerlink" title="【问题】为什么线程通信的方法wait，notify 和notifyAll 被定义在 Object 类里?"></a>【问题】为什么线程通信的方法wait，notify 和notifyAll 被定义在 Object 类里?</h3><p>锁是一种状态，是状态就要有地方存。锁又是一种很通用的需求，因此 Java 提供了对象级的锁，就是指每个对象都可以有锁状态，可通过线程来获得。而所有类都继承于 Object，所以完全可以把 wait 方法定义在 Object 类中，这样，当我们定义一个新类，并需要以它的一个对象作为锁时，不需要我们再重新定义 wait 方法的实现，而是直接调用父类的 wait。</p>
<h3 id="【问题】wait-方法是属于-Object-对象的，那调用-Thread-wait-会怎么样-（Thread-肯定也是继承自-Object）"><a href="#【问题】wait-方法是属于-Object-对象的，那调用-Thread-wait-会怎么样-（Thread-肯定也是继承自-Object）" class="headerlink" title="【问题】wait 方法是属于 Object 对象的，那调用 Thread.wait 会怎么样? （Thread 肯定也是继承自 Object）"></a>【问题】wait 方法是属于 Object 对象的，那调用 Thread.wait 会怎么样? （Thread 肯定也是继承自 Object）</h3><p>就把 Thread 当成是一个普通的类，和 Object 没有区别。但是这样会有一个问题，那就是线程退出的时候会自动唤醒，这会让我们自己设计的唤醒流程受到极大的干扰，所以不推荐调用 Thread 类的 wait()，因为这会影响到系统 API 的正常运行，或者被系统 API 影响到。</p>
<h2 id="5-3-sleep"><a href="#5-3-sleep" class="headerlink" title="5.3 sleep"></a>5.3 sleep</h2><p><strong>作用：</strong>可以让线程进入 Waiting 状态，并且不占用 CPU 资源。</p>
<p><strong>特点：</strong>不释放锁，包括 synchronized 和 lock，直到规定的时间后再次执行，休眠期间如果被中断，会抛出<code>InterruptedException</code>，并清除中断状态。</p>
<h3 id="5-3-1-关于-sleep-的几个-Demo"><a href="#5-3-1-关于-sleep-的几个-Demo" class="headerlink" title="5.3.1 关于 sleep 的几个 Demo"></a>5.3.1 关于 sleep 的几个 Demo</h3><p>Demo 1：示线程 sleep 的时候不释放 synchronized 的 monitor，等 sleep 时间到了以后，正常结束后才释放锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 展示线程 sleep 的时候不释放 synchronized 的 monitor，</span></span><br><span class="line"><span class="comment"> * 等 sleep 时间到了以后，正常结束后才释放锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-09 16:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepDontReleaseMonitor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SleepDontReleaseMonitor r = <span class="keyword">new</span> SleepDontReleaseMonitor();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        syn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 获取到了 monitor"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 退出了同步方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/SleepDontReleaseMonitor.png" width=""/> </div>

<p>Demo 2： sleep 不释放 lock（lock需要手动释放）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sleep 不释放 lock</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-09 16:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepDontReleaseLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lock LOCK = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SleepDontReleaseLock r = <span class="keyword">new</span> SleepDontReleaseLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOCK.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 获取了 Lock 锁"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 已经苏醒"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            LOCK.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/SleepDontReleaseLock.png" width=""/> </div>

<p><strong>sleep 方法响应中断</strong></p>
<ol>
<li>抛出 <code>InterruptedException</code></li>
<li>清除中断状态<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* <span class="meta">@throws</span>  InterruptedException</span><br><span class="line">*          <span class="keyword">if</span> any thread has interrupted the current thread. The</span><br><span class="line">*          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span><br><span class="line">*          cleared when <span class="keyword">this</span> exception is thrown.</span><br></pre></td></tr></table></figure>


</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个 1 秒钟输出当前时间，被中断。</span></span><br><span class="line"><span class="comment"> * Thread.sleep()</span></span><br><span class="line"><span class="comment"> * TimeUnit.SECONDS.sleep()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-09 17:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepInterrupted</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SleepInterrupted());</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">"已被中断"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().isInterrupted());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/SleepInterrupted.png" width=""/> </div>

<p>java.util.concurrent 下的 <code>TimeUnit</code> 使用起来更方便些，直接提供了时间的转换，内部也还是调用了 Thread 类中的<code>sleep(long millis, int nanos)</code>方法，只不过如果输入的是负数，Thread 类中的 <code>sleep(long millis, int nanos)</code>方法会抛出<code>IllegalArgumentException</code>，而 TimeUnit 中的方法直接忽略输入负数的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 类中的 sleep(long mills, int nanos) 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">        millis++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(millis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TimeUnit 类中的 sleep(long timrout) 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> ms = toMillis(timeout);</span><br><span class="line">        <span class="keyword">int</span> ns = excessNanos(timeout, ms);</span><br><span class="line">        Thread.sleep(ms, ns);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【问题】wait、sleep异同"><a href="#【问题】wait、sleep异同" class="headerlink" title="【问题】wait、sleep异同"></a>【问题】wait、sleep异同</h3><p><strong>相同点：</strong></p>
<ol>
<li>wait和 sleep 方法都可以使线程<strong>阻塞</strong>，对应线程状态是 Waiting 或 Timed_Waiting。</li>
<li>wait 和 sleep 方法都可以<strong>响应中断</strong> Thread. interrupt ()，并抛出<code>InterruptedException</code>异常。</li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li><p>调用的要求不同：sleep() 可以在任何需要的场景下调用；wait 必须使用在同步代码块或同步方法中。</p>
</li>
<li><p>关于是否释放锁：如果两个方法都使用在同步代码块或同步方法中，sleep 不会释放锁，wait 会释放锁。</p>
</li>
<li><p>声明位置不同：sleep 声明在 Thread 类中，wait 声明在 Object 类中。</p>
</li>
</ol>
<h2 id="5-4-join"><a href="#5-4-join" class="headerlink" title="5.4 join"></a>5.4 join</h2><p><strong>作用：</strong>通俗地说，有新的线程加入我们当前线程，当前线程等待，等调用的线程运行完成后，我们当前线程再去执行。t1 和 t2 两个线程，在 t1 的某个点调用 t2.join()，此时 t1 进入阻塞状态，直到 t2 执行完后，t1 结束阻塞状态。</p>
<p><strong>什么情况下使用</strong>：等待好几个资源的初始完成后化，主线程才能开始工作。</p>
<h3 id="5-4-1-几个关于-join-的-Demo："><a href="#5-4-1-几个关于-join-的-Demo：" class="headerlink" title="5.4.1 几个关于 join 的 Demo："></a>5.4.1 几个关于 join 的 Demo：</h3><p><strong>Demo 1</strong>：普通用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示join，注意语句输出顺序，会变化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-09 19:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Join</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Join r = <span class="keyword">new</span> Join();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(r, <span class="string">"Thread-1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(r, <span class="string">"Thread-2"</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        System.out.println(<span class="string">"开始等待子线程运行完毕"</span>);</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">"所有子线程执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/Join_1.png" width=""/> </div>

<p>可以从结果看出，调用了 thread1.join() 和 thread2.join() 之后，主线程会等待 thread1 和 thread2 执行完之后，才会执行后面的程序。如果把 thread1.join() 和 thread2.join() 注释掉，结果如下图所示，主线程不会等待，依然会继续执行。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/Join_2.png" width=""/> </div>

<p><strong>Demo 2</strong>：join 期间遇到中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 join 期间被中断的效果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-09 20:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinInterrupt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread mainThread = Thread.currentThread();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    mainThread.interrupt();</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"sleep()结束"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"子线程被中断"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"子线程"</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">"主线程等待子线程执行完毕"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"线程被中断"</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"子线程执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/JoinInterrupt.png" width=""/> </div>

<p>代码逻辑：通过 Thread.currentThread() 获得主线程的引用，在主线程中调用 thread.join()，此时主线程等待子线程执行完毕才能继续执行，而子线程的 run 方法中，将主线程中断，此时 join 期间的主线程进入 catch，输出“主线程被中断”，同时将子线程也中断，所以在 sleep 的子线程被中断，子线程进入 catch，输出“子线程被中断”。注意：这里子线程被中断后，其 catch 语句和主线程是并行执行的，所以无法确定 “子线程被中断” 和 “子线程执行完毕” 哪一个会先输出。</p>
<p><strong>Demo 3</strong> ：join 期间，线程的状态：WAITING。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先 join 再 mainThread.getState()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-09 20:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThreadState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread mainThread = Thread.currentThread();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"主线程状态: "</span> + mainThread.getState());</span><br><span class="line">                    System.out.println(<span class="string">"Thread-0 执行完毕"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">"主线程等待子线程执行完毕"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"子线程执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/JoinThreadState.png" width=""/> </div>



<h3 id="5-4-2-join-原理"><a href="#5-4-2-join-原理" class="headerlink" title="5.4.2 join 原理"></a>5.4.2 join 原理</h3><p>看看源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 输入参数 &lt; 0，抛出异常。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 等待 delay 时间后苏醒</span></span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的参数为 0 时，意味着永远等待，直到被唤醒、被中断或者前面的线程执行完毕。可以发现，join 内部是调用了 wait。如果输出参数为 0，调用了 wait(0)，但是代码中并没有唤醒的操作。实际上，Thread 类在 run() 方法执行完后，都会自动执行类似 notify 的操作，即唤醒线程（JVM层代码）。所以如之前所说，不推荐调用 Thread 类的 wait()，因为这会影响到系统 API 的正常运行，或者被系统 API 影响到。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">作者：cao</span><br><span class="line">链接：https:<span class="comment">//www.zhihu.com/question/44621343/answer/97640972</span></span><br><span class="line">来源：知乎</span><br><span class="line"></span><br><span class="line"><span class="comment">//c++函数：这个函数的作用就是在一个线程执行完毕之后，jvm会做的收尾工作。里面有一行代码：ensure_join(this);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JavaThread::exit</span><span class="params">(<span class="keyword">bool</span> destroy_vm, ExitType exit_type)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">作者：cao</span><br><span class="line">链接：https:<span class="comment">//www.zhihu.com/question/44621343/answer/97640972</span></span><br><span class="line">来源：知乎</span><br><span class="line"></span><br><span class="line"><span class="comment">// ensure_join(this) 的源码如下: </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensure_join</span><span class="params">(JavaThread* thread)</span> </span>&#123;</span><br><span class="line">    <span class="function">Handle <span class="title">threadObj</span><span class="params">(thread, thread-&gt;threadObj())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ObjectLocker <span class="title">lock</span><span class="params">(threadObj, thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    thread-&gt;clear_pending_exception();</span><br><span class="line"></span><br><span class="line">    java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED);</span><br><span class="line"></span><br><span class="line">    java_lang_Thread::set_thread(threadObj(), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//thread 就是当前线程，比如在主线程中调用 thread1.join(),则就是 thread1 线程。</span></span><br><span class="line">    lock.notify_all(thread);</span><br><span class="line"></span><br><span class="line">    thread-&gt;clear_pending_exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知道了 join 的内部结构，也可以自己实现和 join 类似的功能，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * join 的代替写法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-09 21:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinPrinciple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"执行完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">"开始等待子线程执行完毕"</span>);</span><br><span class="line">        <span class="comment">// thread.join();</span></span><br><span class="line">        <span class="keyword">synchronized</span> (thread) &#123;</span><br><span class="line">            thread.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"所有子线程执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/JoinPrinciple.png" width=""/> </div>

<h2 id="5-5-yield"><a href="#5-5-yield" class="headerlink" title="5.5 yield"></a>5.5 yield</h2><p><strong>作用</strong>：当前线程正在执行的时候停下来进入等待队列，即释放当前线程的 CPU 时间片，此时该线程状态依然是 RUNNABLE。线程调度器依然有可能把刚刚 yield 的线程拿回来继续执行。</p>
<hr>
<h1 id="6-线程属性"><a href="#6-线程属性" class="headerlink" title="6. 线程属性"></a>6. 线程属性</h1><table>
<thead>
<tr>
<th align="left">总览</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">线程Id</td>
<td align="left">用于标识不同线程。</td>
</tr>
<tr>
<td align="left">名称（Name）</td>
<td align="left">作用让用户或程序员在开发、调试或运行过程中，更容易区分每个不同的线程、定位问题等。</td>
</tr>
<tr>
<td align="left">是否是守护线程（isDaemon）</td>
<td align="left">true 代表该线程是【守护线程】, false 代表线程是，非守护线程,也就是【用户线程】。</td>
</tr>
<tr>
<td align="left">优先级（Priority）</td>
<td align="left">优先级这个属性的目的是告诉线程调度器，用户希望哪些线程相对多运行、哪些少运行。</td>
</tr>
</tbody></table>
<h2 id="6-1-线程-ID"><a href="#6-1-线程-ID" class="headerlink" title="6.1 线程 ID"></a>6.1 线程 ID</h2><p>Demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程 ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-10 22:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Id</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">        System.out.println(<span class="string">"主线程ID："</span> + Thread.currentThread().getId());</span><br><span class="line">        System.out.println(<span class="string">"子线程ID："</span> + thread.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/Id.png" width=""/> </div>

<p>从运行结果看，线程 ID 从 1 开始。但 JVM 运行起来后，还有很多线程也会启动，所以自己创建的线程的 ID 并不是 2。从源码来看，线程的 ID 是每次加一，由于是<code>++threadSeqNumber</code>，因此第一个线程的 ID 就是 1 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Thread ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> tid;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set thread ID */</span></span><br><span class="line">tid = nextThreadID();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextThreadID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++threadSeqNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-线程名字"><a href="#6-2-线程名字" class="headerlink" title="6.2 线程名字"></a>6.2 线程名字</h2><p>直接看源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传入一个默认的名字，以 Thread- 开头，后面加上 nextThreadNum()</span></span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For autonumbering anonymous threads. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadInitNumber;</span><br><span class="line"><span class="comment">// 该方法加上了 synchronized，保证了线程的名字是不重复的，</span></span><br><span class="line"><span class="comment">// 返回值就是 threadInitNumber，从 0 自增 1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextThreadNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadInitNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置线程名字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 安全检查</span></span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="comment">// 检查入参</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 将 name 属性重新赋值</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="comment">// 如果线程状态不是 0，调用 native 方法 setNativeName，将 name 传入。</span></span><br><span class="line">    <span class="comment">// 线程状态为 0 说明线程还未被启动</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123;</span><br><span class="line">        setNativeName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-守护线程"><a href="#6-3-守护线程" class="headerlink" title="6.3 守护线程"></a>6.3 守护线程</h2><p><strong>作用</strong>：为用户线程提供服务。</p>
<p><strong>特性</strong>：</p>
<ol>
<li>线程类型默认继承自父线程；</li>
<li>被谁启动：通常所有的守护线程是由 JVM 启动，在 JVM 启动时，main 用户线程也会被启动</li>
<li>不影响 JVM 退出。</li>
</ol>
<p><strong>守护线程与用户线程的区别</strong>：</p>
<p>User 和 Daemon 两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果User Thread已经全部退出运行了，只剩下Daemon Thread存在， 虚拟机也就退出了，因为没有了“被守护者”，Daemon 也就没有工作可做了，也就没有继续运行程序的必要了。</p>
<p><strong>是否需要给线程设置为守护线程？</strong><br>通常不应把自己的线程设置为守护线程，因为设置为守护线程是很危险的。比如线程正在访问如文件、数据库的时候，所有用户线程都结束了，那么守护线程会在任何时候甚至在一个操作的中间发生中断，所以守护线程永远不应该去访问固有资源。</p>
<h2 id="6-4-线程优先级"><a href="#6-4-线程优先级" class="headerlink" title="6.4 线程优先级"></a>6.4 线程优先级</h2><p>有 10 个级别，创建的线程优先级默认是 5。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><strong>为什么程序设计不应依赖于线程优先级？</strong></p>
<div class="note primary">
            <p>线程优先级并不是一项稳定的调节手段，很显然因为主流虚拟机上的Java线程是被映射到系统的原生线程上来实现的，所以线程调度最终还是由操作系统说了算。尽管现代的操作系统基本都提供线程优先级的概念，但是并不见得能与Java线程的优先级一一对应，如 Solaris 中线程有2147483648（2的31次幂）种优先级，但 Windows 中就只有七种优先级。如果操作系统的优先级比 Java 线程优先级更多，那问题还比较好处理，中间留出一点空位就是了，但对于比Java线程优先级少的系统，就不得不出现几个线程优先级对应到同一个操作系统优先级的情况了。</p><p>线程优先级并不是一项稳定的调节手段，这不仅仅体现在某些操作系统上不同的优先级实际会变得相同这一点上，还有其他情况让我们不能过于依赖线程优先级：优先级可能会被系统自行改变，例如在 Windows 系统中存在一个叫“优先级推进器”的功能（Priority Boosting，当然它可以被关掉），大致作用是当系统发现一个线程被执行得特别频繁时，可能会越过线程优先级去为它分配执行时间，从而减少因为线程频繁切换而带来的性能损耗。因此，我们并不能在程序中通过优先级来完全准确判断一组状态都为 Ready 的线程将会先执行哪一个。</p><p><strong><em>深入理解 Java 虚拟机  12.4.2</em></strong></p>
          </div>

<hr>
<h1 id="7-线程的异常处理"><a href="#7-线程的异常处理" class="headerlink" title="7. 线程的异常处理"></a>7. 线程的异常处理</h1><h2 id="7-1-UncaughtExceptionHandler-类"><a href="#7-1-UncaughtExceptionHandler-类" class="headerlink" title="7.1 UncaughtExceptionHandler 类"></a>7.1 UncaughtExceptionHandler 类</h2><p>处理线程的未捕获异常 UncaughtException。</p>
<p><strong>为什么需要 UncaughtExceptionHandler ?</strong></p>
<ol>
<li><p>主线程可以轻松发现异常,子线程却不行。</p>
<p>主线程如果发现未捕获异常，会抛出异常，程序终止，从异常堆栈中可以看到是哪里出现了异常；但是子线程却不行，从代码运行结果来看，子线程抛出了异常，但是不会影响主线程的运行，这就使得子线出现的异常被各种日志信息淹没。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionInChildThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ExceptionInChildThread()).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/ExceptionInChildThread.png" width=""/> </div>

<ol start="2">
<li><p>子线程异常无法用传统方式捕获。</p>
<p>不加 try-catch，以下代码会抛出 4 个异常，而且异常信息中会带有子线程的名字。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不加 try-catch 会抛出4个异常，都带线程名字</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-11 10:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CantCatchDirectly</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"Thread-1"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"Thread-2"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"Thread-3"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"Thread-4"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/CantCatchDirectly_1.png" width=""/> </div>

<p>如果在主线程中将子线程全都进行 try-catch 处理，还是无法正确处理异常，因为现在使用 try-catch 是在主线程中，所以只能捕获主线程中的异常，而真正的异常是在子线程中发生的，因此无法捕捉到子线程中的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加了try catch,期望捕获到第一个线程的异常，线程234不应该运行，希望看到打印出Caught Exception</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-11 10:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CantCatchDirectly</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"Thread-1"</span>).start();</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"Thread-2"</span>).start();</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"Thread-3"</span>).start();</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CantCatchDirectly(), <span class="string">"Thread-4"</span>).start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"捕获了异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/CantCatchDirectly_1.png" width=""/> </div>

<p><strong>两种解决方案：</strong></p>
<p>方案一（不推荐）：手动在每个 run 方法里进行 try-catch。</p>
<p>方案二（推荐）：利用 UncaughtExceptionHandler 。</p>
<p>UncaughtExceptionHandler 是 Thread 类中的一个接口，去实现它就可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UncaughtExceptionHandler 接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Method invoked when the given thread terminates due to the</span></span><br><span class="line"><span class="comment">      * given uncaught exception.</span></span><br><span class="line"><span class="comment">      * &lt;p&gt;Any exception thrown by this method will be ignored by the</span></span><br><span class="line"><span class="comment">      * Java Virtual Machine.</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> t the thread</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> e the exception</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 UncaughtExceptionHandler  接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己定义的 MyUncaughtExceptionHanlder</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-11 11:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyUncaughtExceptionHandler</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 打印一些日志信息</span></span><br><span class="line">        Logger logger = Logger.getAnonymousLogger();</span><br><span class="line">        logger.log(Level.WARNING, t.getName() + <span class="string">"线程异常"</span>);</span><br><span class="line">        System.out.println(name + <span class="string">"捕获了"</span> + t.getName() + <span class="string">"的异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用刚才写的 MyUncaughtExceptionHanlder，根据运行结果可以看到，正确处理了异常并打印出相关信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用刚才自己写的 UncaughtExceptionHandler</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-11 11:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseOwnUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 设置默认的全局捕获器</span></span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler(<span class="string">"捕获器"</span>));</span><br><span class="line">        UseOwnUncaughtExceptionHandler r = <span class="keyword">new</span> UseOwnUncaughtExceptionHandler();</span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">"Thread-1"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">"Thread-2"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">"Thread-3"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">"Thread-4"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/MyUncaughtExceptionHanlder.png" width=""/> </div>

<h2 id="7-2-几个问题"><a href="#7-2-几个问题" class="headerlink" title="7.2 几个问题"></a>7.2 几个问题</h2><p><strong>Java 异常体系</strong></p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/JavaException.png" width=""/> </div>

<p>所有的异常都继承自 Throwable 类，在下一层分为 Error 和 Exception。</p>
<p>Error 类描述了 Java 运行时系统内部错误以及资源耗尽等问题。</p>
<p>Exception 又分为两个分支：RuntimeException 和 其他异常。划分的依据是：由程序错误导致的异常属于 RuntimeException，如果程序本身没有问题，但由于像IO错误这类问题导致的异常属于其他异常。因此，“如果出现 RuntimeException 一定是你的问题”。</p>
<p>Java 语言规范将派生于 Error 类和 RuntimeException 类的所有异常称为<strong>非受检(unchecked)异常</strong>或运行时异常；其他异常称为<strong>受检(checked)异常</strong>或编译时异常，编译器会检查是否为受检异常提供了异常处理器。</p>
<p><strong>如何全局处理异常？</strong></p>
<ol>
<li>给程序统一设置</li>
</ol>
<p>首先实现 UncaughtExceptionHandler 接口，在实现的 uncaughtException(Thread t, Throwable e) 方法中，进行处理，比如把错误信息写入日志、或重启线程、或执行其他修复或诊断。其次要告诉 JVM 当线程抛出异常的时候，回调我们的 uncaughtException 方法，用 setDefaultUncaughtExceptionHandler 来设置默认的 UncaughtExceptionHandler。</p>
<ol start="2">
<li>给每个线程或线程池单独设置</li>
</ol>
<p><strong>run 方法是否可以抛出异常?</strong><br>run 方法不能抛出异常，如果运行时发生异常，默认行为是打印异常堆栈，线程停止运行，状态变成 Terminated，但是不影响主线程的运行。</p>
<hr>
<h1 id="8-线程安全问题"><a href="#8-线程安全问题" class="headerlink" title="8. 线程安全问题"></a>8. 线程安全问题</h1><p><strong>什么是线程安全</strong></p>
<div class="note primary">
            <p>当多个线程访问一个对象时,如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步或者在调用方进行任何其他的协调操作,调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。</p><p><strong><em>Java并发编程实战</em></strong></p>
          </div>

<p>“不管业务中遇到怎样的多个线程访问某对象或某方法的情况,而在编程这个业务逻辑的时候,都不需要做任何额外的处理(也就是可以像单线程编程一样) , 程序也可以正常运行(不会因为多线程而出错) , 就可以称为线程安全。”</p>
<p><strong>主要是两个问题：</strong></p>
<ol>
<li>数据争用：同时进行数据的写操作，造成错误数据。</li>
<li>竞争条件：即使不是同时写造成的错误数据，由于顺序原因依然会造成错误，例如在写之前就读取了数据。</li>
</ol>
<p><strong>三类线程安全问题：</strong></p>
<ol>
<li><p>运行结果错误（a++ 多线程下出现消失的请求现象，属于 read-modify-write）。</p>
</li>
<li><p>活跃性问题：死锁、活锁、饥饿等。</p>
</li>
<li><p>对象发布和初始化时的安全问题：</p>
<ol>
<li><p>方法返回一个 private 对象</p>
</li>
<li><p>未完成初始化就把对象提供给外界：</p>
<ol>
<li><p>在构造方法中未初始化完成就 this 赋值</p>
</li>
<li><p>隐式逸出——注册监听事件</p>
</li>
<li><p>构造方法中运行线程</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="8-1-线程安全问题演示"><a href="#8-1-线程安全问题演示" class="headerlink" title="8.1 线程安全问题演示"></a>8.1 线程安全问题演示</h2><h3 id="8-1-1-线程安全问题之一：结果错误"><a href="#8-1-1-线程安全问题之一：结果错误" class="headerlink" title="8.1.1 线程安全问题之一：结果错误"></a>8.1.1 线程安全问题之一：结果错误</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程安全问题第一种：运行结果出错</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-11 19:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadsError1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> MultiThreadsError1 instance = <span class="keyword">new</span> MultiThreadsError1();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">// 为了让两个线程都执行完后再打印结果</span></span><br><span class="line">        <span class="comment">// 使用 join</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(instance.index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Demo 的逻辑是两个线程分别完成 10000次 <code>index++</code> 操作 ，即最后应该输出 20000。但该程序运行后，大概率输出结果是小于 20000。可以由下图分析，首先线程 1 拿到 index，此时 index == 1，线程 1 对其进行加一操作，但是还没有将结果写入index，此时线程 2 拿到了 index，此时 index 还是为 1，线程 2 对其进行加一操作，还没有将结果写入时，又切回了线程 1，最终将 2 写入 index，此时又切换回了线程 2，线程 2 接着上一步，将 2 又一次写入 index。本该是加两次后 index == 3，但实际 index == 2。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/a++Error.png" width=""/> </div>

<h3 id="8-1-2-线程安全问题之二：活跃性问题（死锁、活锁、饥饿）"><a href="#8-1-2-线程安全问题之二：活跃性问题（死锁、活锁、饥饿）" class="headerlink" title="8.1.2 线程安全问题之二：活跃性问题（死锁、活锁、饥饿）"></a>8.1.2 线程安全问题之二：活跃性问题（死锁、活锁、饥饿）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程安全问题第二种：演示死锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-11 20:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadsError2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MultiThreadsError2 r1 = <span class="keyword">new</span> MultiThreadsError2();</span><br><span class="line">        MultiThreadsError2 r2 = <span class="keyword">new</span> MultiThreadsError2();</span><br><span class="line">        r1.flag = <span class="keyword">true</span>;</span><br><span class="line">        r2.flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(r1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r2).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"flag = "</span> + flag);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"true"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="keyword">false</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"false"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/deadlock.png" width=""/> </div>

<h3 id="8-1-3-线程安全问题之三：对象发布和初始化的时候的安全问题"><a href="#8-1-3-线程安全问题之三：对象发布和初始化的时候的安全问题" class="headerlink" title="8.1.3 线程安全问题之三：对象发布和初始化的时候的安全问题"></a>8.1.3 线程安全问题之三：对象发布和初始化的时候的安全问题</h3><p><strong>对象发布</strong>：使对象能够在当前作用域之外的代码使用。</p>
<p><strong>对象逸出：</strong>某些不应该发布的对象被发布的情况。</p>
<p>具体有：</p>
<ol>
<li>方法返回一个private对象 ( private的本意是不让外部访问)。</li>
<li>还未完成初始化(构造函数没完全执行完毕)就把对象提供给外界,比如:<ol>
<li>在构造函数中未初始化完毕就 this 赋值</li>
<li>隐式逸出——注册监听事件</li>
<li>构造方法中运行线程</li>
</ol>
</li>
</ol>
<h4 id="8-1-3-1-对象逸出问题演示"><a href="#8-1-3-1-对象逸出问题演示" class="headerlink" title="8.1.3.1 对象逸出问题演示"></a>8.1.3.1 对象逸出问题演示</h4><p><strong>Demo 1: 方法返回一个 private对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法返回一个 private对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-12 8:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadsError3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; states;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiThreadsError3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        states = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        states.put(<span class="string">"1"</span>, <span class="string">"周一"</span>);</span><br><span class="line">        states.put(<span class="string">"2"</span>, <span class="string">"周二"</span>);</span><br><span class="line">        states.put(<span class="string">"3"</span>, <span class="string">"周三"</span>);</span><br><span class="line">        states.put(<span class="string">"4"</span>, <span class="string">"周四"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处 getStates 直接将 private 类型的 states 直接发布了出去</span></span><br><span class="line">    <span class="comment">// 使得外界可以对其进行修改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getStates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MultiThreadsError3 m = <span class="keyword">new</span> MultiThreadsError3();</span><br><span class="line">        Map&lt;String, String&gt; states = m.getStates();</span><br><span class="line">        System.out.println(states.get(<span class="string">"1"</span>));  <span class="comment">// 周一</span></span><br><span class="line">        states.remove(<span class="string">"1"</span>);</span><br><span class="line">        System.out.println(states.get(<span class="string">"1"</span>));  <span class="comment">// null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Demo 2: 在构造函数中未初始化完毕就 this 赋值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化未完毕，就 this 赋值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-12 8:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadsError4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Point point;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> PointMaker().start();</span><br><span class="line">        Thread.sleep(<span class="number">20</span>); <span class="comment">// Point&#123;x=1, y=0&#125;</span></span><br><span class="line">        <span class="comment">// Thread.sleep(200);  // Point&#123;x=1, y=1&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (point != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(point);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        MultiThreadsError4.point = <span class="keyword">this</span>;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Point&#123;"</span> +</span><br><span class="line">                <span class="string">"x="</span> + x +</span><br><span class="line">                <span class="string">", y="</span> + y +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointMaker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Point 的构造方法中，还没有对 y 完成赋值，就将 this 赋值给静态变量 point。造成主函数中，等待时间不同，发布的 point 不同。</p>
<p><strong>Demo 3：隐式逸出——注册监听事件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 隐式逸出——注册监听事件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-12 9:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadsError5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiThreadsError5</span><span class="params">(MySource source)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注册监听器</span></span><br><span class="line">        source.registerListener(<span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 打印出当前 count 值</span></span><br><span class="line">                System.out.println(<span class="string">"\n得到的数字是"</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 count 赋值为 100</span></span><br><span class="line">        count = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MySource mySource = <span class="keyword">new</span> MySource();</span><br><span class="line">        <span class="comment">// 利用子线程触发监听器</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 10 ms 之后触发监听器</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                mySource.eventCome(<span class="keyword">new</span> Event() &#123;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        MultiThreadsError5 multiThreadsError5 = <span class="keyword">new</span> MultiThreadsError5(mySource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySource</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> EventListener listener;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(EventListener eventListener)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.listener = eventListener;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">eventCome</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                listener.onEvent(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"未初始化完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Event</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures@master/Concurrency/MultiThreadsError5.png" width=""/> </div>

<p>在构造方法中注册了监听器时，EventListener 是匿名内部类，而在其内部的 onEvent 方法中已经持有了外部类的引用，此时，由于构造方法还未完成对 count 的初始化，因此 onEvent 方法中会打印出 count 为 0。</p>
<p><strong>Demo 4：构造方法中运行线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造方法中新建线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-12 10:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadsError6</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; states;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiThreadsError6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                states = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                states.put(<span class="string">"1"</span>, <span class="string">"周一"</span>);</span><br><span class="line">                states.put(<span class="string">"2"</span>, <span class="string">"周二"</span>);</span><br><span class="line">                states.put(<span class="string">"3"</span>, <span class="string">"周三"</span>);</span><br><span class="line">                states.put(<span class="string">"4"</span>, <span class="string">"周四"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getStates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MultiThreadsError6 multiThreadsError6 = <span class="keyword">new</span> MultiThreadsError6();</span><br><span class="line">        <span class="comment">// Thread.sleep(1000);</span></span><br><span class="line">        System.out.println(multiThreadsError6.getStates().get(<span class="string">"1"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造方法中运行子线程，完成初始化，但子线程执行完 run 方法需要时间，所以在获取 map 中数据时，由于实际上未完成初始化工作，会造成空指针异常。如果在获取数据之前等待一段时间，是可以正确获取到。</p>
<h2 id="8-2-各种需要考虑线程安全的情况"><a href="#8-2-各种需要考虑线程安全的情况" class="headerlink" title="8.2 各种需要考虑线程安全的情况"></a>8.2 各种需要考虑线程安全的情况</h2><ol>
<li>访问<strong>共享</strong>的变量或资源，会有并发风险，比如对象的属性、静态变量、共享缓存、数据库等。</li>
<li>所有依赖<strong>时序</strong>的操作，即使每-步操作都是线程安全的，还是存在并发问题: <ol>
<li>read- modify- write 操作: - 一个线程读取了一个共享数据，并在此基础上更新该数据，例如 index++。</li>
<li>check- then- -act 操作:一个线程读取了一个共享数据，并在此基础上决定其下一一个的操作，例如：if 语句。</li>
</ol>
</li>
<li>不同的数据之间存在<strong>捆绑</strong>关系的时候，比如 IP和端口号，必须同时修改或同时不修改。</li>
<li>我们使用<strong>其他类</strong>的时候，如果对方没有声明自己是线程安全的，那么大概率会存在并发问题的隐患。比如 HashMap 没有生命是并发安全的，如果在并发调用 HashMap 时会出错。</li>
</ol>
<h2 id="8-3-多线程性能问题"><a href="#8-3-多线程性能问题" class="headerlink" title="8.3 多线程性能问题"></a>8.3 多线程性能问题</h2><p>性能问题有很多体现，比如：服务响应慢、吞吐量降低、资源消耗大等。</p>
<h3 id="多线程存在性能问题的原因："><a href="#多线程存在性能问题的原因：" class="headerlink" title="多线程存在性能问题的原因："></a>多线程存在性能问题的原因：</h3><ol>
<li><p>调度：上下文切换</p>
</li>
<li><p>协作：内存同步</p>
</li>
</ol>
<h3 id="调度：上下文切换"><a href="#调度：上下文切换" class="headerlink" title="调度：上下文切换"></a>调度：上下文切换</h3><p>当某个线程进入阻塞状态时，线程调度器就会阻塞该线程，让另一个等待的线程进入 Runnable 状态，上下文切换时需要挂起某个线程，同时将该线程的状态(上下文)保存在内存中。当线程调度器挂起一个线程，另一个线程执行时，之前缓存的数据也会失效，CPU 需要重新进行缓存。因此上下文切换以及缓存上的开销会造成性能问题。</p>
<p>为了避免频繁的上下文切换，CPU 设置一个最小执行时间，否则可能上下文切换的性能消耗已经大于程序本身执行的消耗。</p>
<p>当程序频繁地去抢锁或者经常进行 IO 读写等引起频繁阻塞，会导致密集的上下文切换。</p>
<h3 id="协作：内存同步"><a href="#协作：内存同步" class="headerlink" title="协作：内存同步"></a>协作：内存同步</h3><p>CPU 为了提高处理速度，可能会对指令进行重排序，但多线程环境下，为了数据的正确性，同步手段往往会禁止编译器优化；</p>
<p>JMM 模型规定了主内存和本地内存，多线程为了数据的一致性有时会使各个线程的缓存失效，也会导致性能问题。</p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://coding.imooc.com/class/362.html" target="_blank" rel="noopener">Java并发核心知识体系精讲</a></li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Song Ningning 支付宝">
        <p>支付宝</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Song Ningning 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Song Ningning
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://sningning.github.io/posts/undefined/" title="Java 多线程基础知识">https://sningning.github.io/posts/undefined/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 多线程</a>
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"><i class="fa fa-tag"></i> 并发</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/17d7368a/" rel="prev" title="JDBC 技术">
      <i class="fa fa-chevron-left"></i> JDBC 技术
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/15ce7a39/" rel="next" title="用 size 变量解耦 front 和 last 实现循环队列">
      用 size 变量解耦 front 和 last 实现循环队列 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-创建多线程的方式"><span class="nav-text">1. 创建多线程的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Thread-类官方文档"><span class="nav-text">1.1 Thread 类官方文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-两种创建多线程的方式"><span class="nav-text">1.2 两种创建多线程的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-其他方式"><span class="nav-text">1.3 其他方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【问题】实现-Runnable-接口和继承-Thread-类哪种方式更好一些？"><span class="nav-text">【问题】实现 Runnable 接口和继承 Thread 类哪种方式更好一些？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-启动线程的方式"><span class="nav-text">2. 启动线程的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-start-方法含义"><span class="nav-text">2.1 start() 方法含义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-启动新线程"><span class="nav-text">2.1.1 启动新线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-准备工作"><span class="nav-text">2.1.2 准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-重复调用-start-方法"><span class="nav-text">2.1.3 重复调用 start() 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-start-源码"><span class="nav-text">2.2 start() 源码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-停止线程的方式"><span class="nav-text">3. 停止线程的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-原理"><span class="nav-text">3.1 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-正确停止线程-star"><span class="nav-text">3.2 正确停止线程(:star:)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-线程会在什么情况下停止"><span class="nav-text">3.2.1 线程会在什么情况下停止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-正确的停止方法：interrupt"><span class="nav-text">3.2.2 正确的停止方法：interrupt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-两种较好的停止线程方式"><span class="nav-text">3.2.3 两种较好的停止线程方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-1-优先选择：传递中断"><span class="nav-text">3.2.3.1 优先选择：传递中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-2-不想或无法传递：恢复中断"><span class="nav-text">3.2.3.2 不想或无法传递：恢复中断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【问题】正确停止线程的好处？"><span class="nav-text">【问题】正确停止线程的好处？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-错误停止线程方式-star"><span class="nav-text">3.3 错误停止线程方式(:star:)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-被弃用的-stop、suspend-和-resume-方法"><span class="nav-text">3.3.1 被弃用的 stop、suspend 和 resume 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-用-volatile-设置-boolean-标记位"><span class="nav-text">3.3.2 用 volatile 设置 boolean 标记位</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-几个方法"><span class="nav-text">3.4 几个方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-interrupt"><span class="nav-text">3.4.1 interrupt()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-判断是否已被中断的-2-个方法"><span class="nav-text">3.4.2 判断是否已被中断的 2 个方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-线程的生命周期"><span class="nav-text">4. 线程的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-线程的-6-种状态"><span class="nav-text">4.1 线程的 6 种状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-阻塞状态"><span class="nav-text">4.2 阻塞状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-线程状态总结"><span class="nav-text">4.3 线程状态总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-6-种状态"><span class="nav-text">4.3.1 6 种状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-转换关系和转换条件"><span class="nav-text">4.3.1 转换关系和转换条件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Thread-和-Object-类中线程相关方法"><span class="nav-text">5. Thread 和 Object 类中线程相关方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-概览"><span class="nav-text">5.1 概览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-作用"><span class="nav-text">5.2.1 作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-几个-Demo"><span class="nav-text">5.2.2 几个 Demo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-wait-notify-notifyAll-特点、性质"><span class="nav-text">5.2.2 wait, notify, notifyAll 特点、性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【问题】如何选择用-notify-还是-nofityAll"><span class="nav-text">【问题】如何选择用 notify 还是 nofityAll ?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【Demo】生产者消费者设计模式"><span class="nav-text">【Demo】生产者消费者设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【Demo】使用两个线程交替打印-1-100-的奇偶数。"><span class="nav-text">【Demo】使用两个线程交替打印 1-100 的奇偶数。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【问题】为什么-wait-必须在同步（synchronized）方法-代码块使用"><span class="nav-text">【问题】为什么 wait 必须在同步（synchronized）方法&#x2F;代码块使用?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【问题】为什么线程通信的方法wait，notify-和notifyAll-被定义在-Object-类里"><span class="nav-text">【问题】为什么线程通信的方法wait，notify 和notifyAll 被定义在 Object 类里?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【问题】wait-方法是属于-Object-对象的，那调用-Thread-wait-会怎么样-（Thread-肯定也是继承自-Object）"><span class="nav-text">【问题】wait 方法是属于 Object 对象的，那调用 Thread.wait 会怎么样? （Thread 肯定也是继承自 Object）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-sleep"><span class="nav-text">5.3 sleep</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-关于-sleep-的几个-Demo"><span class="nav-text">5.3.1 关于 sleep 的几个 Demo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【问题】wait、sleep异同"><span class="nav-text">【问题】wait、sleep异同</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-join"><span class="nav-text">5.4 join</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-1-几个关于-join-的-Demo："><span class="nav-text">5.4.1 几个关于 join 的 Demo：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-2-join-原理"><span class="nav-text">5.4.2 join 原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-yield"><span class="nav-text">5.5 yield</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-线程属性"><span class="nav-text">6. 线程属性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-线程-ID"><span class="nav-text">6.1 线程 ID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-线程名字"><span class="nav-text">6.2 线程名字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-守护线程"><span class="nav-text">6.3 守护线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-线程优先级"><span class="nav-text">6.4 线程优先级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-线程的异常处理"><span class="nav-text">7. 线程的异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-UncaughtExceptionHandler-类"><span class="nav-text">7.1 UncaughtExceptionHandler 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-几个问题"><span class="nav-text">7.2 几个问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-线程安全问题"><span class="nav-text">8. 线程安全问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-线程安全问题演示"><span class="nav-text">8.1 线程安全问题演示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-1-线程安全问题之一：结果错误"><span class="nav-text">8.1.1 线程安全问题之一：结果错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-2-线程安全问题之二：活跃性问题（死锁、活锁、饥饿）"><span class="nav-text">8.1.2 线程安全问题之二：活跃性问题（死锁、活锁、饥饿）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-3-线程安全问题之三：对象发布和初始化的时候的安全问题"><span class="nav-text">8.1.3 线程安全问题之三：对象发布和初始化的时候的安全问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-3-1-对象逸出问题演示"><span class="nav-text">8.1.3.1 对象逸出问题演示</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-各种需要考虑线程安全的情况"><span class="nav-text">8.2 各种需要考虑线程安全的情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-多线程性能问题"><span class="nav-text">8.3 多线程性能问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程存在性能问题的原因："><span class="nav-text">多线程存在性能问题的原因：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度：上下文切换"><span class="nav-text">调度：上下文切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协作：内存同步"><span class="nav-text">协作：内存同步</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Song Ningning"
      src="/images/profile_pic.jpg">
  <p class="site-author-name" itemprop="name">Song Ningning</p>
  <div class="site-description" itemprop="description">己所不欲 勿施于人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Sningning" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sningning" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/qfsnn1117@126.com" title="E-Mail → qfsnn1117@126.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Song Ningning</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'pBbqtWKVEqWEt7mPeHsCoC3Q-gzGzoHsz',
      appKey     : 'Tb92Uo4lbYgTBTGR2aWri46v',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
