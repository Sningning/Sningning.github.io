<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Morris 遍历</title>
    <url>/posts/4a4f5ebc/</url>
    <content><![CDATA[<p>利用 Morris 遍历实现二叉树的先序，中序，后续遍历，时间复杂度 O(N)，额外空间复杂度 O(1)。</p>
<a id="more"></a>

<h1 id="1-算法流程"><a href="#1-算法流程" class="headerlink" title="1. 算法流程"></a>1. 算法流程</h1><p>Morrris 遍历利用叶子节点的左右空节点，达到 O(1) 的空间复杂度。</p>
<p>当前节点记为 <code>cur</code>（引用）。</p>
<ul>
<li>如果 <code>cur</code> 没有左孩子（<code>cur.left == null</code>），将 <code>cur</code> 向右移动（<code>cur = cur.right</code>）；</li>
<li>如果 <code>cur</code> 有左孩子 （<code>cur.left != null</code>），找到 <code>cur</code> 左子树上最右侧的节点，记为 <code>mostRight</code>：<ul>
<li>如果 <code>mostRight</code> 的右孩子为空（<code>mostRight.right == null</code>），让其右孩子指向 <code>cur</code>（<code>mostRight.right = cur</code>），<code>cur</code> 向左移动（<code>cur = cur.left</code>）；</li>
<li>如果 <code>mostRight</code> 的右孩子指向 <code>cur</code>（<code>mostRight.right == cur</code>），让其右孩子指向空（<code>mostRight.right = null</code>），<code>cur</code> 向右移动（<code>cur = cur.right</code>）。</li>
</ul>
</li>
</ul>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/Morris.png
"> </div>

<hr>
<h1 id="2-性质"><a href="#2-性质" class="headerlink" title="2. 性质"></a>2. 性质</h1><p>将 Morris 遍历与普通的递归遍历进行对比：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 递归遍历二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// System.out.println(root.val);</span></span><br><span class="line">    process(root.left);</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// System.out.println(root.val);</span></span><br><span class="line">    process(root.right);</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// System.out.println(root.val);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对于二叉树的每个节点(非空)，都有 3 次访问机会，分别是访问该节点左子树之前；访问左子树和右子树之间；访问右子树之后。分别对应下图的 3 个紫色的点。更多关于二叉树的介绍可以参考之前的一篇博客：<a href="https://sningning.github.io/posts/523021e3/">数据结构04-二分搜索树</a>。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/遍历.png" width="600px"> </div> 

<p>但对于 Morris 遍历，如果有左子树，那么它可以执行下面的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// System.out.println(root.val);</span></span><br><span class="line">process(root.left);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// System.out.println(root.val);</span></span><br><span class="line">process(root.right);</span><br></pre></td></tr></tbody></table></figure>

<p>如果没有左子树，那么只能执行下面的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// System.out.println(root.val);</span></span><br><span class="line">process(root.right);</span><br></pre></td></tr></tbody></table></figure>

<p>如果一个节点有左子树，使用 Morris 遍历可以访问该节点两次；如果一个节点没有左子树，使用 Morris 遍历之只能访问该节点一次。当第二次访问某个节点时，那么，该节点左子树必定已经全都访问过了。但无论如何，Morris 遍历无法做到第三次回到自身那个节点。</p>
<p>Morris 遍历是如何判断是第一次访问该节点还是第二次访问该节点呢？</p>
<p>对于递归来说，系统栈会记录执行到第几行，递归回来后，接着上次的继续执行；Morris 遍历则是根据当前节点左子树最右节点的右指针来判断，如果左子树上最右侧节点的右指针为 <code>null</code>，则是第一次访问当前节点；如果左子树上最右侧节点的右指针为 <code>cur</code>，则是第二次访问当前节点。</p>
<p>将上面算法流程用代码翻译下来就是 Morris 遍历：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Morris 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morris</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    TreeNode mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 先让 mostRight 指向 cur 的左孩子</span></span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) {</span><br><span class="line">                <span class="comment">// 在左子树中找最右节点</span></span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 执行到这里，说明 mostRight == null 或 mostRight.right == cur</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 执行到这里，mostRight == null，说明是第一次访问 cur 节点</span></span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            } <span class="keyword">else</span> { </span><br><span class="line">                <span class="comment">// 执行到这里，mostRight.right == cur，说明是第二次访问 cur 节点</span></span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 有两种可能会执行到这里：</span></span><br><span class="line">        <span class="comment">// ① cur 没有左孩子，从第 10 行直接跳到这里</span></span><br><span class="line">        <span class="comment">// ② cur 的左子树的最右节点的右孩子指向 cur 自身，执行完第 20 行跳到这里</span></span><br><span class="line">        cur = cur.right;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="3-Morris-前中后序遍历"><a href="#3-Morris-前中后序遍历" class="headerlink" title="3. Morris 前中后序遍历"></a>3. Morris 前中后序遍历</h1><h2 id="3-1-Morris-前序遍历"><a href="#3-1-Morris-前序遍历" class="headerlink" title="3.1 Morris 前序遍历"></a>3.1 Morris 前序遍历</h2><p>对照一般的递归方法的前序遍历，前序遍历是当第一次访问该节点的时候去处理该节点（这里是打印输出）。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 递归前序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 在第二次访问该节点的时候操作该节点</span></span><br><span class="line">    System.out.println(root.val);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对于 Morris 遍历来说，如果某个节点有左孩子，那么会访问该节点两次，在第一次访问时操作该节点；如果某个节点没有左孩子，只会访问该节点一次，就在访问到的时候操作该节点。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Morris 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morrisPreOrder</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    TreeNode mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) {</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (mostRight == <span class="keyword">null</span>) {</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                <span class="comment">// 如果执行到这里，说明 cur 有左子树，这是第一次访问该节点</span></span><br><span class="line">                <span class="comment">// 就在这个时候操作该节点 </span></span><br><span class="line">                System.out.println(cur.val); </span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                mostRight = <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 如果执行到这里，说明 cur 没有左子树，这是第一次也是最后一次访问该节点</span></span><br><span class="line">            <span class="comment">// 就在这个时候操作该节点</span></span><br><span class="line">            System.out.println(cur.val); </span><br><span class="line">        }</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<br>

<h2 id="3-2-Morris-中序遍历"><a href="#3-2-Morris-中序遍历" class="headerlink" title="3.2 Morris 中序遍历"></a>3.2 Morris 中序遍历</h2><p>同样对照递归中序遍历，递归版的中序遍历是在第二次访问该节点的时候操作该节点。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 递归中序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    <span class="comment">// 在第二次访问该节点的时候操作该节点</span></span><br><span class="line">    System.out.println(root.val);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对于 Morris 遍历来说，如果某个节点有左孩子，那么会访问该节点两次，在第二次访问时操作该节点；如果某个节点没有左孩子，只会访问该节点一次，就在访问到的时候操作该节点。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Morris 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morrisInOrder</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    TreeNode mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) {</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (mostRight == <span class="keyword">null</span>) {</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                mostRight = <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">        } </span><br><span class="line">        <span class="comment">// 有两种可能会执行到这里：</span></span><br><span class="line">        <span class="comment">// ① cur 没有左孩子，从第 9 行直接跳到这里，这是第一次也是最后一次访问该节点，在此刻操作该节点</span></span><br><span class="line">        <span class="comment">// ② cur 有左孩子，即从第 19 行跳到这里，说明是第二次访问该节点，在此时操作该节点</span></span><br><span class="line">        System.out.println(cur.val); </span><br><span class="line">        cur = cur.right;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<br>

<h2 id="3-3-Morris-后序遍历"><a href="#3-3-Morris-后序遍历" class="headerlink" title="3.3 Morris 后序遍历"></a>3.3 Morris 后序遍历</h2><p>递归的后续遍历，是在第三次访问该节点是对其进行操作。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 递归后序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    <span class="comment">// 在第三次访问该节点的时候操作该节点</span></span><br><span class="line">    System.out.println(root.val);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但 Morris 遍历无法三次访问一个节点，怎么做到后序遍历呢？</p>
<p>直接将具体做法：</p>
<p>对于 Morris 遍历，有的节点会被访问两次，有的节点会被访问一次，只关注会被访问两次的节点，当第二次访问该节点时，逆序操作其左子树的右边界，最后在函数退出之前，再单独逆序操作一次整棵树的右边界。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/MorrisPostOrder.png">
 </div> 

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morrisPostOrder</span><span class="params">(Node root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    TreeNode mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) {</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) {</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 第二次访问到该节点时，逆序打印其左子树的右边界</span></span><br><span class="line">                printRightEdge(cur.left);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 退出之前单独逆序打印整棵树的右边界</span></span><br><span class="line">    printRightEdge(root);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>下面具体看 <code>printRightEdge(TreeNode node)</code> 函数的实现，<code>printRightEdge(TreeNode node)</code> 函数的功能是要逆序打印 <code>node</code> 的右边界(包含 <code>node</code>)。我们当然可以使用栈来辅助，但是使用栈又会占用额外空间。因此，将逆序打印右边界看成是对单链表的操作，先将右边界按照单链表逆序的方式逆序，打印完后，再逆序回来。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/printRightEdge.png">
 </div> 

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 逆序打印以 head 为根的二叉树的右边界</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printRightEdeg</span><span class="params">(TreeNode head)</span> </span>{</span><br><span class="line">    TreeNode tail = reverseEdge(head);</span><br><span class="line">    TreeNode cur = tail;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">        System.put.println(cur.val);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    }</span><br><span class="line">    reverseEdeg(tail);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 逆序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reverseEdge</span><span class="params">(TreeNode from)</span> </span>{</span><br><span class="line">    TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (from != <span class="keyword">null</span>) {</span><br><span class="line">        next = from.right;</span><br><span class="line">        from.right = prev;</span><br><span class="line">        prev = from;</span><br><span class="line">        from = next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="4-为什么时间复杂度是-O-N"><a href="#4-为什么时间复杂度是-O-N" class="headerlink" title="4. 为什么时间复杂度是 O(N)"></a>4. 为什么时间复杂度是 O(N)</h1><div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/tree.png">
 </div> 

<p>下面还是还原遍历的过程， <code>cur</code> → <code>1</code>，<code>mostRight</code> → <code>2</code>、<code>4</code>，表示当 <code>cur</code> 指向 <code>1</code> 这个节点时，<code>mostRight</code> 需要遍历的节点为 <code>2</code>、<code>4</code>。</p>
<p><code>cur</code> → <code>1</code>，<code>mostRight</code> → <code>2</code>、<code>4</code>；</p>
<p><code>cur</code> → <code>2</code>，<code>mostRight</code> → <code>3</code>；</p>
<p><code>cur</code> → <code>3</code>，<code>mostRight</code> → <code>null</code>；</p>
<p><code>cur</code> → <code>2</code>，<code>mostRight</code> → <code>3</code>；</p>
<p><code>cur</code> → <code>4</code>，<code>mostRight</code> → <code>null</code>；</p>
<p><code>cur</code> → <code>1</code>，<code>mostRight</code> → <code>2</code>、<code>4</code>；</p>
<p><code>cur</code> → <code>5</code>，<code>mostRight</code> → <code>6</code>；</p>
<p><code>cur</code> → <code>6</code>，<code>mostRight</code> → <code>null</code>；</p>
<p><code>cur</code> → <code>5</code>，<code>mostRight</code> → <code>6</code>；</p>
<p><code>cur</code> → <code>7</code>，<code>mostRight</code> → <code>null</code>；</p>
<p><code>cur</code> → <code>null</code>。</p>
<p>首先，整棵二叉树可以被<strong>右边界</strong>划分，而对于一个节点，<code>cur</code> 最多会访问两次，每次访问，<code>mostRight</code>都会走一遍 <code>cur</code> 左子树的右边界，除了这两次遍历之外，这个右边界不会被再次遍历，也就是每个右边界只会被遍历有限次，而所有的右边界节点的总数又是 <code>N</code>，因此 Morris 遍历的时间复杂度还是 O(N)。</p>
<hr>
<h1 id="5-问题"><a href="#5-问题" class="headerlink" title="5. 问题"></a>5. 问题</h1><p>Morris 遍历会改变输入的数据的结构，因此如果要求不能该改变原本的树的结构，那么就不能使用 Morris 遍历。但是，这个算法真的是太 <span class="github-emoji" style="display:inline;vertical-align:middle;color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f42e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f42e.png?v8">🐮</span> <span class="github-emoji" style="display:inline;vertical-align:middle;color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f37a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f37a.png?v8">🍺</span>了！</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>用 size 变量解耦 front 和 last 实现循环队列</title>
    <url>/posts/15ce7a39/</url>
    <content><![CDATA[<p>用数组实现循环队列和双端循环队列，并用<code>size</code>变量实现解耦<code>front</code>和<code>last</code>。</p>
<hr>
<a id="more"></a>

<p>LeetCode 中 第【<a href="https://leetcode-cn.com/problems/design-circular-queue" target="_blank" rel="noopener">622</a>】题是设计一个循环队列，把题目抄过来：</p>
<blockquote>
<p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p>
<p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p>
<p>你的实现应该支持如下操作：</p>
<ul>
<li>MyCircularQueue(k): 构造器，设置队列长度为 k 。</li>
<li>Front: 从队首获取元素。如果队列为空，返回 -1 。</li>
<li>Rear: 获取队尾元素。如果队列为空，返回 -1 。</li>
<li>enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。</li>
<li>deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。</li>
<li>isEmpty(): 检查循环队列是否为空。</li>
<li>isFull(): 检查循环队列是否已满。</li>
</ul>
</blockquote>
<hr>
<p>之前用数组设计循环队列，里面为了判断元素位置，<code>front</code> 和 <code>last</code> 两个变量算来算去，很是糊涂。后来看了左程云老师的一节课，里面讲了下用数组实现循环队列，最主要的是，用<code>size</code>变量来实现了<code>front</code>和<code>last</code>两个指针的解耦，很清爽，总结一下。</p>
<p>我们用数组实现循环队列。定义一个数组<code>arr</code>来记录数据，定义变量<code>size</code>来记录当前数组或者队列的元素个数。</p>
<p>显然，当<code>size == arr.length</code>时，队列已经满了，就不能再添加元素了；当<code>size != arr.length</code>时，说明还有空位，可以新加元素。所以，我们是<strong>通过<code>size</code>和<code>arr.length</code>的关系来判断是否能添加元素</strong>。后续的工作就是维护好<code>size</code>这个重要的变量。</p>
<p>此外，还需要定义<code>front</code>指针和<code>last</code>指针。<strong><code>front</code>指针永远指向队列头部的那个元素</strong>；<strong><code>last</code>指针永远指向队尾最后一个元素的后一个位置</strong>，也就是新元素待插入的位置。<br><br><br>有了<code>size</code>变量后，一切变得简单。</p>
<ul>
<li><p><code>enQueue(int value)</code>操作：因为 last 的位置就是新元素待插入的位置，因此直接将新元素放到last位置，维护 size。那么怎样维护 last 指针呢？有两种情况：</p>
<ul>
<li><p>情况 1：last 当前指向的不是数组最后一个位置，即 <code>last != arr.length - 1</code>，此时，直接 last++ 就好；</p>
</li>
<li><p>情况 2：last 当前指向数组最后一个位置，即 <code>last == arr.length - 1</code>，此时，last 再往后的话就越界了，所以要从头开始，即 last = 0。</p>
</li>
</ul>
<br>   
</li>
<li><p><code>deQueue()</code>操作：因为front指针指的就是队首元素，所以我们只需要后移 front 指针就可以实现出队操作，同时维护 size。这时也有两种情况：</p>
<ul>
<li><p>情况 1：front 不在数组最后位置，因为不在最后，所以可以放心的执行 front++；</p>
</li>
<li><p>情况 2：front 位于数组最后位置，即<code>front==arr.length - 1</code>，这时，front 后移的操作变成了 front 回到数组第一个位置，即<code>front = 0</code>。</p>
</li>
</ul>
<br>
</li>
<li><p><code>Front()</code>操作：很简单，因为 front 指针永远指向队首元素，所以返回<code>arr[front]</code>即可。</p>
</li>
</ul>
<br>

<ul>
<li><code>Rear()</code>操作：因为 last 并不是指向队尾元素，而是队尾元素后面那个位置，所以需要判断下 last 当前的位置是不是在数组的第一个位置，如果是，那么队尾元素就是数组最后一个元素；否则直接返回 last 前面那个元素即可。</li>
</ul>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/02-Stacks-and-Queues/CircularQueue.gif" width=""> </div>

<p>这样思考的话，写代码就比较容易了。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Queue size is less than 0!"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.arr = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.front = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.last = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (size == arr.length) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        arr[last] = value;</span><br><span class="line">        size ++;</span><br><span class="line">        last = last == arr.length - <span class="number">1</span> ? <span class="number">0</span> : last + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        front = front == arr.length - <span class="number">1</span> ? <span class="number">0</span> : front + <span class="number">1</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the last item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> last == <span class="number">0</span> ? arr[arr.length - <span class="number">1</span>] : arr[last - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size == arr.length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>【<a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641</a>】题也是设计一个循环队列，不过是双端循环队列，即在队列两头都可以删除或添加元素。把题目抄过来：</p>
<blockquote>
<p>设计实现双端队列。<br>你的实现需要支持以下操作：</p>
<ul>
<li>MyCircularDeque(k)：构造函数,双端队列的大小为k。</li>
<li>insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。</li>
<li>insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。</li>
<li>deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。</li>
<li>deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。</li>
<li>getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。</li>
<li>getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。</li>
<li>isEmpty()：检查双端队列是否为空。</li>
<li>isFull()：检查双端队列是否满了。</li>
</ul>
</blockquote>
<p>可以看出来总体思路和 622 题差不多，多了<code>insertFront()</code>和<code>deleteLast()</code>两个方法。剩下的方法实现照搬 622 题。</p>
<p>我们还是通过<code>size</code>和<code>arr.length</code>的关系来判断是否能添加或者删除元素，实现 front 和 last 的解耦。</p>
<ul>
<li><code>insertFront()</code>操作：由于 front 是队首元素的位置，要在队首插入元素，就是要在 front 前面一个位置插入元素，这时候还是两种情况：<ul>
<li>情况 1：front 不是指向数组第一个位置，这时候直接将新元素插入到 front - 1 位置即可，然后 front–，同时维护 size；</li>
<li>情况 2：front 指向数组最后一个位置，此时，要插入的元素位置应该是数组最后位置，即<code>arr.length - 1</code>位置，然后维护 front 和 size。</li>
</ul>
</li>
</ul>
<br>

<ul>
<li><code>deleteLast()</code>操作：由于 last 指向队尾元素的后一个位置，所以从队尾删除元素，就是删除 last 前面那个元素，两种情况：<ul>
<li>情况 1：last 不是指向数组第一个位置，此时直接维护 last– 即可；</li>
<li>情况 2：last 指向数组第一个位置，这是 last 前面的元素就是数组最后一个位置的元素，这是，只需让 last 指向数组最后一个位置即可。</li>
</ul>
</li>
</ul>
<p>直接上代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularDeque</span><span class="params">(<span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Deque size is less than 0!"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.arr = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.front = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.last = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insertFront</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (size == arr.length) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="number">0</span>) {</span><br><span class="line">            arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">            front = arr.length - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            arr[--front] = value;</span><br><span class="line">        }</span><br><span class="line">        size ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insertLast</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (size == arr.length) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        arr[last] = value;</span><br><span class="line">        size ++;</span><br><span class="line">        last = last == arr.length - <span class="number">1</span> ? <span class="number">0</span> : last + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteFront</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        front = front == arr.length - <span class="number">1</span> ? <span class="number">0</span> : front + <span class="number">1</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteLast</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="number">0</span>) {</span><br><span class="line">            last = arr.length - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            last --;</span><br><span class="line">        }</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFront</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRear</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> last == <span class="number">0</span> ? arr[arr.length - <span class="number">1</span>] : arr[last - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size == arr.length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC 技术</title>
    <url>/posts/17d7368a/</url>
    <content><![CDATA[<p>Java 数据库连接，（Java Database Connectivity，简称JDBC）是 Java 语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC是面向关系型数据库的。</p>
<a id="more"></a>


<h1 id="1-JDBC-概述"><a href="#1-JDBC-概述" class="headerlink" title="1. JDBC 概述"></a>1. JDBC 概述</h1><h2 id="1-1-Java-中的数据存储技术"><a href="#1-1-Java-中的数据存储技术" class="headerlink" title="1.1 Java 中的数据存储技术"></a>1.1 Java 中的数据存储技术</h2><p>在 Java中，数据库存取技术可分为如下几类：</p>
<ul>
<li>JDBC 直接访问数据库</li>
<li>JDO (Java Data Object )技术</li>
<li>第三方 O/R 工具，如 Hibernate, Mybatis 等</li>
</ul>
<p>JDO、Hibernate、MyBatis 等更好的封装了 JDBC。</p>
<h2 id="1-2-JDBC-介绍"><a href="#1-2-JDBC-介绍" class="headerlink" title="1.2 JDBC 介绍"></a>1.2 JDBC 介绍</h2><p>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统、通用的 SQL 数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，使用这些类库可以以一种<strong>标准</strong>的方法、方便地访问数据库资源。</p>
<p>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</p>
<p>使用 JDBC 可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/JDBC/jdbc.png" width="800"> </div>


<h2 id="1-3-JDBC-体系结构"><a href="#1-3-JDBC-体系结构" class="headerlink" title="1.3 JDBC 体系结构"></a>1.3 JDBC 体系结构</h2><p>JDBC接口（API）包括两个层次：</p>
<ul>
<li><p><strong>面向应用的 API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</p>
</li>
<li><p><strong>面向数据库的 API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</p>
</li>
</ul>
<blockquote>
<p><strong>JDBC 是 Sun 公司提供一套用于数据库操作的接口，程序员只需要面向这套接口编程即可。不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。——面向接口编程</strong></p>
</blockquote>
<h2 id="1-4-JDBC-程序编写步骤"><a href="#1-4-JDBC-程序编写步骤" class="headerlink" title="1.4 JDBC 程序编写步骤"></a>1.4 JDBC 程序编写步骤</h2><div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/JDBC/flowchart.jpg" width="450"> </div>

<hr>
<h1 id="2-获取数据库连接"><a href="#2-获取数据库连接" class="headerlink" title="2. 获取数据库连接"></a>2. 获取数据库连接</h1><p>四个要素：Driver 接口实现类、URL、用户名、密码。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.读取配置文件中的 4 个基本信息</span></span><br><span class="line">    InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream("jdbc.properties");</span><br><span class="line">    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(is);</span><br><span class="line">    Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">    pros.load(bis);</span><br><span class="line"></span><br><span class="line">    String user = pros.getProperty(<span class="string">"user"</span>);</span><br><span class="line">    String password = pros.getProperty(<span class="string">"password"</span>);</span><br><span class="line">    String url = pros.getProperty(<span class="string">"url"</span>);</span><br><span class="line">    String driverClass = pros.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.加载驱动</span></span><br><span class="line">    Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.获取连接</span></span><br><span class="line">    Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">    System.out.println(conn);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p>
<figure class="highlight properties"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">admin</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></tbody></table></figure>


<div class="note primary">
            <p><strong>使用配置文件的好处：</strong><br>① 实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码<br>② 如果修改了配置信息，省去重新编译的过程。</p>
          </div>

<p>获取连接和关闭资源是常用操作，将其包装为一个工具类：JDBCUtils.java</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作数据库的工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span>: JDBCUtils</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020-04-05 18:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JDBCUtils</span><span class="params">()</span> </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据库连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: java.sql.Connection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Song Ningning</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020-04-05 18:33</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 读取配置文件中的 4 个基本信息</span></span><br><span class="line">        InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">"jdbc.properties"</span>);</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(is);</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(bis);</span><br><span class="line"></span><br><span class="line">        String user = properties.getProperty(<span class="string">"user"</span>);</span><br><span class="line">        String password = properties.getProperty(<span class="string">"password"</span>);</span><br><span class="line">        String url = properties.getProperty(<span class="string">"url"</span>);</span><br><span class="line">        String driverClass = properties.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 加载驱动</span></span><br><span class="line">        Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 获取连接</span></span><br><span class="line">        Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭 Connection 和 Statement 的操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 直接将 Statement 关闭，PreparedStatement 也会一起关闭</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: connection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: statement</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Song Ningning</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020-04-05 18:37</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeResourse</span><span class="params">(Connection conn, Statement ps)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) {</span><br><span class="line">                conn.close();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="keyword">null</span>) {</span><br><span class="line">                ps.close();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭 Connection, Statement, ResultSet 的操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: connection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: statement</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: resultSet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Song Ningning</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020-04-05 22:09</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeResourse</span><span class="params">(Connection conn, Statement ps, ResultSet rs)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) {</span><br><span class="line">                conn.close();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="keyword">null</span>) {</span><br><span class="line">                ps.close();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="keyword">null</span>) {</span><br><span class="line">                rs.close();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="3-使用-PreparedStatement-实现-CRUD-操作"><a href="#3-使用-PreparedStatement-实现-CRUD-操作" class="headerlink" title="3. 使用 PreparedStatement 实现 CRUD 操作"></a>3. 使用 PreparedStatement 实现 CRUD 操作</h1><h2 id="3-1-操作和访问数据库"><a href="#3-1-操作和访问数据库" class="headerlink" title="3.1 操作和访问数据库"></a>3.1 操作和访问数据库</h2><p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。一个数据库连接就是一个Socket连接。</p>
<p>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</p>
<ul>
<li>Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 </li>
<li>PreparedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。</li>
<li>CallableStatement：用于执行 SQL 存储过程</li>
</ul>
<h2 id="3-2-使用-Statement-操作数据表的弊端"><a href="#3-2-使用-Statement-操作数据表的弊端" class="headerlink" title="3.2 使用 Statement 操作数据表的弊端"></a>3.2 使用 Statement 操作数据表的弊端</h2><p>通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p>
<p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int excuteUpdate(String sql)</td>
<td align="center">执行更新操作 INSERT、UPDATE、DELETE</td>
</tr>
<tr>
<td align="center">ResultSet executeQuery(String sql)</td>
<td align="center">执行查询操作 SELECT</td>
</tr>
</tbody></table>
<p>但是使用 Statement 操作数据表存在弊端：</p>
<ul>
<li><strong>问题一：存在拼串操作，繁琐</strong></li>
<li><strong>问题二：存在 SQL 注入问题</strong><ul>
<li>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。</li>
<li>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</li>
</ul>
</li>
</ul>
<h2 id="3-3-PreparedStatement-的使用"><a href="#3-3-PreparedStatement-的使用" class="headerlink" title="3.3 PreparedStatement 的使用"></a>3.3 PreparedStatement 的使用</h2><h3 id="3-3-1-PreparedStatement-介绍"><a href="#3-3-1-PreparedStatement-介绍" class="headerlink" title="3.3.1 PreparedStatement 介绍"></a>3.3.1 PreparedStatement 介绍</h3><p>可以通过调用 Connection 对象的 <code>preparedStatement(String sql)</code> 方法获取 PreparedStatement 对象</p>
<p><strong>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句。</strong></p>
<blockquote>
<p>An object that represents a precompiled SQL statement. </p>
</blockquote>
<p>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值。</p>
<h3 id="3-3-2-PreparedStatement-vs-Statement"><a href="#3-3-2-PreparedStatement-vs-Statement" class="headerlink" title="3.3.2 PreparedStatement vs Statement"></a>3.3.2 PreparedStatement vs Statement</h3><p>PreparedStatement 能最大可能提高性能：</p>
<ul>
<li>DBServer 会对<strong>预编译</strong>语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u></li>
<li>在 Statement 语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u></li>
<li>(语法检查，语义检查，翻译成二进制命令，缓存)</li>
</ul>
<p>PreparedStatement 可以防止 SQL 注入。</p>
<h3 id="3-3-3-Java-与-SQL-对应数据类型转换表"><a href="#3-3-3-Java-与-SQL-对应数据类型转换表" class="headerlink" title="3.3.3 Java 与 SQL 对应数据类型转换表"></a>3.3.3 Java 与 SQL 对应数据类型转换表</h3><table>
<thead>
<tr>
<th align="center">Java 类型</th>
<th align="center">SQL 类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">BIT</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">TINYINT</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">SMALLINT</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">INTEGER</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">BIGINT</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">CHAR,VARCHAR,LONGVARCHAR</td>
</tr>
<tr>
<td align="center">byte   array</td>
<td align="center">BINARY, VAR BINARY</td>
</tr>
<tr>
<td align="center">java.sql.Date</td>
<td align="center">DATE</td>
</tr>
<tr>
<td align="center">java.sql.Time</td>
<td align="center">TIME</td>
</tr>
<tr>
<td align="center">java.sql.Timestamp</td>
<td align="center">TIMESTAMP</td>
</tr>
</tbody></table>
<h3 id="3-3-4-使用-PreparedStatement-实现增、删、改操作"><a href="#3-3-4-使用-PreparedStatement-实现增、删、改操作" class="headerlink" title="3.3.4 使用 PreparedStatement 实现增、删、改操作"></a>3.3.4 使用 PreparedStatement 实现增、删、改操作</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 通用的增删改操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String sql, Object ... args)</span> </span>{ </span><br><span class="line"></span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//1.获取数据库的连接</span></span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.预编译sql语句，返回PreparedStatement的实例</span></span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.填充占位符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) {</span><br><span class="line">            ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.执行</span></span><br><span class="line">        ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">//5.资源的关闭</span></span><br><span class="line">        JDBCUtils.closeResourse(conn, ps);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h3 id="3-3-5-使用-PreparedStatement-实现查询操作"><a href="#3-3-5-使用-PreparedStatement-实现查询操作" class="headerlink" title="3.3.5 使用 PreparedStatement 实现查询操作"></a>3.3.5 使用 PreparedStatement 实现查询操作</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 针对于不同的表的通用的查询操作，返回表中的一条记录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; cls, String sql, Object ... args)</span> </span>{</span><br><span class="line"></span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.获取数据库的连接</span></span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.预编译sql语句，返回PreparedStatement的实例</span></span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.填充占位符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) {</span><br><span class="line">            ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.执行,并返回结果集</span></span><br><span class="line">        rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.处理结果集</span></span><br><span class="line"></span><br><span class="line">        ResultSetMetaData metaData = rs.getMetaData();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> columnCount = metaData.getColumnCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rs.next()) {</span><br><span class="line"></span><br><span class="line">            T t = cls.newInstance();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) {</span><br><span class="line"></span><br><span class="line">                Object columValue = rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">                String columnLabel = metaData.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                Field field = cls.getDeclaredField(columnLabel);</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                field.set(t, columValue);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        JDBCUtils.closeResourse(conn, ps, rs);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 针对于不同的表的通用的查询操作，返回记录组成的 List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">getForList</span><span class="params">(Class&lt;T&gt; cls, String sql, Object ... args)</span> </span>{</span><br><span class="line"></span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.获取数据库的连接</span></span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.预编译sql语句，返回PreparedStatement的实例</span></span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.填充占位符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) {</span><br><span class="line">            ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.执行,并返回结果集</span></span><br><span class="line">        rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.处理结果集</span></span><br><span class="line"></span><br><span class="line">        ResultSetMetaData metaData = rs.getMetaData();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> columnCount = metaData.getColumnCount();</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) {</span><br><span class="line"></span><br><span class="line">            T t = cls.newInstance();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) {</span><br><span class="line"></span><br><span class="line">                Object columValue = rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">                String columnLabel = metaData.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                Field field = cls.getDeclaredField(columnLabel);</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                field.set(t, columValue);</span><br><span class="line">            }</span><br><span class="line">            list.add(t);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        JDBCUtils.closeResourse(conn, ps, rs);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="3-4-ResultSet-与-ResultSetMetaData"><a href="#3-4-ResultSet-与-ResultSetMetaData" class="headerlink" title="3.4 ResultSet 与 ResultSetMetaData"></a>3.4 ResultSet 与 ResultSetMetaData</h2><h3 id="3-4-1-ResultSet"><a href="#3-4-1-ResultSet" class="headerlink" title="3.4.1 ResultSet"></a>3.4.1 ResultSet</h3><p>查询需要调用 PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象。</p>
<p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现。</p>
<p>ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。</p>
<p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。</p>
<p>当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。</p>
<ul>
<li>例如: getInt(1), getString(“name”)</li>
<li><strong>注意：Java 与数据库交互涉及到的相关 Java API 中的索引都从1开始。</strong></li>
</ul>
<p>ResultSet 接口的常用方法：</p>
<ul>
<li>boolean next()</li>
<li>getString()</li>
<li>…<br>


</li>
</ul>
<h3 id="3-4-2-ResultSetMetaData"><a href="#3-4-2-ResultSetMetaData" class="headerlink" title="3.4.2 ResultSetMetaData"></a>3.4.2 ResultSetMetaData</h3><p>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象。</p>
<p>ResultSetMetaData rsmd = rs.getMetaData();</p>
<p>ResultSetMetaData 中的部分抽象方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">String <strong>getColumnName</strong>(int column)</td>
<td align="center">获取指定列的名称</td>
</tr>
<tr>
<td align="center">String <strong>getColumnLabel</strong>(int column)</td>
<td align="center">获取指定列的别名</td>
</tr>
<tr>
<td align="center">int <strong>getColumnCount</strong>()</td>
<td align="center">返回当前 ResultSet 对象中的列数</td>
</tr>
<tr>
<td align="center">String getColumnTypeName(int column)</td>
<td align="center">检索指定列的数据库特定的类型名称</td>
</tr>
<tr>
<td align="center">int getColumnDisplaySize(int column)</td>
<td align="center">指示指定列的最大标准宽度，以字符为单位</td>
</tr>
<tr>
<td align="center">int <strong>isNullable</strong>(int column)</td>
<td align="center">指示指定列中的值是否可以为 null</td>
</tr>
<tr>
<td align="center">boolean isAutoIncrement(int column)</td>
<td align="center">指示是否自动为指定列进行编号，这样这些列仍然是只读的</td>
</tr>
</tbody></table>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/JDBC/ResultSetMetaData.png" width=""> </div><br>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/JDBC/step.png
" width=""> </div>



<h2 id="3-5-资源的释放"><a href="#3-5-资源的释放" class="headerlink" title="3.5 资源的释放"></a>3.5 资源的释放</h2><ul>
<li>释放 ResultSet, Statement,Connection。</li>
<li>数据库连接（Connection）用完后必须马上释放，如果 Connection 不能及时正确的关闭将导致系统宕机。Connection 的使用原则是<strong>尽量晚创建，尽量早的释放。</strong></li>
<li>可以在 finally 中关闭，保证及时其他代码出现异常，资源也一定能被关闭。</li>
</ul>
<h2 id="3-6-小结"><a href="#3-6-小结" class="headerlink" title="3.6 小结"></a>3.6 小结</h2><p>两种思想</p>
<ul>
<li><p>面向接口编程的思想</p>
</li>
<li><p>ORM 思想(object relational mapping)</p>
<ul>
<li>一个数据表对应一个 Java 类</li>
<li>表中的一条记录对应 Java 类的一个对象</li>
<li>表中的一个字段对应 Java 类的一个属性</li>
</ul>
<blockquote>
<p>sql 是需要结合列名和表的属性名来写。注意起别名。</p>
</blockquote>
</li>
</ul>
<p>两种技术</p>
<ul>
<li>JDBC结果集的元数据：ResultSetMetaData<ul>
<li>获取列数：getColumnCount()</li>
<li>获取列的别名：getColumnLabel()</li>
</ul>
</li>
<li>通过反射，创建指定类的对象，获取指定的属性并赋值</li>
</ul>
<hr>
<h1 id="4-操作-BLOB-类型字段"><a href="#4-操作-BLOB-类型字段" class="headerlink" title="4. 操作 BLOB 类型字段"></a>4. 操作 BLOB 类型字段</h1><h2 id="4-1-MySQL-BLOB-类型"><a href="#4-1-MySQL-BLOB-类型" class="headerlink" title="4.1 MySQL BLOB 类型"></a>4.1 MySQL BLOB 类型</h2><p>MySQL中，BLOB 是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。插入BLOB类型的数据必须使用 PreparedStatement，因为 BLOB 类型的数据无法使用字符串拼接写的。</p>
<p>MySQL 的四种 BLOB 类型(除了在存储的最大信息量上不同外，他们是等同的):</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">大小(单位:字节)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TinyBlob</td>
<td align="center">最大 255</td>
</tr>
<tr>
<td align="center">Blob</td>
<td align="center">最大 65K</td>
</tr>
<tr>
<td align="center">MediumBlob</td>
<td align="center">最大 16M</td>
</tr>
<tr>
<td align="center">LongBlob</td>
<td align="center">最大 4G</td>
</tr>
</tbody></table>
<p>实际使用中根据需要存入的数据大小定义不同的 BLOB 类型。如果存储的文件过大，数据库的性能会下降。</p>
<p>如果在指定了相关的 Blob 类型以后，还报错：xxx too large，那么在 MySQL 的安装目录下，找 my.ini 文件加上如下的配置参数： <code>max_allowed_packet=16M</code>。同时注意：修改了my.ini文件之后，需要重新启动 mysql 服务。</p>
<h2 id="4-2-向数据表中插入大数据类型"><a href="#4-2-向数据表中插入大数据类型" class="headerlink" title="4.2 向数据表中插入大数据类型"></a>4.2 向数据表中插入大数据类型</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 向数据表 customers 中插入 Blob 类型的字段</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">    BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">"INSERT INTO customers (cust_name, cust_address, cust_city, cust_photo) VALUES (?, ?, ?, ?)"</span>;</span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 填充占位符</span></span><br><span class="line">        ps.setObject(<span class="number">1</span>, <span class="string">"E Fudd"</span>);</span><br><span class="line">        ps.setObject(<span class="number">2</span>, <span class="string">"4545 53rd Street"</span>);</span><br><span class="line">        ps.setObject(<span class="number">3</span>, <span class="string">"Chicago"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 操作 Blob 类型变量</span></span><br><span class="line">        FileInputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"Fudd.jpg"</span>));</span><br><span class="line">        bis = <span class="keyword">new</span> BufferedInputStream(is);</span><br><span class="line">        ps.setBlob(<span class="number">4</span>, bis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        ps.executeUpdate();</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (bis != <span class="keyword">null</span>) {</span><br><span class="line">                bis.close();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        JDBCUtils.closeResourse(conn, ps);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="4-3-从数据表中查询大数据类型"><a href="#4-3-从数据表中查询大数据类型" class="headerlink" title="4.3 从数据表中查询大数据类型"></a>4.3 从数据表中查询大数据类型</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//查询数据表 customers 中 Blob 类型的字段</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">    InputStream is = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream os = <span class="keyword">null</span>;</span><br><span class="line">    BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">    BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        String sql = <span class="string">"SELECT cust_id, cust_name, cust_address, cust_city, cust_photo FROM customers WHERE id = ?"</span>;</span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        ps.setObject(<span class="number">1</span>, <span class="number">10001</span>);</span><br><span class="line"></span><br><span class="line">        rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rs.next()) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> cust_id = rs.getInt(<span class="string">"cust_id"</span>);</span><br><span class="line">            String cust_name = rs.getString(<span class="string">"cust_name"</span>);</span><br><span class="line">            String cust_address = rs.getString(<span class="string">"cust_address"</span>);</span><br><span class="line">            String cust_city = rs.getString(<span class="string">"cust_city"</span>);</span><br><span class="line"></span><br><span class="line">            Customer customer = <span class="keyword">new</span> Customer(cust_id, cust_name, cust_address, cust_city);</span><br><span class="line">            System.out.println(customer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将 Blob 类型的字段下载下来，以文件的方式保存在本地</span></span><br><span class="line">            Blob photo = rs.getBlob(<span class="string">"photo"</span>);</span><br><span class="line">            is = photo.getBinaryStream();</span><br><span class="line">            os = <span class="keyword">new</span> FileOutputStream(<span class="string">"photo.jpg"</span>);</span><br><span class="line"></span><br><span class="line">            bis = <span class="keyword">new</span> BufferedInputStream(is);</span><br><span class="line">            bos = <span class="keyword">new</span> BufferedOutputStream(os);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ( (len = bis.read(buffer)) != -<span class="number">1</span> ) {</span><br><span class="line">                bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (bos != <span class="keyword">null</span>) {</span><br><span class="line">                bos.close();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (bis != <span class="keyword">null</span>) {</span><br><span class="line">                bis.close();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        JDBCUtils.closeResourse(conn, ps, rs);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="5-批量操作"><a href="#5-批量操作" class="headerlink" title="5. 批量操作"></a>5. 批量操作</h1><h2 id="5-1-批量执行-SQL-语句"><a href="#5-1-批量执行-SQL-语句" class="headerlink" title="5.1 批量执行 SQL 语句"></a>5.1 批量执行 SQL 语句</h2><p>当需要成批插入或者更新记录时，可以采用 Java 的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理效率更高。</p>
<p>JDBC 的批量处理语句包括下面三个方法：</p>
<ul>
<li><strong>addBatch(String)：添加需要批量处理的SQL语句或是参数；</strong></li>
<li><strong>executeBatch()：执行批量处理语句；</strong></li>
<li><strong>clearBatch():清空缓存的数据</strong></li>
</ul>
<p>通常会遇到两种批量执行SQL语句的情况：</p>
<ul>
<li>多条SQL语句的批量处理；</li>
<li>一个SQL语句的批量传参；</li>
</ul>
<h2 id="5-2-高效的批量插入"><a href="#5-2-高效的批量插入" class="headerlink" title="5.2 高效的批量插入"></a>5.2 高效的批量插入</h2><p>向数据表中插入 1000000 条数据</p>
<ul>
<li>数据库中提供一个 goods 表:</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line"><span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<br>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 批量插入 1000000 条数据</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert3</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置不允许自动提交数据</span></span><br><span class="line">        conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">"INSERT INTO goods(name) VALUES (?)"</span>;</span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++) {</span><br><span class="line">            ps.setObject(<span class="number">1</span>, <span class="string">"name_"</span> + i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1."攒"sql</span></span><br><span class="line">            ps.addBatch();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( i % <span class="number">500</span> == <span class="number">0</span> ) {</span><br><span class="line">                <span class="comment">// 2.执行batch</span></span><br><span class="line">                ps.executeBatch();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.清空batch</span></span><br><span class="line">                ps.clearBatch();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交数据</span></span><br><span class="line">        conn.commit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"时间为："</span> + (endTime - startTime) + <span class="string">" ms."</span>);</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        JDBCUtils.closeResourse(conn, ps);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="6-数据库事务"><a href="#6-数据库事务" class="headerlink" title="6. 数据库事务"></a>6. 数据库事务</h1><h2 id="6-1-数据库事务介绍"><a href="#6-1-数据库事务介绍" class="headerlink" title="6.1 数据库事务介绍"></a>6.1 数据库事务介绍</h2><p><strong>事务</strong>：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</p>
<p><strong>事务处理（事务操作）：</strong> 保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被 <strong>提交(commit)</strong>，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务 <strong>回滚(rollback)</strong> 到最初状态。</p>
<p>为确保数据库中数据的 <strong>一致性</strong>，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 </p>
<h2 id="6-2-JDBC-事务处理"><a href="#6-2-JDBC-事务处理" class="headerlink" title="6.2 JDBC 事务处理"></a>6.2 JDBC 事务处理</h2><p>数据一旦提交，就不可回滚。</p>
<p>数据什么时候意味着提交？</p>
<ul>
<li><strong>当一个连接对象被创建时，默认情况下是自动提交事务</strong>：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li>
<li><strong>关闭数据库连接，数据就会自动的提交。</strong> 如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li>
</ul>
<p>JDBC 程序中为了让多个 SQL 语句作为一个事务执行：</p>
<ul>
<li>调用 Connection 对象的 <strong>setAutoCommit(false);</strong> 以取消自动提交事务</li>
<li>在所有的 SQL 语句都成功执行后，调用 <strong>commit();</strong> 方法提交事务</li>
<li>在出现异常时，调用 <strong>rollback();</strong> 方法回滚事务</li>
</ul>
<blockquote>
<p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行 close() 方法前，建议恢复自动提交状态。</p>
</blockquote>
<p>【案例：用户 AA 向用户 BB 转账100】</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJDBCTransaction</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.获取数据库连接</span></span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.开启事务</span></span><br><span class="line">        conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.进行数据库操作</span></span><br><span class="line">        String sql1 = <span class="string">"UPDATE user_table SET balance = balance - 100 WHERE user = ?"</span>;</span><br><span class="line">        update(conn, sql1, <span class="string">"AA"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟网络异常</span></span><br><span class="line">        <span class="comment">//System.out.println(10 / 0);</span></span><br><span class="line"></span><br><span class="line">        String sql2 = <span class="string">"UPDATE user_table SET balance = balance + 100 WHERE user = ?"</span>;</span><br><span class="line">        update(conn, sql2, <span class="string">"BB"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.若没有异常，则提交事务</span></span><br><span class="line">        conn.commit();</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.若有异常，则回滚事务</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            conn.rollback();</span><br><span class="line">        } <span class="keyword">catch</span> (SQLException e1) {</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 6.恢复每次DML操作的自动提交功能</span></span><br><span class="line">            conn.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 7.关闭连接</span></span><br><span class="line">        JDBCUtils.closeResource(conn, <span class="keyword">null</span>, <span class="keyword">null</span>); </span><br><span class="line">    }  </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中，对数据库操作的方法为：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 通用的增删改操作---version 2.0(考虑事务)</span></span><br><span class="line"><span class="comment">// 从外部传入 Connection 连接，避免自动关闭连接导致 commit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Connection conn, String sql, Object ... args)</span> </span>{</span><br><span class="line"></span><br><span class="line">    PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.预编译sql语句，返回PreparedStatement的实例</span></span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.填充占位符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) {</span><br><span class="line">            ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.执行</span></span><br><span class="line">        <span class="keyword">return</span> ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 4.关闭资源</span></span><br><span class="line">        JDBCUtils.closeResourse(<span class="keyword">null</span>, ps);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="6-3-事务的-ACID-属性"><a href="#6-3-事务的-ACID-属性" class="headerlink" title="6.3 事务的 ACID 属性"></a>6.3 事务的 ACID 属性</h2><ol>
<li><p><strong>原子性（Atomicity）</strong><br> 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </p>
</li>
<li><p><strong>一致性（Consistency）</strong><br> 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p>
</li>
<li><p><strong>隔离性（Isolation）</strong><br> 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</li>
<li><p><strong>持久性（Durability）</strong><br> 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
</li>
</ol>
<h3 id="6-3-1-数据库的并发问题"><a href="#6-3-1-数据库的并发问题" class="headerlink" title="6.3.1 数据库的并发问题"></a>6.3.1 数据库的并发问题</h3><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>
<ul>
<li><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li>
<li><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</li>
<li><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li>
</ul>
<p><strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p>
<p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高, 数据一致性就越好, 但并发性越弱。</strong></p>
<h3 id="6-3-2-四种隔离级别"><a href="#6-3-2-四种隔离级别" class="headerlink" title="6.3.2 四种隔离级别"></a>6.3.2 四种隔离级别</h3><p>数据库提供的 4 种事务隔离级别：</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/JDBC/isolation.png" width=""> </div>

<p>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</p>
<p>MySQL 支持 4 种事务隔离级别。MySQL 默认的事务隔离级别为: <strong>REPEATABLE READ。</strong></p>
<h3 id="6-3-3-在-MySQL-中设置隔离级别"><a href="#6-3-3-在-MySQL-中设置隔离级别" class="headerlink" title="6.3.3 在 MySQL 中设置隔离级别"></a>6.3.3 在 MySQL 中设置隔离级别</h3><p>每启动一个 MySQL 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。</p>
<ul>
<li><p>查看当前的隔离级别: </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>设置当前 MySQL 连接的隔离级别:  </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SET  transaction isolation level read committed;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>设置数据库系统的全局的隔离级别:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SET global transaction isolation level read committed;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>补充操作：</p>
<ul>
<li><p>创建 MySQL 数据库用户：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">create user tom identified by 'abc123';</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>授予权限</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#授予通过网络方式登录的 Jeremy 用户，对所有库所有表的全部权限，密码设为abc123.</span><br><span class="line">grant all privileges on *.* to Jeremy@'%'  identified by 'abc123'; </span><br><span class="line"></span><br><span class="line"> #给 Jeremy 用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</span><br><span class="line">grant select,insert,delete,update on atguigudb.* to Jeremy@localhost identified by 'abc123';</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="7-DAO-及相关实现类"><a href="#7-DAO-及相关实现类" class="headerlink" title="7. DAO 及相关实现类"></a>7. DAO 及相关实现类</h1><p>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO。</p>
<p>作用：为了实现功能的模块化，更有利于代码的维护和升级。</p>
<p>customers 表的字段</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/JDBC/customes.png" width=""> </div>



<p>层次结构：</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/JDBC/DAO.png" width=""> </div>

<p><strong>【BaseDAO.java】</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span>: BaseDAO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 封装了针对于数据表的通用的操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020-04-06 22:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDAO</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; cls = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 获取当前 BaseDAO 的子类继承的父类中的泛型</span></span><br><span class="line"></span><br><span class="line">        Type genericSuperclass = <span class="keyword">this</span>.getClass().getGenericSuperclass();</span><br><span class="line">        ParameterizedType paramType = (ParameterizedType) genericSuperclass;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取父类的泛型参数</span></span><br><span class="line">        Type[] typeArguments = paramType.getActualTypeArguments();</span><br><span class="line">        <span class="comment">// 泛型的第一个参数</span></span><br><span class="line">        cls = (Class&lt;T&gt;) typeArguments[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用的增删改操作---version 2.0(考虑事务)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: conn</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: sql</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: int</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Song Ningning</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020-04-06 22:42</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Connection conn, String sql, Object ... args)</span> </span>{  <span class="comment">// sql 中占位符的个数与可变形参的长度相同</span></span><br><span class="line"></span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.预编译sql语句，返回PreparedStatement的实例</span></span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.填充占位符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) {</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.执行</span></span><br><span class="line">            <span class="keyword">return</span> ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 4.资源的关闭</span></span><br><span class="line">            JDBCUtils.closeResourse(<span class="keyword">null</span>, ps);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对于不同的表的通用的查询操作，返回表中的一条记录（version 2.0：考虑事务）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: conn</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: cls</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: sql</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: T</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Song Ningning</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020-04-06 22:01</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getInstance</span><span class="params">(Connection conn, String sql, Object ... args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.预编译sql语句，返回PreparedStatement的实例</span></span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.填充占位符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) {</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.执行,并返回结果集</span></span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.处理结果集</span></span><br><span class="line"></span><br><span class="line">            ResultSetMetaData metaData = rs.getMetaData();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> columnCount = metaData.getColumnCount();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rs.next()) {</span><br><span class="line"></span><br><span class="line">                T t = cls.newInstance();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) {</span><br><span class="line"></span><br><span class="line">                    Object columValue = rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">                    String columnLabel = metaData.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                    Field field = cls.getDeclaredField(columnLabel);</span><br><span class="line">                    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    field.set(t, columValue);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 5.关闭资源</span></span><br><span class="line">            JDBCUtils.closeResourse(<span class="keyword">null</span>, ps, rs);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对于不同的表的通用的查询操作，返回记录组成的 List（version 2.0：考虑事务）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: cls</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: sql</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: java.util.List&lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Song Ningning</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020-04-06 10:59</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getForList</span><span class="params">(Connection conn, String sql, Object ... args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 1.预编译 sql 语句，返回 PreparedStatement 的实例</span></span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.填充占位符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) {</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.执行,并返回结果集</span></span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.处理结果集</span></span><br><span class="line"></span><br><span class="line">            ResultSetMetaData metaData = rs.getMetaData();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> columnCount = metaData.getColumnCount();</span><br><span class="line"></span><br><span class="line">            ArrayList&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) {</span><br><span class="line"></span><br><span class="line">                T t = cls.newInstance();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) {</span><br><span class="line"></span><br><span class="line">                    Object columValue = rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">                    String columnLabel = metaData.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                    Field field = cls.getDeclaredField(columnLabel);</span><br><span class="line">                    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    field.set(t, columValue);</span><br><span class="line">                }</span><br><span class="line">                list.add(t);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 5.关闭资源</span></span><br><span class="line">            JDBCUtils.closeResourse(<span class="keyword">null</span>, ps, rs);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于查询特殊值的通用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: conn</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: sql</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: E</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Song Ningning</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020-04-07 9:22</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">getValue</span><span class="params">(Connection conn, String sql, Object ... args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) {</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            ResultSet rs = ps.executeQuery();</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) {</span><br><span class="line">                <span class="keyword">return</span> (E) rs.getObject(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            JDBCUtils.closeResourse(<span class="keyword">null</span>, ps);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>【CustomerDAO.java】</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于规范针对于 customers 表的常用操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span>: CustomerDAO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020-04-07 9:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerDAO</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将cust对象添加到数据库中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: conn</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: cust</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Song Ningning</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020-04-07 9:31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Connection conn, Customer cust)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对指定的 id，删除表中的一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: conn</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Song Ningning</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020-04-07 9:40</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Connection conn, <span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对内存中的cust对象，去修改数据表中指定的记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: conn</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: cust</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Song Ningning</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020-04-07 9:38</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Connection conn, Customer cust)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对指定的id查询得到对应的Customer对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: conn</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: Customers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Song Ningning</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020-04-07 9:37</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Customer <span class="title">getCustomerById</span><span class="params">(Connection conn, <span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询表中的所有记录构成的集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: conn</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: List&lt;Customers&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Song Ningning</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020-04-07 9:37</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Customer&gt; <span class="title">getAll</span><span class="params">(Connection conn)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回数据表中数据的条目数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: conn</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: Long</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Song Ningning</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020-04-07 9:36</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">getCount</span><span class="params">(Connection conn)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回数据表中最大的生日</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: conn</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: Date</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Song Ningning</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020-04-07 9:36</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Date <span class="title">getMaxBirth</span><span class="params">(Connection conn)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>【CustomerDAOImpl.java】</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span>: CustomerDAOImpl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Song Ningning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020-04-07 9:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerDAOImpl</span> <span class="keyword">extends</span> <span class="title">BaseDAO</span>&lt;<span class="title">Customer</span>&gt; <span class="keyword">implements</span> <span class="title">CustomerDAO</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Connection conn, Customer cust)</span> </span>{</span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">"INSERT INTO customers (name, email, birth) VALUES (?, ?, ?)"</span>;</span><br><span class="line">        update(conn, sql, cust.getName(), cust.getEmail(), cust.getBirth());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Connection conn, <span class="keyword">int</span> id)</span> </span>{</span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">"DELETE FROM customers WHERE id = ?"</span>;</span><br><span class="line">        update(conn, sql,id);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Connection conn, Customer cust)</span> </span>{</span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">"UPDATE customers SET name = ?, email = ?, birth = ? WHERE id = ?"</span>;</span><br><span class="line">        update(conn, sql, cust.getName(), cust.getEmail(), cust.getBirth(), cust.getId());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Customer <span class="title">getCustomerById</span><span class="params">(Connection conn, <span class="keyword">int</span> id)</span> </span>{</span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">"SELECT id, name, email, birth FROM customers WHERE id = ?"</span>;</span><br><span class="line">        <span class="keyword">return</span> getInstance(conn, sql, id);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Customer&gt; <span class="title">getAll</span><span class="params">(Connection conn)</span> </span>{</span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">"SELECT id, name, email, birth FROM customers"</span>;</span><br><span class="line">        <span class="keyword">return</span> getForList(conn, sql);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getCount</span><span class="params">(Connection conn)</span> </span>{</span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">"SELECT COUNT(*) FROM customers"</span>;</span><br><span class="line">        <span class="keyword">return</span> getValue(conn, sql);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getMaxBirth</span><span class="params">(Connection conn)</span> </span>{</span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">"SELECT MAX(birth) FROM customers"</span>;</span><br><span class="line">        <span class="keyword">return</span> getValue(conn, sql);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="8-数据库连接池"><a href="#8-数据库连接池" class="headerlink" title="8. 数据库连接池"></a>8. 数据库连接池</h1><h2 id="8-1-JDBC-数据库连接池的必要性"><a href="#8-1-JDBC-数据库连接池的必要性" class="headerlink" title="8.1 JDBC 数据库连接池的必要性"></a>8.1 JDBC 数据库连接池的必要性</h2><p>在使用开发基于数据库的 web 程序时，传统的模式基本是按以下步骤：　　</p>
<ul>
<li><strong>在主程序（如servlet、beans）中建立数据库连接</strong></li>
<li><strong>进行 sql 操作</strong></li>
<li><strong>断开数据库连接</strong></li>
</ul>
<p>这种模式开发，存在的问题:</p>
<ul>
<li>普通的 JDBC 数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。 <strong>数据库的连接资源并没有得到很好的重复利用。</strong> 若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li>
<li><strong>对于每一次数据库连接，使用完后都得断开。</strong> 否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。</li>
<li><strong>这种开发不能控制被创建的连接对象数</strong>，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 </li>
</ul>
<h2 id="8-2-数据库连接池技术"><a href="#8-2-数据库连接池技术" class="headerlink" title="8.2 数据库连接池技术"></a>8.2 数据库连接池技术</h2><p>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</p>
<ul>
<li><p><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</p>
</li>
<li><p><strong>数据库连接池</strong>负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。</p>
</li>
<li><p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<strong>最小数据库连接数来设定</strong>的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的<strong>最大数据库连接数量</strong>限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p>
</li>
</ul>
<p><strong>数据库连接池技术的优点:</strong></p>
<ul>
<li><p><strong>资源重用</strong></p>
<p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p>
</li>
<li><p><strong>更快的系统反应速度</strong></p>
<p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p>
</li>
<li><p><strong>新的资源分配手段</strong></p>
<p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p>
</li>
<li><p><strong>统一的连接管理，避免数据库连接泄漏</strong></p>
<p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p>
</li>
</ul>
<h2 id="8-3-多种开源的数据库连接池"><a href="#8-3-多种开源的数据库连接池" class="headerlink" title="8.3 多种开源的数据库连接池"></a>8.3 多种开源的数据库连接池</h2><p>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：</p>
<ul>
<li><strong>DBCP</strong> 是Apache提供的数据库连接池。Tomcat 服务器自带dbcp数据库连接池。<strong>速度相对 c3p0 较快</strong>，但因自身存在BUG，Hibernate3已不再提供支持。</li>
<li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，<strong>速度相对较慢，稳定性还可以。</strong>hibernate官方推荐使用。</li>
<li><strong>Proxool</strong> 是 SourceForge下 的一个开源项目数据库连接池，有监控连接池状态的功能，<strong>稳定性较 c3p0 差一点</strong></li>
<li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快。</li>
<li><strong>Druid</strong> 是阿里提供的数据库连接池，监控做的很好。</li>
</ul>
<p>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池。<br><strong>DataSource 用来取代 DriverManager 来获取 Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></p>
<p>目前使用较多的是 Druid。</p>
<p>注意：</p>
<ul>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此<strong>整个应用只需要一个数据源即可。</strong></li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但 conn.close() 并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
</ul>
<h3 id="8-3-1-C3P0-数据库连接池"><a href="#8-3-1-C3P0-数据库连接池" class="headerlink" title="8.3.1 C3P0 数据库连接池"></a>8.3.1 C3P0 数据库连接池</h3><ul>
<li>获取连接方式一</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：硬编码，不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">testGetConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 c3p0 数据库连接池</span></span><br><span class="line">    ComboPooledDataSource cpds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">    cpds.setDriverClass( <span class="string">"com.mysql.jdbc.Driver"</span> );</span><br><span class="line">    cpds.setJdbcUrl( <span class="string">"jdbc:mysql://localhost:3306/test"</span> );</span><br><span class="line">    cpds.setUser(<span class="string">"root"</span>);</span><br><span class="line">    cpds.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过设置相关的参数，对数据库连接池进行管理：</span></span><br><span class="line">    <span class="comment">// 设置初始时数据库连接池中的连接数</span></span><br><span class="line">    cpds.setInitialPoolSize(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    Connection conn = cpds.getConnection();</span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>获取连接方式二</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 方式二：推荐使用配置文件</span></span><br><span class="line">ComboPooledDataSource cpds = <span class="keyword">new</span> ComboPooledDataSource(<span class="string">"c3p0"</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">testGetConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    Connection conn = cpds.getConnection();</span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中，src 下的配置文件为：【c3p0-config.xml】</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">"c3p0"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 提供获取连接的 4 个基本信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 进行数据库连接池管理的基本信息 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当数据库连接池中的连接数不够时，c3p0 一次性向数据库服务器申请的连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireIncrement"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- c3p0 数据库连接池中初始化时的连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- c3p0 数据库连接池维护的最少连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- c3p0 数据库连接池维护的最多的连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- c3p0 数据库连接池最多维护的 Statement 的个数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatements"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 每个连接中可以最多使用的 Statement 的个数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatementsPerConnection"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>


<h3 id="8-3-2-DBCP-数据库连接池"><a href="#8-3-2-DBCP-数据库连接池" class="headerlink" title="8.3.2 DBCP 数据库连接池"></a>8.3.2 DBCP 数据库连接池</h3><ul>
<li>DBCP 是 Apache 下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<ul>
<li>Commons-dbcp.jar：连接池的实现</li>
<li>Commons-pool.jar：连接池实现的依赖库</li>
</ul>
</li>
<li><strong>Tomcat 的连接池正是采用该连接池来实现的。</strong> 该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
</ul>
<ul>
<li>获取连接方式一：</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：硬编码不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">testGetConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建了DBCP的数据库连接池</span></span><br><span class="line">	BasicDataSource source = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置基本信息</span></span><br><span class="line">	source.setDriverClassName( <span class="string">"com.mysql.jdbc.Driver"</span> );</span><br><span class="line">	source.setUrl( <span class="string">"jdbc:mysql://localhost:3306/test"</span> );</span><br><span class="line">	source.setUsername( <span class="string">"root"</span> );</span><br><span class="line">	source.setPassword( <span class="string">"admin"</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 还可以设置其他涉及数据库连接池管理的相关属性：</span></span><br><span class="line">	source.setInitialSize(<span class="number">10</span>);</span><br><span class="line">	source.setMaxActive(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	Connection conn = source.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>获取连接方式二：</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 dbcp 数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource source = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">        </span><br><span class="line">        InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">"dbcp.properties"</span>);</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(is);</span><br><span class="line">        </span><br><span class="line">        pros.load(bis);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据提供的BasicDataSourceFactory创建对应的DataSource对象</span></span><br><span class="line">        source = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">        </span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection6</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    Connection conn = source.getConnection();</span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>其中，src 下的配置文件为：【dbcp.properties】</p>
<figure class="highlight properties"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">admin</span></span><br><span class="line"></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="8-3-3-Druid（德鲁伊）数据库连接池"><a href="#8-3-3-Druid（德鲁伊）数据库连接池" class="headerlink" title="8.3.3 Druid（德鲁伊）数据库连接池"></a>8.3.3 Druid（德鲁伊）数据库连接池</h3><p>Druid 是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">    InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">"druid.properties"</span>);</span><br><span class="line">    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(is);</span><br><span class="line"></span><br><span class="line">    Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">    pros.load(bis);</span><br><span class="line"></span><br><span class="line">    DataSource source = DruidDataSourceFactory.createDataSource(pros);</span><br><span class="line">    Connection conn = source.getConnection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中，src下的配置文件为：【druid.properties】</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test</span></span><br><span class="line">username=root</span><br><span class="line">password=admin</span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line"># 根据需要设置参数</span><br><span class="line">initialSize=<span class="number">10</span></span><br><span class="line">maxActive=<span class="number">10</span></span><br><span class="line">#...</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="9-Apache-DBUtils-实现-CRUD-操作"><a href="#9-Apache-DBUtils-实现-CRUD-操作" class="headerlink" title="9. Apache-DBUtils 实现 CRUD 操作"></a>9. Apache-DBUtils 实现 CRUD 操作</h1><h2 id="9-1-Apache-DBUtils-简介"><a href="#9-1-Apache-DBUtils-简介" class="headerlink" title="9.1 Apache-DBUtils 简介"></a>9.1 Apache-DBUtils 简介</h2><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p>
<p>API介绍：</p>
<ul>
<li>org.apache.commons.dbutils.QueryRunner</li>
<li>org.apache.commons.dbutils.ResultSetHandler</li>
<li>工具类：org.apache.commons.dbutils.DbUtils   </li>
</ul>
<h2 id="9-2-主要-API-的使用"><a href="#9-2-主要-API-的使用" class="headerlink" title="9.2 主要 API 的使用"></a>9.2 主要 API 的使用</h2><h3 id="9-2-1-DbUtils"><a href="#9-2-1-DbUtils" class="headerlink" title="9.2.1 DbUtils"></a>9.2.1 DbUtils</h3><p>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：</p>
<ul>
<li><strong>public static void close(…) throws java.sql.SQLException</strong>：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li>
<li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li>
<li>public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接</li>
<li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 </li>
<li>public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断</li>
<li>public static void rollbackAndClose(Connection conn)throws SQLException</li>
<li>rollbackAndCloseQuietly(Connection)</li>
<li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li>
</ul>
<h3 id="9-2-2-QueryRunner-类"><a href="#9-2-2-QueryRunner-类" class="headerlink" title="9.2.2 QueryRunner 类"></a>9.2.2 QueryRunner 类</h3><p>该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</p>
<p>QueryRunner类提供了两个构造器：</p>
<ul>
<li>默认的构造器</li>
<li>需要一个 javax.sql.DataSource 来作参数的构造器</li>
</ul>
<p>QueryRunner类的主要方法：</p>
<ul>
<li><strong>更新</strong><ul>
<li>public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li>
<li>……</li>
</ul>
</li>
<li><strong>插入</strong><ul>
<li>public <t> T insert(Connection conn,String sql,ResultSetHandler<t> rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值<ul>
<li>….</li>
</ul>
</t></t></li>
</ul>
</li>
<li><strong>批处理</strong><ul>
<li>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句</li>
<li>public <t> T insertBatch(Connection conn,String sql,ResultSetHandler<t> rsh,Object[][] params)throws SQLException：只支持INSERT语句</t></t></li>
<li>…..</li>
</ul>
</li>
<li><strong>查询</strong><ul>
<li>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。<ul>
<li>…… </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>测试</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 测试添加</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        conn = JDBCUtils.getConnection3();</span><br><span class="line">        String sql = <span class="string">"INSERT INTO customers(name, email, birth) VALUES (?,?,?)"</span>;</span><br><span class="line"></span><br><span class="line">        QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        <span class="keyword">int</span> insertCount = runner.update(conn, sql, <span class="string">"Jerry"</span>, <span class="string">"jerry@sina.com"</span>, <span class="string">"2002-06-01"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"添加了 "</span> + insertCount + <span class="string">" 条记录"</span>);</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        JDBCUtils.closeResourse(conn, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h3 id="9-2-3-ResultSetHandler-接口及实现类"><a href="#9-2-3-ResultSetHandler-接口及实现类" class="headerlink" title="9.2.3 ResultSetHandler 接口及实现类"></a>9.2.3 ResultSetHandler 接口及实现类</h3><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</p>
<p>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。</p>
<p>接口的主要实现类：</p>
<table>
<thead>
<tr>
<th align="center">实现类</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ArrayHandler</td>
<td align="center">把结果集中的第一行数据转成对象数组</td>
</tr>
<tr>
<td align="center">ArrayListHandler</td>
<td align="center">把结果集中的每一行数据都转成一个数组，再存放到List中</td>
</tr>
<tr>
<td align="center"><strong>BeanHandler</strong></td>
<td align="center">将结果集中的第一行数据封装到一个对应的JavaBean实例中</td>
</tr>
<tr>
<td align="center"><strong>BeanListHandler</strong></td>
<td align="center">将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里</td>
</tr>
<tr>
<td align="center">ColumnListHandler</td>
<td align="center">将结果集中某一列的数据存放到List中</td>
</tr>
<tr>
<td align="center">KeyedHandler(name)</td>
<td align="center">将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key</td>
</tr>
<tr>
<td align="center"><strong>MapHandler</strong></td>
<td align="center">将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值</td>
</tr>
<tr>
<td align="center"><strong>MapListHandler：</strong></td>
<td align="center">将结果集中的每一行数据都封装到一个Map里，然后再存放到List</td>
</tr>
<tr>
<td align="center"><strong>ScalarHandler：</strong></td>
<td align="center">查询单个值对象</td>
</tr>
</tbody></table>
<p>测试</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用 ResultSetHandler 的实现类：BeanHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testQuery1</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">"SELECT id, name, email, birth FROM customers WHERE id = ?"</span>;</span><br><span class="line">        BeanHandler&lt;Customer&gt; handler = <span class="keyword">new</span> BeanHandler&lt;&gt;(Customer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Customer customer = runner.query(conn, sql, handler, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(customer);</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        JDBCUtils.closeResourse(conn, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询多条记录构成的 List</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用 ResultSetHandler 的实现类：BeanListHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testQuery2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line"></span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">"SELECT id, name, email, birth FROM customers WHERE id &lt; ?"</span>;</span><br><span class="line">        BeanListHandler&lt;Customer&gt; handler = <span class="keyword">new</span> BeanListHandler&lt;&gt;(Customer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        List&lt;Customer&gt; customers = runner.query(conn, sql, handler, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        customers.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        JDBCUtils.closeResourse(conn, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询一条记录</span></span><br><span class="line"><span class="comment"> * 使用 ResultSetHandler 的实现类：MapHander</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testQuery3</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">"SELECT id, name, email, birth FROM customers WHERE id = ?"</span>;</span><br><span class="line">        MapHandler handler = <span class="keyword">new</span> MapHandler();</span><br><span class="line">        Map&lt;String, Object&gt; map = runner.query(conn, sql, handler, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        JDBCUtils.closeResourse(conn, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询条记录构成的 Map</span></span><br><span class="line"><span class="comment"> * 使用 ResultSetHandler 的实现类：MapListHander</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testQuery4</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">"SELECT id, name, email, birth FROM customers WHERE id &lt; ?"</span>;</span><br><span class="line">        MapListHandler handler = <span class="keyword">new</span> MapListHandler();</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = runner.query(conn, sql, handler, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        JDBCUtils.closeResourse(conn, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自定义 ResultSetHandler 的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testQuery5</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">"SELECT id, name, email, birth FROM customers WHERE id = ?"</span>;</span><br><span class="line"></span><br><span class="line">        ResultSetHandler&lt;Customer&gt; handler = <span class="keyword">new</span> ResultSetHandler&lt;Customer&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Customer <span class="title">handle</span><span class="params">(ResultSet resultSet)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (resultSet.next()) {</span><br><span class="line">                    <span class="keyword">int</span> id = resultSet.getInt(<span class="string">"id"</span>);</span><br><span class="line">                    String name = resultSet.getString(<span class="string">"name"</span>);</span><br><span class="line">                    String email = resultSet.getString(<span class="string">"email"</span>);</span><br><span class="line">                    java.sql.Date birth = resultSet.getDate(<span class="string">"birth"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Customer(id, name, email, birth);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        Customer customer = (Customer) runner.query(conn, sql, handler, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(customer);</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        JDBCUtils.closeResourse(conn, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据，</span></span><br><span class="line"><span class="comment"> * 使用 ScalarHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testQuery6</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">"SELECT MAX(birth) FROM customers"</span>;</span><br><span class="line">        ScalarHandler handler = <span class="keyword">new</span> ScalarHandler();</span><br><span class="line">        Date maxBirth = (Date) runner.query(conn, sql, handler);</span><br><span class="line"></span><br><span class="line">        System.out.println(maxBirth);</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        JDBCUtils.closeResourse(conn, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>Java</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工具使用技巧、问题</title>
    <url>/posts/f0688a92/</url>
    <content><![CDATA[<p>记录一些软件工具使用技巧、问题。</p>
<a id="more"></a>

<h1 id="1-GitHub-仓库-HTTPS-和-SSH-通道的切换"><a href="#1-GitHub-仓库-HTTPS-和-SSH-通道的切换" class="headerlink" title="1. GitHub 仓库 HTTPS 和 SSH 通道的切换"></a>1. GitHub 仓库 HTTPS 和 SSH 通道的切换</h1><blockquote>
<p>2020.04.04</p>
</blockquote>
<p>用 HTTPS 方式总是需要输入用户名和密码； SSH 方式使用之前需要先配置密钥。</p>
<p>查看当前本地仓库对应的远程仓库地址：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/Sningning/DataStructures.git (fetch)</span><br><span class="line">origin  https://github.com/Sningning/DataStructures.git (push)</span><br></pre></td></tr></tbody></table></figure>

<p>切换为 SSH 通道：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git remote set-url origin git@github.com:Sningning/DataStructures.git</span><br></pre></td></tr></tbody></table></figure>

<p>再查看下，已经改为 SSH 通道了。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:Sningning/DataStructures.git (fetch)</span><br><span class="line">origin  git@github.com:Sningning/DataStructures.git (push)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="2-测试-GitHub-连接"><a href="#2-测试-GitHub-连接" class="headerlink" title="2. 测试 GitHub 连接"></a>2. 测试 GitHub 连接</h1><blockquote>
<p>2020.04.08</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="3-MySQL-5-7-及-8-0-配置驱动"><a href="#3-MySQL-5-7-及-8-0-配置驱动" class="headerlink" title="3.MySQL 5.7 及 8.0 配置驱动"></a>3.MySQL 5.7 及 8.0 配置驱动</h1><p>MySQL 5.7 及 8.0 不能用老版的<code>com.mysql.jdbc.Driver</code>驱动，需要换成<code>mysql.connector-java-8.0.20.jar</code>包中的<code>com.mysql.cj.jdbc.Driver</code>新版驱动。</p>
<p>同时 url 还需要加入时区<code>jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai</code>。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构04-二分搜索树</title>
    <url>/posts/523021e3/</url>
    <content><![CDATA[<blockquote>
<p>树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。把它叫做“树”是因为它看起来像一棵倒挂的树。</p>
<p>二分搜索树（Binary Search Tree，BST）相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 <code>O(log n)</code>。二分搜索树是基础性数据结构，用于构建更为抽象的数据结构。</p>
<p><strong><em>维基百科</em></strong></p>
</blockquote>
<a id="more"></a>


<h1 id="1-BST-基础"><a href="#1-BST-基础" class="headerlink" title="1. BST 基础"></a>1. BST 基础</h1><h2 id="1-1-二叉树"><a href="#1-1-二叉树" class="headerlink" title="1.1 二叉树"></a>1.1 二叉树</h2><p>二叉树（Binary tree）是每个结点最多只有两个分支的树结构。通常分支被称作“左孩子”和“右孩子”或“左子树”和“右子树”。</p>
<p>二叉树的性质：</p>
<ul>
<li>二叉树只有一个根结点</li>
<li>二叉树每个结点最多有两个孩子</li>
<li>每个结点最多有一个父亲</li>
<li>每个结点的左孩子也是一个二叉树</li>
<li>每个结点的右孩子也是一个二叉树</li>
</ul>
<p>二叉树不一定是“满”的，一个结点也是一个二叉树，<code>NULL</code> 也是一个二叉树。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/tree.png" width="500px"> </div>

<h2 id="1-2-BST"><a href="#1-2-BST" class="headerlink" title="1.2 BST"></a>1.2 BST</h2><p>二分搜索树是一种二叉树，除了二叉树的性质之外，二分搜索树还有如下性质：</p>
<ul>
<li>二分搜索树中每个结点的值：<ul>
<li>大于其左子树的所有结点的值</li>
<li>小于其右子树的所有结点的值</li>
</ul>
</li>
<li>任意结点的左、右子树也分别为二分搜索树</li>
</ul>
<p>为了能达到搜索的目的，二分搜索树存储的元素必须有可比较性。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/BST.png" width=""> </div>

<p>二分搜索树类中实现的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int getSize()</td>
<td align="center">获取二分搜索树中元素个数</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">返回二分搜索树是否为空</td>
</tr>
<tr>
<td align="center">void add(E e)</td>
<td align="center">向二分搜索树中添加新元素 e</td>
</tr>
<tr>
<td align="center">boolean contains(E e)</td>
<td align="center">查看二分搜索树中是否包含元素 e</td>
</tr>
<tr>
<td align="center">E minimum()</td>
<td align="center">查找二分搜索树的最小元素</td>
</tr>
<tr>
<td align="center">E maximum()</td>
<td align="center">查找二分搜索树的最大元素</td>
</tr>
<tr>
<td align="center">void preOrder()</td>
<td align="center">二分搜索树的前序遍历</td>
</tr>
<tr>
<td align="center">void inOrder()</td>
<td align="center">二分搜索树的中序遍历</td>
</tr>
<tr>
<td align="center">void postOrder()</td>
<td align="center">二分搜索树的后序遍历</td>
</tr>
<tr>
<td align="center">void levelOrder()</td>
<td align="center">二分搜索树的层序遍历</td>
</tr>
<tr>
<td align="center">E removeMin()</td>
<td align="center">从二分搜索树中删除最小值所在的结点，返回最小值</td>
</tr>
<tr>
<td align="center">E removeMax()</td>
<td align="center">从二分搜索树中删除最大值所在的结点，返回最大值</td>
</tr>
<tr>
<td align="center">void remove(E e)</td>
<td align="center">从二分搜索树中删除元素为 e 的结点</td>
</tr>
</tbody></table>
<p>根据二分搜索树的性质，可以将结点信息以及简单的方法先完成。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="2-向-BST-中添加元素"><a href="#2-向-BST-中添加元素" class="headerlink" title="2. 向 BST 中添加元素"></a>2. 向 BST 中添加元素</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void add(E e)</td>
<td align="center">向二分搜索树中添加新元素 e</td>
</tr>
</tbody></table>
<p>如果当前的二分搜索树为空，那么直接可以将新的元素添加，同时维护 <code>size</code>。</p>
<p>如果当前二分搜索树不为空，那么需要从根结点出发，先与根结点比较。</p>
<ul>
<li>比根结点大，往右子树插入；</li>
<li>比根结点小，往左子树插入；</li>
<li>和根结点相等，不做改变；（实现的二分搜索树不包含重复元素）</li>
</ul>
<p>这样依次递归下去，知道要插入的位置为空，那么就可以将该元素正确地添加到树中。因此可以写一个递归的方法来实现添加元素的操作。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add1.gif" width=""> </div>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add2.gif" width=""> </div>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add3.gif" width=""> </div>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add4.gif" width=""> </div>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add5.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 向二分搜索树中添加新元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">        root = <span class="keyword">new</span> Node(e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        add(root, e)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向以 node 为根的二分搜索树中插入元素 e，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止的条件</span></span><br><span class="line">    <span class="keyword">if</span>(e.equals(node.e)) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span> &amp;&amp; node.left == <span class="keyword">null</span>) {</span><br><span class="line">        node.left = <span class="keyword">new</span> Node(e);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span> &amp;&amp; node.right == <span class="keyword">null</span>) {</span><br><span class="line">        node.right = <span class="keyword">new</span> Node(e);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归过程</span></span><br><span class="line">    <span class="keyword">if</span>(e.compareTo(node.e) &lt; <span class="number">0</span>) {</span><br><span class="line">        add(node.left, e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {  <span class="comment">//e.compareTo(node.e) &gt; 0</span></span><br><span class="line">        add(node.right, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="3-改进添加操作"><a href="#3-改进添加操作" class="headerlink" title="3. 改进添加操作"></a>3. 改进添加操作</h1><p>前面实现的添加操作中，对于 <code>root == null</code> 的情况进行了单独处理，但是提到过，<strong><code>null</code> 也是一个二分搜索树</strong>。因此，如果待插入的元素走到了一个 <code>null</code> 的位置，肯定要在这里新创建一个结点。</p>
<p>所以将之前递归代码的终止条件中，左右子树为空的条件去掉，让待插入元素再递归一层走到 <code>null</code>，和之前的递归过程相比，相当于多递归了一层，在 <code>null</code> 这个位置新建结点插入，然后将插入结点后的树返回给上一层递归调用，让进入递归前该结点的左子树或右子树接住这个变化，这样完成整个二分搜索树的更新。</p>
<p>如果待插入的元素和某一个结点元素相等，就直接将该结点返回给上层调用就可以了。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 向二分搜索树中添加新元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    add(root, e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向以 node 为根的二分搜索树中插入元素 e，递归算法</span></span><br><span class="line"><span class="comment">// 返回插入新结点后二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止的条件</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) {</span><br><span class="line">        node.left = add(node.left, e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e.compareTo(node.e) &gt; <span class="number">0</span>) {</span><br><span class="line">        node.right = add(node.right, e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 e.equals(node.e)，上面代码不执行，直接将该结点返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="4-BST-的查询操作"><a href="#4-BST-的查询操作" class="headerlink" title="4. BST 的查询操作"></a>4. BST 的查询操作</h1><p>二分搜索树的查询操作，分为查询指定元素 e 是否存在；查询树中最大元素和最小元素。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean contains(E e)</td>
<td align="center">查看二分搜索树中是否包含元素 e</td>
</tr>
<tr>
<td align="center">E minimum()</td>
<td align="center">查找二分搜索树的最小元素</td>
</tr>
<tr>
<td align="center">E maximum()</td>
<td align="center">查找二分搜索树的最大元素</td>
</tr>
</tbody></table>
<h2 id="4-1-查询指定元素"><a href="#4-1-查询指定元素" class="headerlink" title="4.1 查询指定元素"></a>4.1 查询指定元素</h2><p>要实现在二分搜索树中查询某个特定的元素是否存在，给定元素后，先与根结点比较，后续过程和添加元素操作一样，因此也可以使用递归来实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 查看二分搜索树中是否包含元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> contains(node, e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看以 node 为根的二分搜索树中是否包含元素 e，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止的条件</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e.equals(node.e)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> contains(node.left, e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> contains(node.right, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="4-2-查询最小元素和最大元素"><a href="#4-2-查询最小元素和最大元素" class="headerlink" title="4.2 查询最小元素和最大元素"></a>4.2 查询最小元素和最大元素</h2><p>根据二分搜索树的性质，当沿着树的左子树一直往下寻找，当到达最左端，也就是结点的左子树为空时，该结点中存储的元素就是整个树中的最小元素，最大元素相反，往右一直寻找。因此，寻找最小元素和最大元素的过程也是递归进行的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找二分搜索树的最小元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">minimum</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"树为空。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minimum(root).e;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回以 node 为根的二分搜索树的最小键值所在的结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止的条件</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找二分搜索树的最大元素（递归实现）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">maximum</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"树为空。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maximum(root).e;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回以 node 为根的二分搜索树的最大键值所在的结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">maximum</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maximum(node.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>在二分搜索树中寻找最小值和最大值的过程其实和对一个链表进行遍历是一样的操作，因此完全可以使用一个循环来找到相应的最小值和最大值。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找二分搜索树的最小元素（非递归实现）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">minimumNR</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"树为空。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur.left != <span class="keyword">null</span>) {</span><br><span class="line">        cur = cur.left;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur.e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找二分搜索树的最大元素（非递归实现）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">maximumNR</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"树为空。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur.right != <span class="keyword">null</span>) {</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur.e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="5-BST-的前、中、后序遍历"><a href="#5-BST-的前、中、后序遍历" class="headerlink" title="5. BST 的前、中、后序遍历"></a>5. BST 的前、中、后序遍历</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void preOrder()</td>
<td align="center">二分搜索树的前序遍历</td>
</tr>
<tr>
<td align="center">void inOrder()</td>
<td align="center">二分搜索树的中序遍历</td>
</tr>
<tr>
<td align="center">void postOrder()</td>
<td align="center">二分搜索树的后序遍历</td>
</tr>
</tbody></table>
<p>与添加和查询操作不同，二分搜索树的遍历操作要将二分搜索树所有的结点都访问一遍，而非仅仅是左子树或右子树。</p>
<p>运用递归操作，依然可以方便地对二分搜索树进行遍历操作。用递归方法遍历以 <code>node</code> 为根的二分搜索树，整体思路如下：</p>
<ul>
<li>开始：<ul>
<li><code>node</code> 为空：直接返回</li>
<li><code>node</code> 不为空：<ul>
<li>访问 <code>node</code></li>
<li>遍历 <code>node.left</code></li>
<li>遍历 <code>node.right</code></li>
</ul>
</li>
</ul>
</li>
<li>结束</li>
</ul>
<p>其中，递归调用发生在遍历左子树和右子树的操作中。根据访问 <code>node</code> 的顺序不同，遍历可以分为前序遍历、中序遍历、后序遍历。这里定义访问 <code>node</code> 的操作为打印 <code>node</code> 结点存储的元素。</p>
<br>

<h2 id="5-1-前序遍历"><a href="#5-1-前序遍历" class="headerlink" title="5.1 前序遍历"></a>5.1 前序遍历</h2><p>最主要的是实现遍历的递归函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>{</span><br><span class="line">    preOrder(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历以 node 为根的二分搜索树，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">    preOrder(node.left);</span><br><span class="line">    preOrder(node.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="5-2-中序遍历"><a href="#5-2-中序遍历" class="headerlink" title="5.2 中序遍历"></a>5.2 中序遍历</h2><p>中序遍历无非是把访问该结点信息的操作放在访问左子树和右子树中间，根据二分搜索树的性质可以知道，该结点左子树均是小于该结点的，右子树都是大于该结点的，因此，二分搜索树中序遍历的结果是顺序的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span> </span>{</span><br><span class="line">    inOrder(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历以 node 为根的二分搜索树，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    inOrder(node.left);</span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">    inOrder(node.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="5-3-后序遍历"><a href="#5-3-后序遍历" class="headerlink" title="5.3 后序遍历"></a>5.3 后序遍历</h2><p>后序遍历就是先访问该结点的左子树，再访问该结点的右子树，最后访问该结点。后序遍历的一个应用就是释放二分搜索树的内存，如果手动释放内存，就需要先将孩子结点的内存释放，最后再释放该结点的内存。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>{</span><br><span class="line">    postOrder(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历以 node 为根的二分搜索树，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    postOrder(node.left);</span><br><span class="line">    postOrder(node.right);</span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="5-4-再理解-BST-的遍历"><a href="#5-4-再理解-BST-的遍历" class="headerlink" title="5.4 再理解 BST 的遍历"></a>5.4 再理解 BST 的遍历</h2><p>对于二分搜索树的遍历，程序编写是简单的，但是如果面对一颗二分搜索树，怎样快速手写出前中后序遍历结果？</p>
<p>对于二分搜索树的每个结点，都有 3 次访问机会，分别是访问该结点左子树之前；访问左子树和右子树之间；访问右子树之后。分别对应下图的 3 个紫色的点。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/遍历.png" width="600px"> </div> <br>

<p>前序遍历过程中，真正打印该结点是在第 1 次访问该结点的时候。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/preOrder.gif" width=""> </div> <br>


<p>中序遍历过程中，真正打印该结点是在第 2 次访问该结点的时候。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/inOrder.gif" width=""> </div> <br>

<p>后序遍历过程中，真正打印该结点是在第 3 次访问该结点的时候。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/postOrder.gif" width=""> </div>

<hr>
<h1 id="6-BST-前序遍历的非递归实现"><a href="#6-BST-前序遍历的非递归实现" class="headerlink" title="6. BST 前序遍历的非递归实现"></a>6. BST 前序遍历的非递归实现</h1><p>利用栈来实现前序遍历，根据栈结构后入先出的性质，栈顶元素是要访问的元素，先访问该元素，然后将该元素弹出栈，随后将该结点的孩子压入栈，入栈顺序是右孩子先入栈，然后左孩子再入栈，这样，栈顶元素就是左孩子，然后访问左孩子，弹出栈，再依次压入它的右孩子和左孩子，依次进行。当栈为空时，完成遍历。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/preOrderNR.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的非递归前序遍历，非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderNR</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Deque&lt;Node&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line"></span><br><span class="line">        Node cur = stack.pop();</span><br><span class="line">        System.out.println(cur.e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) {  <span class="comment">// 右孩子先入栈</span></span><br><span class="line">            stack.push(cur.right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) {</span><br><span class="line">            stack.push(cur.left); </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="7-BST-的层序遍历"><a href="#7-BST-的层序遍历" class="headerlink" title="7. BST 的层序遍历"></a>7. BST 的层序遍历</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void levelOrder()</td>
<td align="center">二分搜索树的层序遍历</td>
</tr>
</tbody></table>
<p>二分搜索树的前中后序遍历都是在树的一侧一插到底，然后往回递归。层序遍历就是对于一个树，一层一层地对每个结点进行操作，层序遍历又称为<strong>广度优先遍历</strong>，相对应的，二分搜索树的前中后序遍历又称为<strong>深度优先遍历</strong>。对于二分搜索树的层序遍历，多是使用非递归实现，这里使用队列这种数据结构来实现二分搜索树的层序遍历。</p>
<p>队首元素是当前需要操作的元素，将队首元素出队，操作完成后，将该元素的左孩子和右孩子依次入队，知道队列为空，此时完成层序遍历。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/levelOrder.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的层序遍历（广度优先遍历）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Queue&lt;E&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line"></span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        System.out.println(cur.e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) {  <span class="comment">// 左孩子先入队</span></span><br><span class="line">            queue.offer(cur.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) { <span class="comment">// 右孩子再入队</span></span><br><span class="line">            queue.offer(cur.right); </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>广度优先遍历有时可以更快的找到指定的元素，如下图所示，当要找的元素在红点位置，但使用深度优先遍历会直接先插到底部从左边寻找，而这是如果采用广度优先遍历便可以很快找到答案。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/levelOrder1.gif" width=""> </div>

<p>在图中也存在深度优先遍历和广度优先遍历，不过在图中进行遍历时，需要记录一下该结点之前是否遍历过，因为对于图来说，每一个结点的前驱可能有多个。</p>
<hr>
<h1 id="8-删除-BST-中最小元素和最大元素"><a href="#8-删除-BST-中最小元素和最大元素" class="headerlink" title="8. 删除 BST 中最小元素和最大元素"></a>8. 删除 BST 中最小元素和最大元素</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">E removeMin()</td>
<td align="center">从二分搜索树中删除最小值所在的结点，返回最小值</td>
</tr>
<tr>
<td align="center">E removeMax()</td>
<td align="center">从二分搜索树中删除最大值所在的结点，返回最大值</td>
</tr>
</tbody></table>
<p>最小元素和最大元素所在的结点可能是叶子结点也可能不是叶子结点。</p>
<h2 id="8-1-删除-BST-中最小元素"><a href="#8-1-删除-BST-中最小元素" class="headerlink" title="8.1 删除 BST 中最小元素"></a>8.1 删除 BST 中最小元素</h2><p>如果最小元素所在的结点是叶子结点，可以直接将其删除。但是当待删除的结点有右子树时，将该结点删除后，还要再把其右子树赋给其父亲结点，也就是该结点左子树的根结点接替了该结点的位置。由于 <code>null</code> 也可以看做一个结点，因此，两个过程可以统一。最后维护 <code>size</code>。这里复用了之前的 <code>minmum()</code> 方法，因此不需要再对空树进行判断。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/removeMin.gif" width=""> </div>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/removeMin2.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从二分搜索树中删除最小值所在的结点，返回最小值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeMin</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    E ret = minmum();</span><br><span class="line">    root = removeMin(root);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除掉以 node 为根的二分搜索树中的最小结点</span></span><br><span class="line"><span class="comment">// 返回删除结点后新的二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) {</span><br><span class="line"></span><br><span class="line">        Node rightNode = node.right;</span><br><span class="line">        node.right = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    node.left = removeMin(node.left);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="8-2-删除-BST-中最大元素"><a href="#8-2-删除-BST-中最大元素" class="headerlink" title="8.2 删除 BST 中最大元素"></a>8.2 删除 BST 中最大元素</h2><p>删除最大元素和删除最小元素刚好相反，只需保存待删除结点的左子树即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从二分搜索树中删除最大值所在的结点，返回最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeMax</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    E ret = maximum();</span><br><span class="line">    root = removeMax(root);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除掉以 node 为根的二分搜索树中的最大结点</span></span><br><span class="line"><span class="comment">// 返回删除结点后新的二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMax</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) {</span><br><span class="line"></span><br><span class="line">        Node leftNode = node.left;</span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> leftNode;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    node.right = removeMax(node.right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="9-删除-BST-中任意元素"><a href="#9-删除-BST-中任意元素" class="headerlink" title="9. 删除 BST 中任意元素"></a>9. 删除 BST 中任意元素</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void remove(E e)</td>
<td align="center">从二分搜索树中删除元素为 e 的结点</td>
</tr>
</tbody></table>
<p>删除任意元素时，也是分成 3 种情况：</p>
<ul>
<li>待删除元素所在结点左子树为空</li>
<li>待删除元素所在结点右子树为空</li>
<li>待删除元素所在结点左右子树都存在</li>
</ul>
<p>前两种情况和删除最小元素和最大元素是类似：<br>如果左子树为空，暂存右子树，将该结点删除，然后将右子树的根结点返回给上一层递归调用；<br>如果右子树为空，暂存左子树，将该结点删除，然后将左子树的根结点返回给上一层递归调用。</p>
<p>当待删除元素所在结点左右子树都存在时，这里采用<strong>Hibbard Deletion</strong>。</p>
<div class="note primary">
            <p><strong>Delete</strong>. We can proceed in a similar manner to delete any node that has one child (or no children), but what can we do to delete a node that has two children? We are left with two links, but have a place in the parent node for only one of them. An answer to this dilemma, first proposed by T. Hibbard in 1962, is to delete a node x by replacing it with its successor. Because x has a right child, its successor is the node with the smallest key in its right subtree. The replacement preserves order in the tree because there are no keys between x.key and the successor’s key. We accomplish the task of replacing x by its successor in four (!) easy steps:</p><ul><li>Save a link to the node to be deleted in t</li><li>Set x to point to its successor min(t.right).</li><li>Set the right link of x (which is supposed to point to the BST containing all the keys larger than x.key) to deleteMin(t.right), the link to the BST containing all the keys that are larger than x.key after the deletion.</li><li>Set the left link of x (which was null) to t.left (all the keys that are less than both the deleted key and its successor).</li></ul><p><strong><em>Algorithms(4th edition) P410</em></strong></p>
          </div>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/Algorithms(4th edition).png" width=""> </div>

<p>再来几个动画演示。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/visualgo.net.gif" width=""> </div> <br>

<p>一句话概括就是，找到待删除结点右子树中的最小值所在结点，用此结点接替待删除的结点。简单描述下过程：</p>
<p>d 为待删除结点</p>
<ul>
<li>找到 s = min( s-&gt;right ), s 是 d 的后继</li>
<li>s-&gt;right = delMin( d-&gt;right )</li>
<li>s-&gt;left = d-&gt;left</li>
<li>删除 d, s 是新的子树的根</li>
</ul>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/remove.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从二分搜索树中删除元素为 e 的结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">remove</span><span class="params">(E e)</span> </span>{</span><br><span class="line">  remove(root, e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除掉以 node 为根的二分搜索树中值为e的结点, 递归算法</span></span><br><span class="line"><span class="comment">// 返回删除结点后新的二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) {</span><br><span class="line">        node.left = remove(node.left, e);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) {</span><br><span class="line">        node.right = remove(node.right, e);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {  <span class="comment">// e.compareTo(node.e) == 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除结点左子树为空的情况</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) {</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除结点右子树为空的情况</span></span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) {</span><br><span class="line">            Node leftNode = node.left;</span><br><span class="line">            node.left = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除结点左右子树均不为空的情况</span></span><br><span class="line">        <span class="comment">// 找到比待删除结点大的最小结点, 即待删除结点右子树的最小结点</span></span><br><span class="line">        <span class="comment">// 用这个结点顶替待删除结点的位置</span></span><br><span class="line">        Node successor = minimum(node.right);</span><br><span class="line">        successor.right = removeMin(node.right);</span><br><span class="line">        successor.left = node.left;</span><br><span class="line">        node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在最后一个 <code>else</code> 语句中，用了 2 个 <code>if</code>，而没有使用 <code>else if</code>，这是因为满足进入第一个 <code>if</code> 之后，里面直接 <code>return</code> 了，不会再去进行另一个 <code>if</code> 了，因此用 2 个 <code>if</code> 是没问题的。</p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://coding.imooc.com/class/207.html" target="_blank" rel="noopener">玩转数据结构</a></li>
<li><a href="https://visualgo.net/zh" target="_blank" rel="noopener">VisuAlgo</a></li>
<li><a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">算法(第4版)</a></li>
<li><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">Algorithms(4th edition)</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构03-链表</title>
    <url>/posts/ee7bd491/</url>
    <content><![CDATA[<p><strong>链表（Linked list）</strong> 是一种 <strong>动态</strong> 的线性数据结构，但并不是按线性的顺序存储数据。链表通常由一连串结点（Node）组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的引用（prev或next）。<br>链表的优点是不需要处理固定容量的问题，但是链表失去了数组随机读取的优点。</p>
<a id="more"></a>

<h1 id="1-链表"><a href="#1-链表" class="headerlink" title="1. 链表"></a>1. 链表</h1><p>链表是一种天然带有递归性质的线性结构，在链表中数据存储在<strong>结点</strong>中，结点中同时存储了指向下一个结点的引用（这里只介绍单向链表）。</p>
<p>链表类中的操作：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int getSize()</td>
<td align="center">获取链表中元素个数</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">返回链表是否为空</td>
</tr>
<tr>
<td align="center">void add(int index, E e)</td>
<td align="center">在链表的 index 位置添加新元素 e</td>
</tr>
<tr>
<td align="center">void addFirst(E e)</td>
<td align="center">在链表头部添加新元素 e</td>
</tr>
<tr>
<td align="center">addLast(E e)</td>
<td align="center">在链表末尾添加新元素 e</td>
</tr>
<tr>
<td align="center">E get(int index)</td>
<td align="center">获得链表的第 index 个位置的元素</td>
</tr>
<tr>
<td align="center">E getFirst()</td>
<td align="center">获得链表的第一个元素</td>
</tr>
<tr>
<td align="center">E getLast()</td>
<td align="center">获得链表的最后一个元素</td>
</tr>
<tr>
<td align="center">E set(int index, E e)</td>
<td align="center">修改链表的第 index 个位置的元素为 e，返回该位置之前的元素</td>
</tr>
<tr>
<td align="center">boolean contains(E e)</td>
<td align="center">查找链表中是否存在元素 e</td>
</tr>
<tr>
<td align="center">E remove(int index)</td>
<td align="center">从链表中删除第 index 个位置的元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">E removeFirst()</td>
<td align="center">从链表中删除第一个元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">E removeLast()</td>
<td align="center">从链表中删除最后一个元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">void removeElement(E e)</td>
<td align="center">从链表中删除元素e</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 结点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">  E e;</span><br><span class="line">  Node next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/02-LinkedList/LinkedList.png" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e, Node next)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>(e, <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="2-向链表中添加元素"><a href="#2-向链表中添加元素" class="headerlink" title="2. 向链表中添加元素"></a>2. 向链表中添加元素</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int getSize()</td>
<td align="center">获取链表中元素个数</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">返回链表是否为空</td>
</tr>
<tr>
<td align="center">void add(int index, E e)</td>
<td align="center">在链表的 index 位置添加新元素 e</td>
</tr>
<tr>
<td align="center">void addFirst(E e)</td>
<td align="center">在链表头部添加新元素 e</td>
</tr>
<tr>
<td align="center">addLast(E e)</td>
<td align="center">在链表末尾添加新元素 e</td>
</tr>
</tbody></table>
<p>先将链表类的几个基本属性和方法声明出来。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e, Node next)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>(e, <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;  <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;   <span class="comment">// 链表中元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span></span>{</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链表中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/03-LinkedList/addFirst.gif" width=""> </div>

<p>在链表头部添加元素，只需将之前整个链表的 <code>head</code> 赋给新插入结点的 <code>next</code> ，同时维护 <code>head</code> 和 <code>size</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在链表头添加新的元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    head = <span class="keyword">new</span> Node(e, head);</span><br><span class="line">    size ++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/03-LinkedList/add.gif" width=""> </div>


<p>根据图示可以看出，在某个位置添加元素最重要的是要找到前一个结点，设置一个结点引用 <code>prev</code>，通过移动 <code>prev</code> 找到待插入的位置的前一个位置，之后进行 <code>node.next = prev.next</code> 和 <code>prev.next = node</code> 两步操作就可以完成在某个位置添加元素的操作，最后维护 <code>size</code>。注意此时 <code>prev</code> 移动的次数，如果放在 3 这个位置，那么 <code>prev</code> 移动 2 次，即当 <code>prev == 2</code> 时就停止，所以循环条件是 <code>i &lt; index - 1</code>。</p>
<p>但是，如果 <code>index == 0</code>，即在链表头添加元素，由于 <code>head</code> 没有前一个结点，所以这种情况下需要单独处理。</p>
<p>切记两个操作不开颠倒顺序，否则，当执行完 <code>prev.next = node</code> 时，<code>prev.next</code> 已经指向了 <code>node</code>，再执行 <code>node.next = prev.next</code> 就出现了逻辑上的错误。</p>
<p>需要说明的是，在链表中一个位置添加元素是不常用的操作，其实在链表中没有索引这个概念，这里只是借助这个概念。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在链表的 index 位置添加新元素 e</span></span><br><span class="line"><span class="comment">// 在链表中不是一个常用的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"添加失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 在链表头添加，需要调用 addFirst 方法</span></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) {</span><br><span class="line">        addFirst(e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">        Node prev = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index - <span class="number">1</span>, i++) {</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Node node = new Node(e);</span></span><br><span class="line">        <span class="comment">// node.next = prev.next;</span></span><br><span class="line">        <span class="comment">// prev.next = node;</span></span><br><span class="line">        prev.next = node(e, prev.next);</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>在链表末尾添加元素就可以直接复用 <code>add(int index, E e)</code> 方法，将 <code>index</code> 设置为 <code>size</code> 即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在链表末尾添加新的元素e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>{</span><br><span class="line">    add(size, e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="3-虚拟头结点"><a href="#3-虚拟头结点" class="headerlink" title="3. 虚拟头结点"></a>3. 虚拟头结点</h1><p>之前在向链表中添加元素时，如果是在头部添加元素，由于头结点没有前结点，因此需要单独考虑。为了将对链表头的操作与其他操作统一起来，设立一个<strong>虚拟头结点(dummyHead)</strong>，虚拟头结点不存储元素，只有一个指向 <code>head</code> 的引用。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/03-LinkedList/dummyHead.png" width=""> </div>

<p>有了虚拟头结点，便可以将添加操作统一起来。新增 <code>dummyHead</code> 属性，初始化时将其建立起来，但元素值和 next 引用均为空。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类：Node</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e, Node next)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>(e,<span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node dummyHead;  <span class="comment">// 虚拟头结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span></span>{</span><br><span class="line">        dummyHead = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链表中元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>有了虚拟头结点后，从链表头部添加元素就不需要再单独考虑，因为 <code>dummyHead</code> 中 <code>next</code> 就指向链表第一个元素。注意，增加了虚拟头结点后，只需遍历 index 次，所以循环继续进行的条件是 <code>i &lt; index</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在链表的 index 位置添加新元素 e</span></span><br><span class="line"><span class="comment">// 在链表中不是一个常用的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"添加失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node prev = dummyHead;</span><br><span class="line">    <span class="comment">// 有虚拟头结点，从头部插入依然是安全的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) {</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    prev.next = <span class="keyword">new</span> Node(e, prev.next);</span><br><span class="line">    size ++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>此时向链表头部添加元素就可以复用 <code>add</code> 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在链表头部添加新元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>{</span><br><span class="line">  add(<span class="number">0</span>, e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="4-链表的遍历、查询和修改"><a href="#4-链表的遍历、查询和修改" class="headerlink" title="4. 链表的遍历、查询和修改"></a>4. 链表的遍历、查询和修改</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">E get(int index)</td>
<td align="center">获得链表的第 index 个位置的元素</td>
</tr>
<tr>
<td align="center">E getFirst()</td>
<td align="center">获得链表的第一个元素</td>
</tr>
<tr>
<td align="center">E getLast()</td>
<td align="center">获得链表的最后一个元素</td>
</tr>
<tr>
<td align="center">E set(int index, E e)</td>
<td align="center">修改链表的第 index 个位置的元素为 e，返回该位置之前的元素</td>
</tr>
<tr>
<td align="center">boolean contains(E e)</td>
<td align="center">查找链表中是否存在元素 e</td>
</tr>
</tbody></table>
<p>在链表中是不常使用索引的，因此 <code>get</code> 方法也不经常使用，更多是用来熟悉链表的遍历操作。</p>
<p>查询操作是需要找到 index 位置的结点，而添加操作是要找到 index 的前一个结点，因此对于查询操作，从链表真正的第一个结点开始遍历，由于设置了虚拟头结点，因此，遍历操作是从 <code>dummyHead.next</code> 进行的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获得链表的第 index 个位置的元素</span></span><br><span class="line"><span class="comment">// 在链表中不是一个常用的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"获取失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node cur = dummyHead.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) {</span><br><span class="line">        cur= cur.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur.e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>获取链表中第一个元素和最后一个元素就可以直接复用 <code>get</code> 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获得链表的第一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> get(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获得链表的最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> get(size - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>同样，修改元素也和查询元素一样需要遍历，只不过是把 index 位置的结点中数据域进行修改，最后维护 <code>size</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 修改链表的第 index 个位置的元素为 e，返回该位置之前的元素</span></span><br><span class="line"><span class="comment">// 在链表中不是一个常用的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"获取失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node cur = dummyHead.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++&gt;) {</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    E t = cur.e;</span><br><span class="line">    cur.e = e;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>设置一个查找的方法 <code>contains(E e)</code>，查询链表中是否包含元素 e。由于此时不知道具体索引位置，因此需要遍历整个链表，需要不断进行，直到到达链表的最后。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    Node cur = dummyHead.next;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cur.e.equals(e)) {</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      cur = cur.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>为了方便输出，重写 <code>toString()</code> 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node cur = dummyHead.next; cur != <span class="keyword">null</span>; cur = cur.next) {</span><br><span class="line">        res.append(cur + <span class="string">"-&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    res.append(<span class="string">"NULL"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="5-从链表中删除元素"><a href="#5-从链表中删除元素" class="headerlink" title="5. 从链表中删除元素"></a>5. 从链表中删除元素</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">E remove(int index)</td>
<td align="center">从链表中删除第 index 个位置的元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">E removeFirst()</td>
<td align="center">从链表中删除第一个元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">E removeLast()</td>
<td align="center">从链表中删除最后一个元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">void removeElement(E e)</td>
<td align="center">从链表中删除元素e</td>
</tr>
</tbody></table>
<p>想要实现在链表 index 位置删除元素，和添加元素一样，先找到待删除元素的前一个结点 <code>prev</code>，然后将待删除结点用临时结点 <code>retNode</code> 暂存起来，然后跳过待删除结点，直接将待删除结点的下一个结点赋给 <code>prev</code> 的 <code>next</code> 引用。为了避免对象游离，将待删除结点 <code>retNode</code> 的 <code>next</code> 引用设置为空。最后将 <code>retNode</code> 结点的数据返回并维护 <code>size</code>。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/03-LinkedList/remove.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从链表中删除第 index 个位置的元素，返回被删除的元素</span></span><br><span class="line"><span class="comment">// 在链表中不是一个常用的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"删除失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node prev = dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) {</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node retNode = prev.next;</span><br><span class="line">    prev.next = retNode.next;</span><br><span class="line">    retNode.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retNode.e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>有了 <code>remove</code> 方法，从链表中删除第一个元素和最后一个元素就可以直接复用 <code>remove</code> 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从链表中删除第一个元素，返回被删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从链表中删除最后一个元素，返回被删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> remove(size - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>要想从链表中删除元素，最重要的是要先找到它，找到之后，就和删除某个位置的元素一样操作就可以了。寻找的过程还是链表遍历的过程，删除元素是要找到待删除元素之前的结点 <code>prev</code>，因此遍历链表时从 <code>dummyHead</code> 开始，同时，遍历结束的条件是 <code>prev.next == null</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从链表中删除元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElemet</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    Node prev = dummyHead;</span><br><span class="line">    <span class="keyword">while</span> (prev.next != <span class="keyword">null</span>) {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev.next.e.equals(e)) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理待删除的结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev.next != <span class="keyword">null</span>) {</span><br><span class="line"></span><br><span class="line">        Node retNode = prev.next;</span><br><span class="line">        prev.next = retNode.next;</span><br><span class="line">        retNode.next = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="6-链表操作的时间复杂度"><a href="#6-链表操作的时间复杂度" class="headerlink" title="6. 链表操作的时间复杂度"></a>6. 链表操作的时间复杂度</h1><p><strong>添加操作</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add(int index, E e)</td>
<td align="center">O(n/2) = O(n)</td>
</tr>
<tr>
<td align="center">addFirst(E e)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">addLast(E e)</td>
<td align="center">O(n)</td>
</tr>
</tbody></table>
<p>由于在末尾添加元素需要遍历整个链表，所以时间复杂度为 <code>O(n)</code>；而在链表头部添加元素，是 <code>O(1)</code> 的时间复杂度；以上两个操作的时间复杂度是和数组相反的。当在链表任一位置插入元素是，平均来看，是往链表的中间添加元素，时间复杂度为 <code>O(n/2)</code>，总体也是 <code>O(n)</code> 级别。</p>
<br>

<p><strong>删除操作</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">remove(int index)</td>
<td align="center">O(n/2) = O(n)</td>
</tr>
<tr>
<td align="center">removeFirst()</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">removeLast()</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">removeElement(E e)</td>
<td align="center">O(n/2) = O(n)</td>
</tr>
</tbody></table>
<p>如果删除最后一个元素，需要从头遍历整个链表，时间复杂度为 <code>O(n)</code>；删除第一个元素，只需 <code>O(1)</code> 的时间复杂度；这两个操作的时间复杂度和数组也是相反的。平均来看，<code>remove(int index)</code> 和 <code>removeElement(E e)</code> 的时间复杂度为 <code>O(n)</code>。</p>
<br>

<p><strong>修改、查找操作</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">set(int index, E e)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">get(int index)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">getFirst()</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">getLast()</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">contains(E e)</td>
<td align="center">O(n)</td>
</tr>
</tbody></table>
<p>链表的修改和查找操作时间复杂度也是 <code>O(n)</code>。</p>
<br>

<p>总的来说，如果只对链表的头部进行操作，或者只对链表头部进行查找，时间复杂度是 <code>O(1)</code>，</p>
<p><strong>链表整体实现：</strong> <a href="https://github.com/Sningning/DataStructures/tree/master/03-Linked-List" target="_blank" rel="noopener">LikedList.java</a></p>
<hr>
<h1 id="7-使用链表实现栈"><a href="#7-使用链表实现栈" class="headerlink" title="7. 使用链表实现栈"></a>7. 使用链表实现栈</h1><p>栈的接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈中元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈，向栈中压入元素 e</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈，弹出栈顶元素</span></span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>由于在链表头操作的时间复杂度为 <code>O(1)</code>，因此栈的 <code>pop</code> 和 <code>push</code> 都应在链表头进行，也就是说，链表的头部是栈顶，尾部是栈底。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 用链表实现栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;E&gt; linkedList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListStack</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> linkedList.getSize();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> linkedList.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>{</span><br><span class="line">        linkedList.addFirst(e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> linkedList.removeFirst();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> linkedList.getFirst();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        res.append(<span class="string">"Stack: "</span>);</span><br><span class="line">        res.append(<span class="string">"top ["</span>);</span><br><span class="line">        res.append(linkedList);</span><br><span class="line">        res.append(<span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="8-使用链表实现队列"><a href="#8-使用链表实现队列" class="headerlink" title="8. 使用链表实现队列"></a>8. 使用链表实现队列</h1><p>对于队列，要在一端添加元素，另一端删除元素，但是对于链表来说势必会有一个 <code>O(n)</code> 的操作，其实之前用数组实现队列的时候也有同样的问题，不过用循环队列改进后，性能就提升了。因此用链表实现队列，也进行改进。</p>
<p>由于有 <code>head</code> 变量，所以之前对于链表头部的操作都是简单的，因此，可以考虑同时在链表尾部设置 <code>tail</code> 变量，指向最后一个结点，在对链表操作的时候，同时维护 <code>tail</code>。</p>
<p>添加了 <code>tail</code> 之后，想要在尾部添加元素就变得很方便，相当于在 <code>tail</code> 后面添加一个结点，这是，从链表的头部和尾部添加元素都是容易的</p>
<p>添加了 <code>tail</code> 之后，要想在尾部删除元素，就是说要找到 <code>tail</code> 前一个结点，但找到前一个结点又要进行遍历，所以从尾部删除元素是不容易的。</p>
<p>总的来说，添加 <code>tail</code> 变量之后，在链表尾部添加元素变得方便，而在头部添加或删除都是方便的，因此，选择在链表头部删除元素，在链表尾部添加元素，即：<strong>将链表头作为队首，链表尾部作为队尾</strong>。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/03-LinkedList/tail.gif" width=""> </div>

<p>先将简单的操作进行实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类：Node</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e, Node next)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>(e,<span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head, tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>进行入队操作，如果队列不为空，则直接将元素添加到最后即可，同时维护 <code>tail</code> 和 <code>size</code>。当队列为空时，<code>head</code> 和 <code>tail</code> 均指向 <code>null</code>，此时向空队中添加一个元素时，直接将 <code>tail</code> 指向入队的那个结点，同时维护 <code>head</code> 和 <code>size</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="keyword">null</span>) {  </span><br><span class="line">        tail = <span class="keyword">new</span> Node(e);</span><br><span class="line">        head = tail;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        tail.next = <span class="keyword">new</span> Node(e);</span><br><span class="line">        tail = tail.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    size ++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>正常出队的时候，只需按照链表中删除第一个元素，维护 <code>size</code> 即可。但是要注意，当队列中只有一个元素，<code>head.next</code> 为空，经过 <code>head = head.next</code> 操作后，队列已经为空，此时 <code>head == null</code>，因此还需要额外维护下 <code>tail</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"队列为空。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node retNode = head;</span><br><span class="line">    head = head.next;</span><br><span class="line">    retNode.next = <span class="keyword">null</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) { </span><br><span class="line">        tail = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    size --;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retNode.e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>查看队首元素只需将 <code>head</code> 数据域中的元素返回即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"队列为空。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head.e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>最后重写 <code>toString()</code> 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    res.append(<span class="string">"Queue: front "</span>);</span><br><span class="line"></span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">        res.append(cur + <span class="string">"-&gt;"</span>);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    }</span><br><span class="line">    res.append(<span class="string">"NULL tail"</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>用链表实现栈整体实现：<a href="https://github.com/Sningning/DataStructures/tree/master/02-Stacks-and-Queues/queues" target="_blank" rel="noopener">LinkedListQueue.java</a></p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://coding.imooc.com/class/207.html" target="_blank" rel="noopener">玩转数据结构</a></li>
<li><a href="https://visualgo.net/zh" target="_blank" rel="noopener">VisuAlgo</a></li>
<li><a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">算法(第4版)</a></li>
<li><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">Algorithms(4th edition)</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构02-栈和队列</title>
    <url>/posts/f9c8b94e/</url>
    <content><![CDATA[<p><strong>栈（Stack）</strong>是一种后入先出（Last In First Out, LIFO）的线性数据结构， 只能从一端添加或取出元素，进出元素的一端称为栈顶。<br><strong>队列（Queue）</strong>是一种先入先出（First In First Out, FIFO）的线性数据结构，只能从一端添加元素，从另一端取出元素，添加元素一端称为队尾，取出元素的一端称为队首。</p>
<a id="more"></a>


<h1 id="1-栈（Stack）"><a href="#1-栈（Stack）" class="headerlink" title="1.栈（Stack）"></a>1.栈（Stack）</h1><h2 id="1-1-栈的接口中定义的几个操作"><a href="#1-1-栈的接口中定义的几个操作" class="headerlink" title="1.1 栈的接口中定义的几个操作"></a>1.1 栈的接口中定义的几个操作</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int getSize()</td>
<td align="center">获取栈中元素个数</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">判断栈是否为空</td>
</tr>
<tr>
<td align="center">void push(E e)</td>
<td align="center">入栈，向栈中压入元素 e</td>
</tr>
<tr>
<td align="center">E pop()</td>
<td align="center">出栈，弹出栈顶元素</td>
</tr>
<tr>
<td align="center">E peek()</td>
<td align="center">查看栈顶元素</td>
</tr>
</tbody></table>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/02-Stacks-and-Queues/stack.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈中元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈，向栈中压入元素 e</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈，弹出栈顶元素</span></span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="1-2-基于-Array-类的栈实现"><a href="#1-2-基于-Array-类的栈实现" class="headerlink" title="1.2 基于 Array 类的栈实现"></a>1.2 基于 Array 类的栈实现</h2><p>如果用之前实现的动态数组 Array 类来实现栈，很多方法可以直接复用。由于在数组的末尾添加元素和删除元素的复杂度为 O(1)，因此将数组的末尾作为栈顶。</p>
<p>在实现栈中 <code>push(E e)</code> 和 <code>pop()</code> 方法时，根据后入先出的原则，分别复用 Array 中的 <code>addLast(E e)</code> 和 <code>removeLast()</code> 方法。<code>peek()</code> 操作只是查看栈顶元素，并非删除，因此复用 Array 类中的 <code>getLast()</code> 方法。</p>
<p>另外再添加 <code>getCapacity()</code> 方法，返回当前栈的容量，具体实现是返回底层数组的容量。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Array&lt;E&gt; array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> array.getCapacity();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> array.getSize();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> array.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>{</span><br><span class="line">        array.addLast(e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> array.removeLast();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> array.getLast();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>为了方便打印输出，重写一下 <code>toString()</code> 方法。数组栈的整体实现：<a href="https://github.com/Sningning/DataStructures/tree/master/02-Stacks-and-Queues/stacks" target="_blank" rel="noopener">ArrayStack.java</a></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    res.append(<span class="string">"Stack: "</span>);</span><br><span class="line">    res.append(<span class="string">'['</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.getSize() ; i ++) {</span><br><span class="line"></span><br><span class="line">            res.append(array.get(i));</span><br><span class="line">            <span class="keyword">if</span> (i != array.getSize() - <span class="number">1</span>) {</span><br><span class="line">                res.append(<span class="string">", "</span>);</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">    res.append(<span class="string">"] top"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1-3-栈的复杂度分析"><a href="#1-3-栈的复杂度分析" class="headerlink" title="1.3 栈的复杂度分析"></a>1.3 栈的复杂度分析</h2><p>由于 <code>push(E e)</code> 和 <code>pop()</code> 操作都是在数组尾操作，因此时间复杂度是 <code>O(1)</code>，如果触发 <code>resize()</code> 操作，按照均摊复杂度分析，整个过程也是 <code>O(1)</code>。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int getSize()</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">void push(E e)</td>
<td align="center">O(1) 均摊</td>
</tr>
<tr>
<td align="center">E pop()</td>
<td align="center">O(1) 均摊</td>
</tr>
<tr>
<td align="center">E peek()</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<hr>
<h1 id="2-队列（Queue）"><a href="#2-队列（Queue）" class="headerlink" title="2. 队列（Queue）"></a>2. 队列（Queue）</h1><h2 id="2-1-队列的接口中定义的几个操作"><a href="#2-1-队列的接口中定义的几个操作" class="headerlink" title="2.1 队列的接口中定义的几个操作"></a>2.1 队列的接口中定义的几个操作</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void enqueue(E e)</td>
<td align="center">入队，向队列中添加新元素 e</td>
</tr>
<tr>
<td align="center">E dequeue()</td>
<td align="center">出队，从队列中删除元素</td>
</tr>
<tr>
<td align="center">E getFront()</td>
<td align="center">查看队首元素</td>
</tr>
<tr>
<td align="center">int getSize()</td>
<td align="center">获取队列中元素个数</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">判断队列是否为空</td>
</tr>
</tbody></table>
<br>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队，向队列中添加新元素 e</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队，从队列中删除元素</span></span><br><span class="line">    <span class="function">E <span class="title">dequeue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看队首元素</span></span><br><span class="line">    <span class="function">E <span class="title">getFront</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列中元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/02-Stacks-and-Queues/queue.gif" width=""> </div>

<h2 id="2-2-基于-Array-类的队列实现"><a href="#2-2-基于-Array-类的队列实现" class="headerlink" title="2.2 基于 Array 类的队列实现"></a>2.2 基于 Array 类的队列实现</h2><p>还是用之前实现的动态数组 Array 类来实现队列，很多方法可以直接复用。</p>
<p>在实现队列中 <code>enqueue(E e)</code> 和 <code>dequeue()</code> 方法时，根据先入先出的原则，分别复用 Array 中的 <code>addLast(E e)</code> 和 <code>removeFirst()</code> 方法。<code>getFront()</code> 操作只是查看队首元素，并非删除，因此复用 Array 类中的 <code>getFirst()</code> 方法。</p>
<p>另外再添加 <code>getCapacity()</code> 方法，返回当前栈的容量，具体实现是返回底层数组的容量。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Array&lt;E&gt; array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> array.getCapacity();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>{</span><br><span class="line">        array.addLast(e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> array.removeFirst();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> array.getFirst();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> array.getSize();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> array.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>为了方便打印输出，重写 <code>toString()</code> 方法。数组队列的整体实现：<a href="https://github.com/Sningning/DataStructures/tree/master/02-Stacks-and-Queues/queue" target="_blank" rel="noopener">ArrayQueue.java</a>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">    </span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    res.append(<span class="string">"Queue: "</span>);</span><br><span class="line">    res.append(<span class="string">"front ["</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.getSize() ; i ++) {</span><br><span class="line">        </span><br><span class="line">        res.append(array.get(i));</span><br><span class="line">        <span class="keyword">if</span>(i != array.getSize() - <span class="number">1</span>) {</span><br><span class="line">            res.append(<span class="string">", "</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    res.append(<span class="string">"] tail"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-3-队列的复杂度分析"><a href="#2-3-队列的复杂度分析" class="headerlink" title="2.3 队列的复杂度分析"></a>2.3 队列的复杂度分析</h2><p>由于 <code>enqueue(E e)</code> 操作是在数组尾操作，因此时间复杂度是 <code>O(1)</code>，如果触发 <code>resize()</code> 操作，按照均摊复杂度分析，入队过程也是 <code>O(1)</code>。</p>
<p>但出队操作是在数组头部进行，底层复用动态数组类中 <code>removeFirst()</code> 方法，因此时间复杂度为 O(n)。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void enqueue(E e)</td>
<td align="center">O(1) 均摊</td>
</tr>
<tr>
<td align="center">E dequeue()</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">E getFront()</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">int getSize()</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<hr>
<h1 id="3-循环队列"><a href="#3-循环队列" class="headerlink" title="3. 循环队列"></a>3. 循环队列</h1><h2 id="3-1-循环队列介绍"><a href="#3-1-循环队列介绍" class="headerlink" title="3.1 循环队列介绍"></a>3.1 循环队列介绍</h2><p>之前用动态数组实现的队列，出队操作由于复用了动态数组中 <code>removeFirst()</code> 操作，删除第一个元素后，后面的元素需要向前依次移动，因此时间复杂度为 O(n)。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/02-Stacks-and-Queues/dequeue1.gif" width=""> </div>

<p>考虑出队后，其余元素不进行移动，这样就可以使出队的时间复杂度变为 <code>O(1)</code>。</p>
<p>当删除数组第一个元素后，不进行后面元素的移动，而是用一个 <code>front</code> 变量记录下当前第一个元素的索引位置，即队首元素位置，同时用一个 <code>tail</code> 变量记录下最后一个元素的下一个索引位置，也是新元素入队时的索引位置。这样当删除数组第一个元素后，只需要维护 <code>front</code> 就可以。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/02-Stacks-and-Queues/dequeue2.gif" width=""> </div>

<p>循环队列的初始状态下，队列中没有元素，<code>front</code> 和 <code>tail</code> 均指向底层数组的第一个位置，因此当 <code>front == tail</code> 时，队列为空。</p>
<p>进行入队操作时，只需维护 <code>tail</code>；如果进行出队操作，只需维护 <code>front</code>。</p>
<p>当底层数组中最后一个位置存在元素，再进行入队操作时，<code>tail</code> 就无法进行简单的 <code>tail++</code> 操作，但是由于进行了出队操作，底层数组的前半部分是空闲的，如下图中所示，这时 <code>tail</code> 应该指向 <code>data[0]</code>，因此要实现这种循环的操作，<code>tail</code> 的维护应该变成 <code>tail = (tail + 1) % data.length</code>。</p>
<p>当底层数组中 <code>tail + 1 == front</code>时，再添加元素，此时 <code>front == tail</code>，而前面定义这种情况是队列为空的判断条件，因此在这种情况下，选择不再添加元素，即判断队列为满的条件是  <code>tail + 1 == front</code>，但由于是循环队列，这个判断条件响应改为 <code>(tail + 1) % data.length == front</code>，如同钟表一样，11 点的下一个小时我们可以说是 12 点或者是 <code>0</code> 点，钟表中的 12 个刻度对应底层数组的长度 <code>data.length</code>。这时浪费了一个数组空间，因此当前队列所能存储最多的元素个数为 <code>data.length - 1</code>。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/02-Stacks-and-Queues/LoopQueue.gif" width=""> </div>

<h2 id="3-2-循环队列中简单方法的实现"><a href="#3-2-循环队列中简单方法的实现" class="headerlink" title="3.2 循环队列中简单方法的实现"></a>3.2 循环队列中简单方法的实现</h2><p>先进行 <code>LoopQueue</code> 类中简单操作的实现，由于实现方式不同，这里不再复用之前的 <code>Array</code> 动态数组类。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front, tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoopQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>{</span><br><span class="line">      </span><br><span class="line">        data = (E[])<span class="keyword">new</span> Object[capacity + <span class="number">1</span>];</span><br><span class="line">        front = <span class="number">0</span>;  <span class="comment">// 队列中第一个元素的索引</span></span><br><span class="line">        tail = <span class="number">0</span>;   <span class="comment">// 队列中最后一个元素的下一个索引</span></span><br><span class="line">        size = <span class="number">0</span>;   <span class="comment">// 队列中元素个数</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoopQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> data.length - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> front == tail;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后面实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后面实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后面实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-3-底层数组容量调整"><a href="#3-3-底层数组容量调整" class="headerlink" title="3.3 底层数组容量调整"></a>3.3 底层数组容量调整</h2><p>底层数组的容量调整和之前 <code>Array</code> 中 <code>resize(int newCapacity)</code> 方法类似。差别在于两个地方：遍历旧数组、维护 <code>front</code> 和 <code>tail</code>。</p>
<p>为了保证元素的顺序，必须从 <code>front</code> 开始遍历旧的 <code>data</code> 数组时，但旧数组中 <code>front</code> 可能不为 <code>0</code>，即不能进行 <code>newData[i] = data[i]</code> 这种操作，这时 <code>data</code> 中元素相对于 <code>newData</code> 中元素的索引值存在 front 数量的偏移，同时由于是循环队列，有可能会产生越界，需要再对 <code>data.length</code> 进行取模。这里也有两种遍历方式。</p>
<p>方式一：终止条件从 <code>size</code> 考虑。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">    newData[i] = data[(i + front) % data.length];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>方式二：终止条件从 <code>tail</code> 考虑。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = front ; i != tail ; i = (i + <span class="number">1</span>) % data.length) {</span><br><span class="line">    newData[(i - front) % data.length] = data[i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>在容量调整后，<code>front</code> 重新指向了新数组索引为 <code>0</code> 的位置，<code>tail</code> 重新指向了新数组中索引为 <code>size</code> 的位置。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>{</span><br><span class="line"></span><br><span class="line">    E[] newData = (E[]) <span class="keyword">new</span> Object[newCapacity + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        newData[i] = data[(i + front) % data.length];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    data = newData;</span><br><span class="line">    front = <span class="number">0</span>;</span><br><span class="line">    tail = size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="3-4-循环队列入队、出队的实现"><a href="#3-4-循环队列入队、出队的实现" class="headerlink" title="3.4 循环队列入队、出队的实现"></a>3.4 循环队列入队、出队的实现</h2><p>循环队列底层数组的添加、删除和容量调整的方式和 <code>Array</code> 中的方法基本是相同的，差别主要在于维护 <code>front</code> 和 <code>tail</code> 变量时并不是简单加一，而是需要加一并取模数组长度。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (tail + <span class="number">1</span>) % data.length == front ) {</span><br><span class="line">        resize( getCapacity() * <span class="number">2</span> );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    data[tail] = e;</span><br><span class="line">    tail = (tail + <span class="number">1</span>) % data.length;</span><br><span class="line">    size++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"出队失败，队列为空。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    E ret = data[front];</span><br><span class="line">    data[front] = <span class="keyword">null</span>;</span><br><span class="line">    front = (front + <span class="number">1</span>) % data.length;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == getCapacity() / <span class="number">4</span> &amp;&amp; getCapacity() / <span class="number">2</span> != <span class="number">0</span>) {</span><br><span class="line">        resize(getCapacity() / <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>重写 <code>toString()</code> 方法，循环队列的整体实现：<a href="https://github.com/Sningning/DataStructures/tree/master/02-Stacks-and-Queues/queues" target="_blank" rel="noopener">LoopQueue.java</a></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    res.append(String.format(<span class="string">"Queue: size = %d , capacity = %d\n"</span>, size, getCapacity()));</span><br><span class="line">    res.append(<span class="string">"front ["</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = front ; i != tail ; i = (i + <span class="number">1</span>) % data.length) {</span><br><span class="line"></span><br><span class="line">        res.append(data[i]);</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % data.length != tail) {</span><br><span class="line">            res.append(<span class="string">", "</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    res.append(<span class="string">"] tail"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-5-循环队列的时间复杂度"><a href="#3-5-循环队列的时间复杂度" class="headerlink" title="3.5 循环队列的时间复杂度"></a>3.5 循环队列的时间复杂度</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void enqueue(E e)</td>
<td align="center">O(1) 均摊</td>
</tr>
<tr>
<td align="center">E dequeue()</td>
<td align="center">O(1) 均摊</td>
</tr>
<tr>
<td align="center">E getFront()</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">int getSize()</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://coding.imooc.com/class/207.html" target="_blank" rel="noopener">玩转数据结构</a></li>
<li><a href="https://visualgo.net/zh" target="_blank" rel="noopener">VisuAlgo</a></li>
<li><a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">算法(第4版)</a></li>
<li><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">Algorithms(4th edition)</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构01-数组</title>
    <url>/posts/bb3e32af/</url>
    <content><![CDATA[<blockquote>
<p>数组（Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块<strong>连续</strong>的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。<strong><em>维基百科</em></strong></p>
</blockquote>
<p>数组最大的优点就是<strong>快速查询</strong>。</p>
<a id="more"></a>

<h1 id="1-数组类中包含的方法"><a href="#1-数组类中包含的方法" class="headerlink" title="1. 数组类中包含的方法"></a>1. 数组类中包含的方法</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Array( int capacity )</td>
<td align="center">构造容量为 capacity 的数组类</td>
</tr>
<tr>
<td align="center">Array()</td>
<td align="center">构造默认容量的数组类</td>
</tr>
<tr>
<td align="center">int getSize()</td>
<td align="center">获取数组中元素个数</td>
</tr>
<tr>
<td align="center">int getCapacity()</td>
<td align="center">获取数组容量</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">返回数组是否为空</td>
</tr>
<tr>
<td align="center">void add( int index, E e )</td>
<td align="center">在第 index 个位置插入一个新元素 e</td>
</tr>
<tr>
<td align="center">void addLast(E e)</td>
<td align="center">向所有元素后添加一个新元素 e</td>
</tr>
<tr>
<td align="center">void addFirst(E e)</td>
<td align="center">在所有元素前添加一个新元素 e</td>
</tr>
<tr>
<td align="center">E get(int index)</td>
<td align="center">获取 index 索引位置的元素</td>
</tr>
<tr>
<td align="center">E getLast()</td>
<td align="center">获取最后一个元素</td>
</tr>
<tr>
<td align="center">E getFirst()</td>
<td align="center">获第一个元素</td>
</tr>
<tr>
<td align="center">void set(int index, E e))</td>
<td align="center">修改 index 索引位置的为 e</td>
</tr>
<tr>
<td align="center">boolean contains(E e)</td>
<td align="center">查询数组中是否存在元素 e</td>
</tr>
<tr>
<td align="center">int find(E e)</td>
<td align="center">查询数组中元素 e 的索引位置，如果不存在，返回 -1</td>
</tr>
<tr>
<td align="center">E remove(int index)</td>
<td align="center">从数组中删除 index 位置的元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">E removeFirst()</td>
<td align="center">从数组中删除第一个元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">E removeLast()</td>
<td align="center">从数组中删除最后一个元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">void removeElement(E e)</td>
<td align="center">从数组中删除元素 e</td>
</tr>
</tbody></table>
<hr>
<h1 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h1><p>实现方法</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Array( int capacity )</td>
<td align="center">构造容量为 capacity 的数组类</td>
</tr>
<tr>
<td align="center">Array()</td>
<td align="center">构造默认容量的数组类</td>
</tr>
<tr>
<td align="center">int getSize()</td>
<td align="center">获取数组中元素个数</td>
</tr>
<tr>
<td align="center">int getCapacity()</td>
<td align="center">获取数组容量</td>
</tr>
</tbody></table>
<br>

<p>在进行数组类功能实现之前，先将基本框架搭建起来，在数组类 <code>Array</code> 的内部，定义一个私有数组 <code>data</code> 用来存放元素，定义一个 <code>int</code> 型私有变量 <code>size</code> 来表示数组元素个数。对于一些简单的方法，如获取数组元素个数、获取数组容量和判断数组是否为空，先进行实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入数组的容量 capacity 构造 Array</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">( <span class="keyword">int</span> capacity )</span> </span>{</span><br><span class="line">        data = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空参构造方法，默认数组容量 capacity = 10</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数组中元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数组容量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> data.length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数组是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="3-添加元素"><a href="#3-添加元素" class="headerlink" title="3. 添加元素"></a>3. 添加元素</h1><p>实现方法</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void add(int index, E e)</td>
<td align="center">在第 index 个位置插入一个新元素 e</td>
</tr>
<tr>
<td align="center">void addLast(E e)</td>
<td align="center">向所有元素后添加一个新元素 e</td>
</tr>
<tr>
<td align="center">void addFirst(E e)</td>
<td align="center">在所有元素前添加一个新元素 e</td>
</tr>
<tr>
<td align="center">E get(int index)</td>
<td align="center">获取 index 索引位置的元素</td>
</tr>
<tr>
<td align="center">E getLast()</td>
<td align="center">获取最后一个元素</td>
</tr>
<tr>
<td align="center">E getFirst()</td>
<td align="center">获第一个元素</td>
</tr>
<tr>
<td align="center">void set(int index, E e))</td>
<td align="center">修改 index 索引位置的为 e</td>
</tr>
</tbody></table>
<br>

<p> 由于数组中存放元素必须是连续存储，因此在某个索引位置添加元素时，索引位置处的元素以及其后所有的元素需要依次向后移动一个位置，之后，再将元素插入指定索引位置，在后移元素时，必须是最后一个元素先进行移动。</p>
<p> 在添加之前，还需注意两个情况：数组是否已经存满元素；传入的索引是否是合法的。对这两个情况检查完毕没有问题后，就可以将元素添加到指定索引位置，元素添加完毕后，还需要将数组元素个数加 1，即维护 <code>size</code>。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/01-Array/add.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在 index 索引位置插入新元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == data.length) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"添加失败，数组已满。"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"添加失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 后移元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= index ; i--) {</span><br><span class="line">        data[i + <span class="number">1</span>] = data[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    data[index] = e;</span><br><span class="line">    <span class="comment">// 维护 size</span></span><br><span class="line">    size ++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<br>

<p>实现了在指定位置添加元素后，实现在所有元素前、在所有元素后添加元素就很简单了，只需将 <code>add(int index, E e)</code> 中的 <code>index</code> 分别设置为 <code>0</code> 和 <code>size</code> 即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在所有元素后添加一个新元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    add(size, e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在所有元素前添加一个新元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    add(<span class="number">0</span>, e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="4-查询和修改元素"><a href="#4-查询和修改元素" class="headerlink" title="4. 查询和修改元素"></a>4. 查询和修改元素</h1><p>实现方法</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">E get(int index)</td>
<td align="center">获取 index 索引位置的元素</td>
</tr>
<tr>
<td align="center">E getLast()</td>
<td align="center">获取最后一个元素</td>
</tr>
<tr>
<td align="center">E getFirst()</td>
<td align="center">获第一个元素</td>
</tr>
<tr>
<td align="center">void set(int index, E e))</td>
<td align="center">修改 index 索引位置的为 e</td>
</tr>
</tbody></table>
<br>

<p>数组最大的优点就是可以快速查询，因此想要获取某个索引位置的元素，可以直接在数组中返回相应的元素，同样在进行查询之前，要先判断给出的 index 的合法性。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 index 索引位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"获取元素失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data[index];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<br>

<p>当实现了获取指定索引位置的元素后，获取最后一个和第一个元素的方法可以直接复用 <code>get(int index)</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获取最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">return</span> get(size - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获取第一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">return</span> get(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<br>

<p>同样，修改某个索引位置的元素同获取元素类似，只不过是将新的元素 e 赋值给数组中 <code>index</code> 位置即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 修改 index 索引位置元素为 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"修改失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    data[index] = e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="5-包含、搜索和删除元素"><a href="#5-包含、搜索和删除元素" class="headerlink" title="5. 包含、搜索和删除元素"></a>5. 包含、搜索和删除元素</h1><p>实现方法</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean contains(E e)</td>
<td align="center">查询数组中是否存在元素 e</td>
</tr>
<tr>
<td align="center">int find(E e)</td>
<td align="center">查询数组中元素 e 的索引位置，如果不存在，返回 -1</td>
</tr>
<tr>
<td align="center">E remove(int index)</td>
<td align="center">从数组中删除 index 位置的元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">E removeFirst()</td>
<td align="center">从数组中删除第一个元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">E removeLast()</td>
<td align="center">从数组中删除最后一个元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">void removeElement(E e)</td>
<td align="center">从数组中删除第一个元素 e</td>
</tr>
<tr>
<td align="center">void removeAllElement(E e)</td>
<td align="center">从数组中删除所有元素 e</td>
</tr>
</tbody></table>
<h2 id="5-1-包含、搜索元素"><a href="#5-1-包含、搜索元素" class="headerlink" title="5.1 包含、搜索元素"></a>5.1 包含、搜索元素</h2><p>有时想看数组中是否包含某个元素 e，基本思路是将数组遍历，将数组元素逐一与想要查询的元素 e 进行比较，当查询到相等时，立即返回 <code>true</code>，否则，遍历完整个数组也没有查询到与 e 相等的元素，则返回 <code>false</code>。</p>
<p>查询数组中某个元素的索引位置，也是相同的思路，遍历数组，查询到相等时就返回当前索引位置，否则返回 <code>-1</code>。这里实现的 <code>find(E e)</code> 方法只是将该元素第一次出现的位置返回。</p>
<p>由于使用了泛型（Generic），因此进行元素比较时，不能使用 <code>==</code> 来判断，应该使用 <code>equals()</code> 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 查询数组中是否存在元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        <span class="keyword">if</span> (data[i].equals(e)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 查询数组中元素 e 的索引位置，如果不存在，返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        <span class="keyword">if</span> (data[i].equals(e)) {</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="5-2-删除元素"><a href="#5-2-删除元素" class="headerlink" title="5.2 删除元素"></a>5.2 删除元素</h2><p>数组中的元素都是连续存储，因此删除操作实际上也是元素移动的过程，具体执行删除操作时，直接将待删除索引位置后面的元素依次向前移动覆盖，前移过程必须是待删除索引位置后第一个位置元素先进行移动。</p>
<p>当最后的元素 56 向前移动后，维护了 <code>size</code>，此时 <code>size</code> 指向了索引为 5 位置的 56，该元素用户是访问不到的。但是由于使用了泛型，所以实际上 <code>size</code> 还是指向了一个对象的引用，Java 的垃圾回收机制无法对其进行回收， 应该手动进行释放。</p>
<div class="note primary">
            <p>Java 的垃圾收集策略是回收所有无法被访问的对象的内存。在我们对 pop() 的实现中，被弹出的元素的引用仍然存在于数组中。这个元素实际上已经是一个孤儿了——它永远不会再被访问，但 Java 的垃圾收集器无法知道这一点，除非该引用被覆盖。即使用例不再需要这个元素了，数组中的引用仍然可以让它继续存在。这种情况（保存一个不需要的对象的引用）成为<strong>游离(loitering)</strong>。在这里，避免对象游离很容易，只需将被弹出的数组元素的值设为 null 即可。这将覆盖无用的引用并使系统可以在用例使用完被弹出的元素后回收它的内存。<strong><em>算法(第4版) P85</em></strong></p>
          </div>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/01-Array/delete.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组中删除 index 位置的元素, 返回被删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"删除失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    E ret = data[index];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index + <span class="number">1</span> ; i &lt; size ; i ++) {</span><br><span class="line">        data[i - <span class="number">1</span>] = data[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    size--;</span><br><span class="line">    data[size] = <span class="keyword">null</span>;  <span class="comment">// 避免对象游离</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>完成 <code>remove(int index)</code> 方法后，删除数组中第一个元素和最后一个元素，直接复用 <code>remove(int index)</code> 方法，传入相应的索引即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组中删除第一个元素, 返回被删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组中删除最后一个元素, 返回被删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> remove(size - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>要实现从数组中删除某一个元素 e，可以先调用 <code>find(E e)</code> 方法，找到其在数组中对应的索引位置，然后再调用 <code>remove(int index)</code> 方法，将其删除。如果调用 <code>find(E e)</code> 返回 <code>-1</code>，即数组中不存在该元素，这里不执行任何操作。实现的 <code>removeElement(E e)</code> 方法，由于只进行了一次 <code>find</code> 操作，因此只能删除第一次出现的 e。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组中(第一次出现 e 的位置)删除元素 e </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = find(e);</span><br><span class="line">    <span class="keyword">if</span> (index != -<span class="number">1</span>) {</span><br><span class="line">        remove(index);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="6-动态调整容量"><a href="#6-动态调整容量" class="headerlink" title="6. 动态调整容量"></a>6. 动态调整容量</h1><p>前面所有操作的实现，底层都是基于 <code>data</code> 数组，当实例化 <code>Array</code> 类后，底层 <code>data</code> 数组的容量就已经固定了。如果不断向数组中添加元素，势必会导致数组被填满，因此可以考虑，在添加完元素后，当满足一定条件时，进行底层 <code>data</code> 数组的扩容；另一方面，当删除完元素后，可以考虑当满足一定条件时，对底层 <code>data</code> 数组进行缩容。</p>
<p>数组大小的动态调整（缩容或扩容），实质上是将原来数组的元素，逐个复制到新的数组中，然后将之前的数组引用 <code>data</code> 指向新的数组，Java 的垃圾回收机制会将之前的数组进行回收。这里实现一个私有的方法 <code>resize(int newCapacity)</code> 来调整数组容量，设置成私有方法是因为，对于使用 <code>Array</code> 类的用户来说，容量调整这个过程是对其屏蔽的。</p>
<div align="center"><img width="" src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/01-Array/resize1.gif"></div>
<br>
<div align="center"><img width="" src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/01-Array/resize2.gif"></div>


<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 数组容量调整</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>{</span><br><span class="line"></span><br><span class="line">    E[] newData = (E[]) <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        newData[i] = data[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    data = newData;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="6-1-扩容"><a href="#6-1-扩容" class="headerlink" title="6.1 扩容"></a>6.1 扩容</h2><p>扩容，是在添加元素时进行的，前面实现的 <code>add(int index, int e)</code> 方法中，对于数组已满的情况是抛出了异常，现在可以将底层 <code>data</code> 数组进行扩容，扩容的大小设置为当前容量的 <code>2</code> 倍，即 <code>2 * data.length</code>，这里设置的新数组的容量是与现有元素个数相关联的，保证新数组容量和之前数组中元素的个数是一个数量级。 </p>
<div class="note primary">
            <p>在 <code>Java</code> 中，<code>ArrayList</code> 扩容是变为原来的 <strong><code>1.5</code></strong> 倍。在 <code>ArrayList</code> 类的 <code>grow(int minCapacity)</code> 私有方法中， <strong><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code></strong> 进行了新容量的设定。</p>
          </div>
<br>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在第 index 个位置插入一个新元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">( <span class="keyword">int</span> index, E e )</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( index &lt; <span class="number">0</span> || index &gt; size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"添加失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    <span class="keyword">if</span> ( size == data.length ) {</span><br><span class="line">        resize(<span class="number">2</span> * data.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= index; i--) {</span><br><span class="line">        data[i + <span class="number">1</span>] = data[i];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    data[index] = e;</span><br><span class="line">    size++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="6-2-缩容"><a href="#6-2-缩容" class="headerlink" title="6.2 缩容"></a>6.2 缩容</h2><p>在删除对象后，可以根据元素个数进行缩容操作。当元素个数小到刚好等于数组长度的一半时，即 <code>size == data.length / 2</code>，将数组缩容为原来长度的一半。暂时这样处理，后续再进行优化。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组中删除 index 位置的元素, 返回删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"删除失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    E ret = data[index];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index + <span class="number">1</span> ; i &lt; size ; i ++) {</span><br><span class="line">        data[i - <span class="number">1</span>] = data[i];</span><br><span class="line">    }</span><br><span class="line">    size--;</span><br><span class="line">    data[size] = <span class="keyword">null</span>; <span class="comment">// 避免对象游离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩容</span></span><br><span class="line">    <span class="keyword">if</span> (size == data.length / <span class="number">2</span>) {</span><br><span class="line">        resize(data.length / <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="7-简单的时间复杂度分析"><a href="#7-简单的时间复杂度分析" class="headerlink" title="7. 简单的时间复杂度分析"></a>7. 简单的时间复杂度分析</h1><h2 id="7-1-添加操作的时间复杂度"><a href="#7-1-添加操作的时间复杂度" class="headerlink" title="7.1 添加操作的时间复杂度"></a>7.1 添加操作的时间复杂度</h2><table>
<thead>
<tr>
<th align="center">添加操作</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">addLast(E e)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">addFirst(E e)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">add(int index, E e)</td>
<td align="center">O(n/2) = O(n)</td>
</tr>
</tbody></table>
<p>有时添加元素时还需要扩容，<code>resize</code> 操作的时间复杂度为 <code>O(n)</code>，因此，总体来看，添加操作的时间复杂度为 <code>O(n)</code>。</p>
<h2 id="7-2-删除操作的时间复杂度"><a href="#7-2-删除操作的时间复杂度" class="headerlink" title="7.2 删除操作的时间复杂度"></a>7.2 删除操作的时间复杂度</h2><table>
<thead>
<tr>
<th align="center">删除操作</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">removeLast(E e)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">removeFirst(E e)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">remove(int index, E e)</td>
<td align="center">O(n/2) = O(n)</td>
</tr>
</tbody></table>
<p>有时删除元素后还需要缩容，<code>resize</code> 操作的时间复杂度为 <code>O(n)</code>，因此，总体来看，删除操作的时间复杂度为 <code>O(n)</code>。</p>
<h2 id="7-3-修改、查询操作的时间复杂度"><a href="#7-3-修改、查询操作的时间复杂度" class="headerlink" title="7.3 修改、查询操作的时间复杂度"></a>7.3 修改、查询操作的时间复杂度</h2><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">set(int index, E e)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">get(int index)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">contains(E e)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">find(E e)</td>
<td align="center">O(n)</td>
</tr>
</tbody></table>
<hr>
<h1 id="8-改进缩容操作"><a href="#8-改进缩容操作" class="headerlink" title="8. 改进缩容操作"></a>8. 改进缩容操作</h1><p>假设当前数组容量为 8，即 <code>capacity = 8</code>。添加 9 个元素，每次添加操作均使用 <code>addLast()</code> ，则一共需要 <code>9</code> 次 <code>addLast()</code> 操作和 <code>1</code> 次 <code>resize(2 * 8)</code> 操作。其中， <code>resize(2 * 8)</code> 需要将已有的 <code>8</code> 个元素全部进行复制，因此总共进行了 <code>17</code> 次基本操作。平均来看，每次 <code>addLast()</code> 操作会进行 <code>2</code> 次基本操作。</p>
<p>更普遍的，假设 <code>capacity = n</code>，<code>n + 1</code> 次 <code>addLast()</code> ，触发 <code>resize</code> 操作，总共进行了 <code>n + n + 1 = 2n + 1</code> 次基本操作。平均来看，每次 <code>addLast()</code> 操作会进行 <code>2</code> 次基本操作。这里 <code>1</code> 次 <code>resize</code> 的时间<strong>平摊</strong>给了 <code>n + 1</code> 次 <code>addLast()</code> 操作，这样均摊来看，<code>addLast()</code> 的时间复杂度为 <code>O(1)</code>，因此在这里 <code>addLast()</code> 的<strong>均摊复杂度(Amortized Time Complexity)</strong> 为 <code>O(1)</code>。</p>
<p>同理，从均摊复杂度分析，<code>removeLast()</code> 的摊复杂度也是 O(1)。</p>
<p>但是，当 <code>size == data.length</code>，也就是 <code>size == capacity</code> 时，依次进行 <code>addLast()</code> 和 <code>removeLast()</code> 操作，根据之前 <code>add</code> 和 <code>remove</code> 中扩容缩容的条件，会出现<strong>复杂度振荡</strong>的情况。</p>
<div align="center"><img width="" src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/01-Array/complexity.gif"></div>
<br> 

<p>出现复杂度振荡的原因，是在进行 <code>removeLast()</code> 操作时 <code>resize</code> 过于<strong>着急(eager)</strong> ，当元素个数等于数组容量的一半时马上进行缩容，缩容完整个 <code>data</code> 数组是满的，再添加元素肯定需要再进行扩容。解决的方法就是采用 <strong>懒惰 (lazy)</strong> 的方案，当 <code>size == data.length / 4</code> 时，再进行容量减半，此时缩容完，<code>data</code> 数组还有一半的空余容量。</p>
<p>注意，因为是要缩容，<code>data.length</code> 要减小，有可能 <code>data.length == 1</code>，此时 <code>data.length / 2 == 0</code>，因此缩容前应该进行判断。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组中删除 index 位置的元素，返回被删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"删除失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    E ret = data[index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; size; i++) {</span><br><span class="line">        data[i - <span class="number">1</span>] = (data[i]);</span><br><span class="line">    }</span><br><span class="line">    size--;</span><br><span class="line">    data[size] = <span class="keyword">null</span>; <span class="comment">// 避免对象游离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩容</span></span><br><span class="line">    <span class="keyword">if</span> (size == data.length / <span class="number">4</span> &amp;&amp; data.length / <span class="number">2</span> != <span class="number">0</span>) {</span><br><span class="line">        resize(data.length / <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div align="center"><img width="" src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/01-Array/LazyResize.gif"></div>

<hr>
<h1 id="9-数组类的整体实现"><a href="#9-数组类的整体实现" class="headerlink" title="9. 数组类的整体实现"></a>9. 数组类的整体实现</h1><p>为了方便打印输出，重写了 <code>toString()</code> 方法。整体实现：<a href="https://github.com/Sningning/DataStructures/tree/master/01-Arrays" target="_blank" rel="noopener">Array.java</a></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    res.append(String.format(<span class="string">"Array: size = %d, capacity = %d\n"</span>, size, data.length));</span><br><span class="line">    res.append(<span class="string">"["</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        res.append(data[i]);</span><br><span class="line">        <span class="keyword">if</span>(i != size - <span class="number">1</span>) {</span><br><span class="line">            res.append(<span class="string">", "</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    res.append(<span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://coding.imooc.com/class/207.html" target="_blank" rel="noopener">玩转数据结构</a></li>
<li><a href="https://visualgo.net/zh" target="_blank" rel="noopener">VisuAlgo</a></li>
<li><a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">算法(第4版)</a></li>
<li><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">Algorithms(4th edition)</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义npm包的安装位置</title>
    <url>/posts/15d73520/</url>
    <content><![CDATA[<p>nodejs 官网上下载的安装包中包含 npm，在 Windows 系统下安装完后，npm 下载模块默认安装在 <code>C:\Users\本机用户名\AppData\Roaming</code> 文件中。但在清理磁盘时容易将其清理掉，考虑将 npm 也安装在其他盘符。</p>
<p>通过以下几个步骤实现在安装 nodejs 时将 npm 也安装在自定义路径。</p>
<a id="more"></a>
<br>


<p><strong>1. 在<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网</a>下载 zip 文件</strong><br>这里不使用默认的 msi 安装包，使用 <code>zip</code> 压缩文件，之后自己配置安装路径和环境变量。<br><br></p>
<p><strong>2. 设置安装目录</strong><br>我这里将 nodejs 安装在D盘。在 <code>D:\Program Files\</code> 目录下新建 node 文件夹，然后在 node 文件夹中新建 nodejs、npm_prefix、npm_cashe 三个文件夹。将下载的压缩包中的所有文件拷贝到 nodejs 文件夹中。<br><br></p>
<p><strong>3. 设置环境变量</strong><br>① 将 node 路径加入环境变量。<br>在 Path 中添加 <code>D:\Program Files\node\nodejs</code>。或者通过以下命令将 node路径 加入环境变量。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">setx PATH "%PATH%;D:\Program Files\node\nodejs</span><br></pre></td></tr></tbody></table></figure>

<p>② 将 npm 的全局模块路径加入到环境变量。<br>在 Path 中添加 <code>D:\Program Files\node\npm_prefix</code>，或者通过以下命令将 npm 全局模块路径加入环境变量 。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">setx PATH "%PATH%;D:\Program Files\node\npm_prefix</span><br></pre></td></tr></tbody></table></figure>
<br>

<p><strong>4. 设置 npm 全局模块和缓存路径</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">npm config set prefix "D:\\Program Files\\node\\npm_prefix"</span><br><span class="line">npm config set cache "D:\\Program Files\\node\\npm_cache"</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>大功告成！<br><br></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
