<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git 使用技巧</title>
    <url>/posts/f0688a92/</url>
    <content><![CDATA[<p>记录一些遇到过的 Git 操作。</p>
<a id="more"></a>

<h1 id="1-GitHub-仓库-HTTPS-和-SSH-通道的切换"><a href="#1-GitHub-仓库-HTTPS-和-SSH-通道的切换" class="headerlink" title="1. GitHub 仓库 HTTPS 和 SSH 通道的切换"></a>1. GitHub 仓库 HTTPS 和 SSH 通道的切换</h1><p>用 HTTPS 方式总是需要输入用户名和密码； SSH 方式使用之前需要先配置密钥。</p>
<p>查看当前本地仓库对应的远程仓库地址：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/Sningning/DataStructures.git (fetch)</span><br><span class="line">origin  https://github.com/Sningning/DataStructures.git (push)</span><br></pre></td></tr></tbody></table></figure>

<p>切换为 SSH 通道：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git remote set-url origin git@github.com:Sningning/DataStructures.git</span><br></pre></td></tr></tbody></table></figure>

<p>再查看下，已经改为 SSH 通道了。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:Sningning/DataStructures.git (fetch)</span><br><span class="line">origin  git@github.com:Sningning/DataStructures.git (push)</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构04-二分搜索树</title>
    <url>/posts/523021e3/</url>
    <content><![CDATA[<blockquote>
<p>树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。把它叫做“树”是因为它看起来像一棵倒挂的树。</p>
<p>二分搜索树（Binary Search Tree，BST）相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 <code>O(log n)</code>。二分搜索树是基础性数据结构，用于构建更为抽象的数据结构。</p>
<p><strong><em>维基百科</em></strong></p>
</blockquote>
<a id="more"></a>


<h1 id="1-BST-基础"><a href="#1-BST-基础" class="headerlink" title="1. BST 基础"></a>1. BST 基础</h1><h2 id="1-1-二叉树"><a href="#1-1-二叉树" class="headerlink" title="1.1 二叉树"></a>1.1 二叉树</h2><p>二叉树（Binary tree）是每个结点最多只有两个分支的树结构。通常分支被称作“左孩子”和“右孩子”或“左子树”和“右子树”。</p>
<p>二叉树的性质：</p>
<ul>
<li>二叉树只有一个根结点</li>
<li>二叉树每个结点最多有两个孩子</li>
<li>每个结点最多有一个父亲</li>
<li>每个结点的左孩子也是一个二叉树</li>
<li>每个结点的右孩子也是一个二叉树</li>
</ul>
<p>二叉树不一定是“满”的，一个结点也是一个二叉树，<code>NULL</code> 也是一个二叉树。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/tree.png" width="500px"> </div>

<h2 id="1-2-BST"><a href="#1-2-BST" class="headerlink" title="1.2 BST"></a>1.2 BST</h2><p>二分搜索树是一种二叉树，除了二叉树的性质之外，二分搜索树还有如下性质：</p>
<ul>
<li>二分搜索树中每个结点的值：<ul>
<li>大于其左子树的所有结点的值</li>
<li>小于其右子树的所有结点的值</li>
</ul>
</li>
<li>任意结点的左、右子树也分别为二分搜索树</li>
</ul>
<p>为了能达到搜索的目的，二分搜索树存储的元素必须有可比较性。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/BST.png" width=""> </div>

<p>二分搜索树类中实现的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int getSize()</td>
<td align="center">获取二分搜索树中元素个数</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">返回二分搜索树是否为空</td>
</tr>
<tr>
<td align="center">void add(E e)</td>
<td align="center">向二分搜索树中添加新元素 e</td>
</tr>
<tr>
<td align="center">boolean contains(E e)</td>
<td align="center">查看二分搜索树中是否包含元素 e</td>
</tr>
<tr>
<td align="center">E minimum()</td>
<td align="center">查找二分搜索树的最小元素</td>
</tr>
<tr>
<td align="center">E maximum()</td>
<td align="center">查找二分搜索树的最大元素</td>
</tr>
<tr>
<td align="center">void preOrder()</td>
<td align="center">二分搜索树的前序遍历</td>
</tr>
<tr>
<td align="center">void inOrder()</td>
<td align="center">二分搜索树的中序遍历</td>
</tr>
<tr>
<td align="center">void postOrder()</td>
<td align="center">二分搜索树的后序遍历</td>
</tr>
<tr>
<td align="center">void levelOrder()</td>
<td align="center">二分搜索树的层序遍历</td>
</tr>
<tr>
<td align="center">E removeMin()</td>
<td align="center">从二分搜索树中删除最小值所在的结点，返回最小值</td>
</tr>
<tr>
<td align="center">E removeMax()</td>
<td align="center">从二分搜索树中删除最大值所在的结点，返回最大值</td>
</tr>
<tr>
<td align="center">void remove(E e)</td>
<td align="center">从二分搜索树中删除元素为 e 的结点</td>
</tr>
</tbody></table>
<p>根据二分搜索树的性质，可以将结点信息以及简单的方法先完成。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="2-向-BST-中添加元素"><a href="#2-向-BST-中添加元素" class="headerlink" title="2. 向 BST 中添加元素"></a>2. 向 BST 中添加元素</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void add(E e)</td>
<td align="center">向二分搜索树中添加新元素 e</td>
</tr>
</tbody></table>
<p>如果当前的二分搜索树为空，那么直接可以将新的元素添加，同时维护 <code>size</code>。</p>
<p>如果当前二分搜索树不为空，那么需要从根结点出发，先与根结点比较。</p>
<ul>
<li>比根结点大，往右子树插入；</li>
<li>比根结点小，往左子树插入；</li>
<li>和根结点相等，不做改变；（实现的二分搜索树不包含重复元素）</li>
</ul>
<p>这样依次递归下去，知道要插入的位置为空，那么就可以将该元素正确地添加到树中。因此可以写一个递归的方法来实现添加元素的操作。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add1.gif" width=""> </div>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add2.gif" width=""> </div>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add3.gif" width=""> </div>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add4.gif" width=""> </div>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/add5.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 向二分搜索树中添加新元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">        root = <span class="keyword">new</span> Node(e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        add(root, e)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向以 node 为根的二分搜索树中插入元素 e，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止的条件</span></span><br><span class="line">    <span class="keyword">if</span>(e.equals(node.e)) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span> &amp;&amp; node.left == <span class="keyword">null</span>) {</span><br><span class="line">        node.left = <span class="keyword">new</span> Node(e);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span> &amp;&amp; node.right == <span class="keyword">null</span>) {</span><br><span class="line">        node.right = <span class="keyword">new</span> Node(e);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归过程</span></span><br><span class="line">    <span class="keyword">if</span>(e.compareTo(node.e) &lt; <span class="number">0</span>) {</span><br><span class="line">        add(node.left, e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {  <span class="comment">//e.compareTo(node.e) &gt; 0</span></span><br><span class="line">        add(node.right, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="3-改进添加操作"><a href="#3-改进添加操作" class="headerlink" title="3. 改进添加操作"></a>3. 改进添加操作</h1><p>前面实现的添加操作中，对于 <code>root == null</code> 的情况进行了单独处理，但是提到过，<strong><code>null</code> 也是一个二分搜索树</strong>。因此，如果待插入的元素走到了一个 <code>null</code> 的位置，肯定要在这里新创建一个结点。</p>
<p>所以将之前递归代码的终止条件中，左右子树为空的条件去掉，让待插入元素再递归一层走到 <code>null</code>，和之前的递归过程相比，相当于多递归了一层，在 <code>null</code> 这个位置新建结点插入，然后将插入结点后的树返回给上一层递归调用，让进入递归前该结点的左子树或右子树接住这个变化，这样完成整个二分搜索树的更新。</p>
<p>如果待插入的元素和某一个结点元素相等，就直接将该结点返回给上层调用就可以了。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 向二分搜索树中添加新元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    add(root, e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向以 node 为根的二分搜索树中插入元素 e，递归算法</span></span><br><span class="line"><span class="comment">// 返回插入新结点后二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止的条件</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) {</span><br><span class="line">        node.left = add(node.left, e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e.compareTo(node.e) &gt; <span class="number">0</span>) {</span><br><span class="line">        node.right = add(node.right, e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 e.equals(node.e)，上面代码不执行，直接将该结点返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="4-BST-的查询操作"><a href="#4-BST-的查询操作" class="headerlink" title="4. BST 的查询操作"></a>4. BST 的查询操作</h1><p>二分搜索树的查询操作，分为查询指定元素 e 是否存在；查询树中最大元素和最小元素。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean contains(E e)</td>
<td align="center">查看二分搜索树中是否包含元素 e</td>
</tr>
<tr>
<td align="center">E minimum()</td>
<td align="center">查找二分搜索树的最小元素</td>
</tr>
<tr>
<td align="center">E maximum()</td>
<td align="center">查找二分搜索树的最大元素</td>
</tr>
</tbody></table>
<h2 id="4-1-查询指定元素"><a href="#4-1-查询指定元素" class="headerlink" title="4.1 查询指定元素"></a>4.1 查询指定元素</h2><p>要实现在二分搜索树中查询某个特定的元素是否存在，给定元素后，先与根结点比较，后续过程和添加元素操作一样，因此也可以使用递归来实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 查看二分搜索树中是否包含元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> contains(node, e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看以 node 为根的二分搜索树中是否包含元素 e，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止的条件</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e.equals(node.e)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> contains(node.left, e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> contains(node.right, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="4-2-查询最小元素和最大元素"><a href="#4-2-查询最小元素和最大元素" class="headerlink" title="4.2 查询最小元素和最大元素"></a>4.2 查询最小元素和最大元素</h2><p>根据二分搜索树的性质，当沿着树的左子树一直往下寻找，当到达最左端，也就是结点的左子树为空时，该结点中存储的元素就是整个树中的最小元素，最大元素相反，往右一直寻找。因此，寻找最小元素和最大元素的过程也是递归进行的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找二分搜索树的最小元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">minimum</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"树为空。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minimum(root).e;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回以 node 为根的二分搜索树的最小键值所在的结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止的条件</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找二分搜索树的最大元素（递归实现）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">maximum</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"树为空。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maximum(root).e;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回以 node 为根的二分搜索树的最大键值所在的结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">maximum</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maximum(node.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>在二分搜索树中寻找最小值和最大值的过程其实和对一个链表进行遍历是一样的操作，因此完全可以使用一个循环来找到相应的最小值和最大值。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找二分搜索树的最小元素（非递归实现）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">minimumNR</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"树为空。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur.left != <span class="keyword">null</span>) {</span><br><span class="line">        cur = cur.left;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur.e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找二分搜索树的最大元素（非递归实现）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">maximumNR</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"树为空。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur.right != <span class="keyword">null</span>) {</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur.e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="5-BST-的前、中、后序遍历"><a href="#5-BST-的前、中、后序遍历" class="headerlink" title="5. BST 的前、中、后序遍历"></a>5. BST 的前、中、后序遍历</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void preOrder()</td>
<td align="center">二分搜索树的前序遍历</td>
</tr>
<tr>
<td align="center">void inOrder()</td>
<td align="center">二分搜索树的中序遍历</td>
</tr>
<tr>
<td align="center">void postOrder()</td>
<td align="center">二分搜索树的后序遍历</td>
</tr>
</tbody></table>
<p>与添加和查询操作不同，二分搜索树的遍历操作要将二分搜索树所有的结点都访问一遍，而非仅仅是左子树或右子树。</p>
<p>运用递归操作，依然可以方便地对二分搜索树进行遍历操作。用递归方法遍历以 <code>node</code> 为根的二分搜索树，整体思路如下：</p>
<ul>
<li>开始：<ul>
<li><code>node</code> 为空：直接返回</li>
<li><code>node</code> 不为空：<ul>
<li>访问 <code>node</code></li>
<li>遍历 <code>node.left</code></li>
<li>遍历 <code>node.right</code></li>
</ul>
</li>
</ul>
</li>
<li>结束</li>
</ul>
<p>其中，递归调用发生在遍历左子树和右子树的操作中。根据访问 <code>node</code> 的顺序不同，遍历可以分为前序遍历、中序遍历、后序遍历。这里定义访问 <code>node</code> 的操作为打印 <code>node</code> 结点存储的元素。</p>
<br>

<h2 id="5-1-前序遍历"><a href="#5-1-前序遍历" class="headerlink" title="5.1 前序遍历"></a>5.1 前序遍历</h2><p>最主要的是实现遍历的递归函数。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>{</span><br><span class="line">    preOrder(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历以 node 为根的二分搜索树，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">    preOrder(node.left);</span><br><span class="line">    preOrder(node.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="5-2-中序遍历"><a href="#5-2-中序遍历" class="headerlink" title="5.2 中序遍历"></a>5.2 中序遍历</h2><p>中序遍历无非是把访问该结点信息的操作放在访问左子树和右子树中间，根据二分搜索树的性质可以知道，该结点左子树均是小于该结点的，右子树都是大于该结点的，因此，二分搜索树中序遍历的结果是顺序的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span> </span>{</span><br><span class="line">    inOrder(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历以 node 为根的二分搜索树，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    inOrder(node.left);</span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">    inOrder(node.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="5-3-后序遍历"><a href="#5-3-后序遍历" class="headerlink" title="5.3 后序遍历"></a>5.3 后序遍历</h2><p>后序遍历就是先访问该结点的左子树，再访问该结点的右子树，最后访问该结点。后序遍历的一个应用就是释放二分搜索树的内存，如果手动释放内存，就需要先将孩子结点的内存释放，最后再释放该结点的内存。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>{</span><br><span class="line">    postOrder(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历以 node 为根的二分搜索树，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    postOrder(node.left);</span><br><span class="line">    postOrder(node.right);</span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="5-4-再理解-BST-的遍历"><a href="#5-4-再理解-BST-的遍历" class="headerlink" title="5.4 再理解 BST 的遍历"></a>5.4 再理解 BST 的遍历</h2><p>对于二分搜索树的遍历，程序编写是简单的，但是如果面对一颗二分搜索树，怎样快速手写出前中后序遍历结果？</p>
<p>对于二分搜索树的每个结点，都有 3 次访问机会，分别是访问该结点左子树之前；访问左子树和右子树之间；访问右子树之后。分别对应下图的 3 个紫色的点。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/遍历.png" width="600px"> </div> <br>

<p>前序遍历过程中，真正打印该结点是在第 1 次访问该结点的时候。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/preOrder.gif" width=""> </div> <br>


<p>中序遍历过程中，真正打印该结点是在第 2 次访问该结点的时候。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/inOrder.gif" width=""> </div> <br>

<p>后序遍历过程中，真正打印该结点是在第 3 次访问该结点的时候。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/postOrder.gif" width=""> </div>

<hr>
<h1 id="6-BST-前序遍历的非递归实现"><a href="#6-BST-前序遍历的非递归实现" class="headerlink" title="6. BST 前序遍历的非递归实现"></a>6. BST 前序遍历的非递归实现</h1><p>利用栈来实现前序遍历，根据栈结构后入先出的性质，栈顶元素是要访问的元素，先访问该元素，然后将该元素弹出栈，随后将该结点的孩子压入栈，入栈顺序是右孩子先入栈，然后左孩子再入栈，这样，栈顶元素就是左孩子，然后访问左孩子，弹出栈，再依次压入它的右孩子和左孩子，依次进行。当栈为空时，完成遍历。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/preOrderNR.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的非递归前序遍历，非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderNR</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line"></span><br><span class="line">        Node cur = stack.pop();</span><br><span class="line">        System.out.println(cur.e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) {  <span class="comment">// 右孩子先入栈</span></span><br><span class="line">            stack.push(cur.right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) {</span><br><span class="line">            stack.push(cur.left); </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="7-BST-的层序遍历"><a href="#7-BST-的层序遍历" class="headerlink" title="7. BST 的层序遍历"></a>7. BST 的层序遍历</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void levelOrder()</td>
<td align="center">二分搜索树的层序遍历</td>
</tr>
</tbody></table>
<p>二分搜索树的前中后序遍历都是在树的一侧一插到底，然后往回递归。层序遍历就是对于一个树，一层一层地对每个结点进行操作，层序遍历又称为<strong>广度优先遍历</strong>，相对应的，二分搜索树的前中后序遍历又称为<strong>深度优先遍历</strong>。对于二分搜索树的层序遍历，多是使用非递归实现，这里使用队列这种数据结构来实现二分搜索树的层序遍历。</p>
<p>队首元素是当前需要操作的元素，将队首元素出队，操作完成后，将该元素的左孩子和右孩子依次入队，知道队列为空，此时完成层序遍历。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/levelOrder.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的层序遍历（广度优先遍历）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Queue&lt;E&gt; queue = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line"></span><br><span class="line">        Node cur = queue.remove();</span><br><span class="line">        System.out.println(cur.e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) {  <span class="comment">// 左孩子先入队</span></span><br><span class="line">            queue.add(cur.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) {</span><br><span class="line">            queue.add(cur.right); </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>广度优先遍历有时可以更快的找到指定的元素，如下图所示，当要找的元素在红点位置，但使用深度优先遍历会直接先插到底部从左边寻找，而这是如果采用广度优先遍历便可以很快找到答案。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/levelOrder1.gif" width=""> </div>

<p>在图中也存在深度优先遍历和广度优先遍历，不过在图中进行遍历时，需要记录一下该结点之前是否遍历过，因为对于图来说，每一个结点的前驱可能有多个。</p>
<hr>
<h1 id="8-删除-BST-中最小元素和最大元素"><a href="#8-删除-BST-中最小元素和最大元素" class="headerlink" title="8. 删除 BST 中最小元素和最大元素"></a>8. 删除 BST 中最小元素和最大元素</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">E removeMin()</td>
<td align="center">从二分搜索树中删除最小值所在的结点，返回最小值</td>
</tr>
<tr>
<td align="center">E removeMax()</td>
<td align="center">从二分搜索树中删除最大值所在的结点，返回最大值</td>
</tr>
</tbody></table>
<p>最小元素和最大元素所在的结点可能是叶子结点也可能不是叶子结点。</p>
<h2 id="8-1-删除-BST-中最小元素"><a href="#8-1-删除-BST-中最小元素" class="headerlink" title="8.1 删除 BST 中最小元素"></a>8.1 删除 BST 中最小元素</h2><p>如果最小元素所在的结点是叶子结点，可以直接将其删除。但是当待删除的结点有右子树时，将该结点删除后，还要再把其右子树赋给其父亲结点，也就是该结点左子树的根结点接替了该结点的位置。由于 <code>null</code> 也可以看做一个结点，因此，两个过程可以统一。最后维护 <code>size</code>。这里复用了之前的 <code>minmum()</code> 方法，因此不需要再对空树进行判断。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/removeMin.gif" width=""> </div>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/removeMin2.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从二分搜索树中删除最小值所在的结点，返回最小值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeMin</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    E ret = minmum();</span><br><span class="line">    root = removeMin(root);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除掉以 node 为根的二分搜索树中的最小结点</span></span><br><span class="line"><span class="comment">// 返回删除结点后新的二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) {</span><br><span class="line"></span><br><span class="line">        Node rightNode = node.right;</span><br><span class="line">        node.right = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    node.left = removeMin(node.left);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="8-2-删除-BST-中最大元素"><a href="#8-2-删除-BST-中最大元素" class="headerlink" title="8.2 删除 BST 中最大元素"></a>8.2 删除 BST 中最大元素</h2><p>删除最大元素和删除最小元素刚好相反，只需保存待删除结点的左子树即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从二分搜索树中删除最大值所在的结点，返回最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeMax</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    E ret = maximum();</span><br><span class="line">    root = removeMax(root);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除掉以 node 为根的二分搜索树中的最大结点</span></span><br><span class="line"><span class="comment">// 返回删除结点后新的二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMax</span><span class="params">(Node node)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) {</span><br><span class="line"></span><br><span class="line">        Node leftNode = node.left;</span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> leftNode;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    node.right = removeMax(node.right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="9-删除-BST-中任意元素"><a href="#9-删除-BST-中任意元素" class="headerlink" title="9. 删除 BST 中任意元素"></a>9. 删除 BST 中任意元素</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void remove(E e)</td>
<td align="center">从二分搜索树中删除元素为 e 的结点</td>
</tr>
</tbody></table>
<p>删除任意元素时，也是分成 3 种情况：</p>
<ul>
<li>待删除元素所在结点左子树为空</li>
<li>待删除元素所在结点右子树为空</li>
<li>待删除元素所在结点左右子树都存在</li>
</ul>
<p>前两种情况和删除最小元素和最大元素是类似：<br>如果左子树为空，暂存右子树，将该结点删除，然后将右子树的根结点返回给上一层递归调用；<br>如果右子树为空，暂存左子树，将该结点删除，然后将左子树的根结点返回给上一层递归调用。</p>
<p>当待删除元素所在结点左右子树都存在时，这里采用<strong>Hibbard Deletion</strong>。</p>
<div class="note primary">
            <p><strong>Delete</strong>. We can proceed in a similar manner to delete any node that has one child (or no children), but what can we do to delete a node that has two children? We are left with two links, but have a place in the parent node for only one of them. An answer to this dilemma, first proposed by T. Hibbard in 1962, is to delete a node x by replacing it with its successor. Because x has a right child, its successor is the node with the smallest key in its right subtree. The replacement preserves order in the tree because there are no keys between x.key and the successor’s key. We accomplish the task of replacing x by its successor in four (!) easy steps:</p><ul><li>Save a link to the node to be deleted in t</li><li>Set x to point to its successor min(t.right).</li><li>Set the right link of x (which is supposed to point to the BST containing all the keys larger than x.key) to deleteMin(t.right), the link to the BST containing all the keys that are larger than x.key after the deletion.</li><li>Set the left link of x (which was null) to t.left (all the keys that are less than both the deleted key and its successor).</li></ul><p><strong><em>Algorithms(4th edition) P410</em></strong></p>
          </div>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/Algorithms(4th edition).png" width=""> </div>

<p>再来几个动画演示。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/visualgo.net.gif" width=""> </div> <br>

<p>一句话概括就是，找到待删除结点右子树中的最小值所在结点，用此结点接替待删除的结点。简单描述下过程：</p>
<p>d 为待删除结点</p>
<ul>
<li>找到 s = min( s-&gt;right ), s 是 d 的后继</li>
<li>s-&gt;right = delMin( d-&gt;right )</li>
<li>s-&gt;left = d-&gt;left</li>
<li>删除 d, s 是新的子树的根</li>
</ul>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/04-BST/remove.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从二分搜索树中删除元素为 e 的结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">remove</span><span class="params">(E e)</span> </span>{</span><br><span class="line">  remove(root, e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除掉以 node 为根的二分搜索树中值为e的结点, 递归算法</span></span><br><span class="line"><span class="comment">// 返回删除结点后新的二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) {</span><br><span class="line">        node.left = remove(node.left, e);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) {</span><br><span class="line">        node.right = remove(node.right, e);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {  <span class="comment">// e.compareTo(node.e) == 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除结点左子树为空的情况</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) {</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除结点右子树为空的情况</span></span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) {</span><br><span class="line">            Node leftNode = node.left;</span><br><span class="line">            node.left = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除结点左右子树均不为空的情况</span></span><br><span class="line">        <span class="comment">// 找到比待删除结点大的最小结点, 即待删除结点右子树的最小结点</span></span><br><span class="line">        <span class="comment">// 用这个结点顶替待删除结点的位置</span></span><br><span class="line">        Node successor = minimum(node.right);</span><br><span class="line">        successor.right = removeMin(node.right);</span><br><span class="line">        successor.left = node.left;</span><br><span class="line">        node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在最后一个 <code>else</code> 语句中，用了 2 个 <code>if</code>，而没有使用 <code>else if</code>，这是因为满足进入第一个 <code>if</code> 之后，里面直接 <code>return</code> 了，不会再去进行另一个 <code>if</code> 了，因此用 2 个 <code>if</code> 是没问题的。</p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://coding.imooc.com/class/207.html" target="_blank" rel="noopener">玩转数据结构</a></li>
<li><a href="https://visualgo.net/zh" target="_blank" rel="noopener">VisuAlgo</a></li>
<li><a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">算法(第4版)</a></li>
<li><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">Algorithms(4th edition)</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构03-链表</title>
    <url>/posts/ee7bd491/</url>
    <content><![CDATA[<p><strong>链表（Linked list）</strong> 是一种 <strong>动态</strong> 的线性数据结构，但并不是按线性的顺序存储数据。链表通常由一连串结点（Node）组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的引用（prev或next）。<br>链表的优点是不需要处理固定容量的问题，但是链表失去了数组随机读取的优点。</p>
<a id="more"></a>

<h1 id="1-链表"><a href="#1-链表" class="headerlink" title="1. 链表"></a>1. 链表</h1><p>链表是一种天然带有递归性质的线性结构，在链表中数据存储在<strong>结点</strong>中，结点中同时存储了指向下一个结点的引用（这里只介绍单向链表）。</p>
<p>链表类中的操作：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int getSize()</td>
<td align="center">获取链表中元素个数</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">返回链表是否为空</td>
</tr>
<tr>
<td align="center">void add(int index, E e)</td>
<td align="center">在链表的 index 位置添加新元素 e</td>
</tr>
<tr>
<td align="center">void addFirst(E e)</td>
<td align="center">在链表头部添加新元素 e</td>
</tr>
<tr>
<td align="center">addLast(E e)</td>
<td align="center">在链表末尾添加新元素 e</td>
</tr>
<tr>
<td align="center">E get(int index)</td>
<td align="center">获得链表的第 index 个位置的元素</td>
</tr>
<tr>
<td align="center">E getFirst()</td>
<td align="center">获得链表的第一个元素</td>
</tr>
<tr>
<td align="center">E getLast()</td>
<td align="center">获得链表的最后一个元素</td>
</tr>
<tr>
<td align="center">E set(int index, E e)</td>
<td align="center">修改链表的第 index 个位置的元素为 e，返回该位置之前的元素</td>
</tr>
<tr>
<td align="center">boolean contains(E e)</td>
<td align="center">查找链表中是否存在元素 e</td>
</tr>
<tr>
<td align="center">E remove(int index)</td>
<td align="center">从链表中删除第 index 个位置的元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">E removeFirst()</td>
<td align="center">从链表中删除第一个元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">E removeLast()</td>
<td align="center">从链表中删除最后一个元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">void removeElement(E e)</td>
<td align="center">从链表中删除元素e</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 结点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">  E e;</span><br><span class="line">  Node next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/02-LinkedList/LinkedList.png" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e, Node next)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>(e, <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="2-向链表中添加元素"><a href="#2-向链表中添加元素" class="headerlink" title="2. 向链表中添加元素"></a>2. 向链表中添加元素</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int getSize()</td>
<td align="center">获取链表中元素个数</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">返回链表是否为空</td>
</tr>
<tr>
<td align="center">void add(int index, E e)</td>
<td align="center">在链表的 index 位置添加新元素 e</td>
</tr>
<tr>
<td align="center">void addFirst(E e)</td>
<td align="center">在链表头部添加新元素 e</td>
</tr>
<tr>
<td align="center">addLast(E e)</td>
<td align="center">在链表末尾添加新元素 e</td>
</tr>
</tbody></table>
<p>先将链表类的几个基本属性和方法声明出来。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e, Node next)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>(e, <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;  <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;   <span class="comment">// 链表中元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span></span>{</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链表中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/03-LinkedList/addFirst.gif" width=""> </div>

<p>在链表头部添加元素，只需将之前整个链表的 <code>head</code> 赋给新插入结点的 <code>next</code> ，同时维护 <code>head</code> 和 <code>size</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在链表头添加新的元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    head = <span class="keyword">new</span> Node(e, head);</span><br><span class="line">    size ++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/03-LinkedList/add.gif" width=""> </div>


<p>根据图示可以看出，在某个位置添加元素最重要的是要找到前一个结点，设置一个结点引用 <code>prev</code>，通过移动 <code>prev</code> 找到待插入的位置的前一个位置，之后进行 <code>node.next = prev.next</code> 和 <code>prev.next = node</code> 两步操作就可以完成在某个位置添加元素的操作，最后维护 <code>size</code>。注意此时 <code>prev</code> 移动的次数，如果放在 3 这个位置，那么 <code>prev</code> 移动 2 次，即当 <code>prev == 2</code> 时就停止，所以循环条件是 <code>i &lt; index - 1</code>。</p>
<p>但是，如果 <code>index == 0</code>，即在链表头添加元素，由于 <code>head</code> 没有前一个结点，所以这种情况下需要单独处理。</p>
<p>切记两个操作不开颠倒顺序，否则，当执行完 <code>prev.next = node</code> 时，<code>prev.next</code> 已经指向了 <code>node</code>，再执行 <code>node.next = prev.next</code> 就出现了逻辑上的错误。</p>
<p>需要说明的是，在链表中一个位置添加元素是不常用的操作，其实在链表中没有索引这个概念，这里只是借助这个概念。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在链表的 index 位置添加新元素 e</span></span><br><span class="line"><span class="comment">// 在链表中不是一个常用的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"添加失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 在链表头添加，需要调用 addFirst 方法</span></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) {</span><br><span class="line">        addFirst(e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">        Node prev = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index - <span class="number">1</span>, i++) {</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Node node = new Node(e);</span></span><br><span class="line">        <span class="comment">// node.next = prev.next;</span></span><br><span class="line">        <span class="comment">// prev.next = node;</span></span><br><span class="line">        prev.next = node(e, prev.next);</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>在链表末尾添加元素就可以直接复用 <code>add(int index, E e)</code> 方法，将 <code>index</code> 设置为 <code>size</code> 即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在链表末尾添加新的元素e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>{</span><br><span class="line">    add(size, e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="3-虚拟头结点"><a href="#3-虚拟头结点" class="headerlink" title="3. 虚拟头结点"></a>3. 虚拟头结点</h1><p>之前在向链表中添加元素时，如果是在头部添加元素，由于头结点没有前结点，因此需要单独考虑。为了将对链表头的操作与其他操作统一起来，设立一个<strong>虚拟头结点(dummyHead)</strong>，虚拟头结点不存储元素，只有一个指向 <code>head</code> 的引用。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/03-LinkedList/dummyHead.png" width=""> </div>

<p>有了虚拟头结点，便可以将添加操作统一起来。新增 <code>dummyHead</code> 属性，初始化时将其建立起来，但元素值和 next 引用均为空。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类：Node</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e, Node next)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>(e,<span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node dummyHead;  <span class="comment">// 虚拟头结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span></span>{</span><br><span class="line">        dummyHead = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链表中元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>有了虚拟头结点后，从链表头部添加元素就不需要再单独考虑，因为 <code>dummyHead</code> 中 <code>next</code> 就指向链表第一个元素。注意，增加了虚拟头结点后，只需遍历 index 次，所以循环继续进行的条件是 <code>i &lt; index</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在链表的 index 位置添加新元素 e</span></span><br><span class="line"><span class="comment">// 在链表中不是一个常用的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"添加失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node prev = dummyHead;</span><br><span class="line">    <span class="comment">// 有虚拟头结点，从头部插入依然是安全的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) {</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    prev.next = <span class="keyword">new</span> Node(e, prev.next);</span><br><span class="line">    size ++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>此时向链表头部添加元素就可以复用 <code>add</code> 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在链表头部添加新元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>{</span><br><span class="line">  add(<span class="number">0</span>, e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="4-链表的遍历、查询和修改"><a href="#4-链表的遍历、查询和修改" class="headerlink" title="4. 链表的遍历、查询和修改"></a>4. 链表的遍历、查询和修改</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">E get(int index)</td>
<td align="center">获得链表的第 index 个位置的元素</td>
</tr>
<tr>
<td align="center">E getFirst()</td>
<td align="center">获得链表的第一个元素</td>
</tr>
<tr>
<td align="center">E getLast()</td>
<td align="center">获得链表的最后一个元素</td>
</tr>
<tr>
<td align="center">E set(int index, E e)</td>
<td align="center">修改链表的第 index 个位置的元素为 e，返回该位置之前的元素</td>
</tr>
<tr>
<td align="center">boolean contains(E e)</td>
<td align="center">查找链表中是否存在元素 e</td>
</tr>
</tbody></table>
<p>在链表中是不常使用索引的，因此 <code>get</code> 方法也不经常使用，更多是用来熟悉链表的遍历操作。</p>
<p>查询操作是需要找到 index 位置的结点，而添加操作是要找到 index 的前一个结点，因此对于查询操作，从链表真正的第一个结点开始遍历，由于设置了虚拟头结点，因此，遍历操作是从 <code>dummyHead.next</code> 进行的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获得链表的第 index 个位置的元素</span></span><br><span class="line"><span class="comment">// 在链表中不是一个常用的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"获取失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node cur = dummyHead.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) {</span><br><span class="line">        cur= cur.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur.e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>获取链表中第一个元素和最后一个元素就可以直接复用 <code>get</code> 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获得链表的第一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> get(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获得链表的最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> get(size - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>同样，修改元素也和查询元素一样需要遍历，只不过是把 index 位置的结点中数据域进行修改，最后维护 <code>size</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 修改链表的第 index 个位置的元素为 e，返回该位置之前的元素</span></span><br><span class="line"><span class="comment">// 在链表中不是一个常用的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"获取失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node cur = dummyHead.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++&gt;) {</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    E t = cur.e;</span><br><span class="line">    cur.e = e;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>设置一个查找的方法 <code>contains(E e)</code>，查询链表中是否包含元素 e。由于此时不知道具体索引位置，因此需要遍历整个链表，需要不断进行，直到到达链表的最后。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    Node cur = dummyHead.next;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cur.e.equals(e)) {</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      cur = cur.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>为了方便输出，重写 <code>toString()</code> 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node cur = dummyHead.next; cur != <span class="keyword">null</span>; cur = cur.next) {</span><br><span class="line">        res.append(cur + <span class="string">"-&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    res.append(<span class="string">"NULL"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="5-从链表中删除元素"><a href="#5-从链表中删除元素" class="headerlink" title="5. 从链表中删除元素"></a>5. 从链表中删除元素</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">E remove(int index)</td>
<td align="center">从链表中删除第 index 个位置的元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">E removeFirst()</td>
<td align="center">从链表中删除第一个元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">E removeLast()</td>
<td align="center">从链表中删除最后一个元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">void removeElement(E e)</td>
<td align="center">从链表中删除元素e</td>
</tr>
</tbody></table>
<p>想要实现在链表 index 位置删除元素，和添加元素一样，先找到待删除元素的前一个结点 <code>prev</code>，然后将待删除结点用临时结点 <code>retNode</code> 暂存起来，然后跳过待删除结点，直接将待删除结点的下一个结点赋给 <code>prev</code> 的 <code>next</code> 引用。为了避免对象游离，将待删除结点 <code>retNode</code> 的 <code>next</code> 引用设置为空。最后将 <code>retNode</code> 结点的数据返回并维护 <code>size</code>。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/03-LinkedList/remove.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从链表中删除第 index 个位置的元素，返回被删除的元素</span></span><br><span class="line"><span class="comment">// 在链表中不是一个常用的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"删除失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node prev = dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) {</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node retNode = prev.next;</span><br><span class="line">    prev.next = retNode.next;</span><br><span class="line">    retNode.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retNode.e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>有了 <code>remove</code> 方法，从链表中删除第一个元素和最后一个元素就可以直接复用 <code>remove</code> 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从链表中删除第一个元素，返回被删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从链表中删除最后一个元素，返回被删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> remove(size - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>要想从链表中删除元素，最重要的是要先找到它，找到之后，就和删除某个位置的元素一样操作就可以了。寻找的过程还是链表遍历的过程，删除元素是要找到待删除元素之前的结点 <code>prev</code>，因此遍历链表时从 <code>dummyHead</code> 开始，同时，遍历结束的条件是 <code>prev.next == null</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从链表中删除元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElemet</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    Node prev = dummyHead;</span><br><span class="line">    <span class="keyword">while</span> (prev.next != <span class="keyword">null</span>) {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev.next.e.equals(e)) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理待删除的结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev.next != <span class="keyword">null</span>) {</span><br><span class="line"></span><br><span class="line">        Node retNode = prev.next;</span><br><span class="line">        prev.next = retNode.next;</span><br><span class="line">        retNode.next = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="6-链表操作的时间复杂度"><a href="#6-链表操作的时间复杂度" class="headerlink" title="6. 链表操作的时间复杂度"></a>6. 链表操作的时间复杂度</h1><p><strong>添加操作</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add(int index, E e)</td>
<td align="center">O(n/2) = O(n)</td>
</tr>
<tr>
<td align="center">addFirst(E e)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">addLast(E e)</td>
<td align="center">O(n)</td>
</tr>
</tbody></table>
<p>由于在末尾添加元素需要遍历整个链表，所以时间复杂度为 <code>O(n)</code>；而在链表头部添加元素，是 <code>O(1)</code> 的时间复杂度；以上两个操作的时间复杂度是和数组相反的。当在链表任一位置插入元素是，平均来看，是往链表的中间添加元素，时间复杂度为 <code>O(n/2)</code>，总体也是 <code>O(n)</code> 级别。</p>
<br>

<p><strong>删除操作</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">remove(int index)</td>
<td align="center">O(n/2) = O(n)</td>
</tr>
<tr>
<td align="center">removeFirst()</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">removeLast()</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">removeElement(E e)</td>
<td align="center">O(n/2) = O(n)</td>
</tr>
</tbody></table>
<p>如果删除最后一个元素，需要从头遍历整个链表，时间复杂度为 <code>O(n)</code>；删除第一个元素，只需 <code>O(1)</code> 的时间复杂度；这两个操作的时间复杂度和数组也是相反的。平均来看，<code>remove(int index)</code> 和 <code>removeElement(E e)</code> 的时间复杂度为 <code>O(n)</code>。</p>
<br>

<p><strong>修改、查找操作</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">set(int index, E e)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">get(int index)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">getFirst()</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">getLast()</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">contains(E e)</td>
<td align="center">O(n)</td>
</tr>
</tbody></table>
<p>链表的修改和查找操作时间复杂度也是 <code>O(n)</code>。</p>
<br>

<p>总的来说，如果只对链表的头部进行操作，或者只对链表头部进行查找，时间复杂度是 <code>O(1)</code>，</p>
<p><strong>链表整体实现：</strong> <a href="https://github.com/Sningning/DataStructures/tree/master/03-Linked-List" target="_blank" rel="noopener">LikedList.java</a></p>
<hr>
<h1 id="7-使用链表实现栈"><a href="#7-使用链表实现栈" class="headerlink" title="7. 使用链表实现栈"></a>7. 使用链表实现栈</h1><p>栈的接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈中元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈，向栈中压入元素 e</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈，弹出栈顶元素</span></span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>由于在链表头操作的时间复杂度为 <code>O(1)</code>，因此栈的 <code>pop</code> 和 <code>push</code> 都应在链表头进行，也就是说，链表的头部是栈顶，尾部是栈底。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 用链表实现栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;E&gt; linkedList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListStack</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> linkedList.getSize();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> linkedList.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>{</span><br><span class="line">        linkedList.addFirst(e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> linkedList.removeFirst();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> linkedList.getFirst();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        res.append(<span class="string">"Stack: "</span>);</span><br><span class="line">        res.append(<span class="string">"top ["</span>);</span><br><span class="line">        res.append(linkedList);</span><br><span class="line">        res.append(<span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="8-使用链表实现队列"><a href="#8-使用链表实现队列" class="headerlink" title="8. 使用链表实现队列"></a>8. 使用链表实现队列</h1><p>对于队列，要在一端添加元素，另一端删除元素，但是对于链表来说势必会有一个 <code>O(n)</code> 的操作，其实之前用数组实现队列的时候也有同样的问题，不过用循环队列改进后，性能就提升了。因此用链表实现队列，也进行改进。</p>
<p>由于有 <code>head</code> 变量，所以之前对于链表头部的操作都是简单的，因此，可以考虑同时在链表尾部设置 <code>tail</code> 变量，指向最后一个结点，在对链表操作的时候，同时维护 <code>tail</code>。</p>
<p>添加了 <code>tail</code> 之后，想要在尾部添加元素就变得很方便，相当于在 <code>tail</code> 后面添加一个结点，这是，从链表的头部和尾部添加元素都是容易的</p>
<p>添加了 <code>tail</code> 之后，要想在尾部删除元素，就是说要找到 <code>tail</code> 前一个结点，但找到前一个结点又要进行遍历，所以从尾部删除元素是不容易的。</p>
<p>总的来说，添加 <code>tail</code> 变量之后，在链表尾部添加元素变得方便，而在头部添加或删除都是方便的，因此，选择在链表头部删除元素，在链表尾部添加元素，即：<strong>将链表头作为队首，链表尾部作为队尾</strong>。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/03-LinkedList/tail.gif" width=""> </div>

<p>先将简单的操作进行实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类：Node</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e, Node next)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>(e,<span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head, tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>进行入队操作，如果队列不为空，则直接将元素添加到最后即可，同时维护 <code>tail</code> 和 <code>size</code>。当队列为空时，<code>head</code> 和 <code>tail</code> 均指向 <code>null</code>，此时向空队中添加一个元素时，直接将 <code>tail</code> 指向入队的那个结点，同时维护 <code>head</code> 和 <code>size</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="keyword">null</span>) {  </span><br><span class="line">        tail = <span class="keyword">new</span> Node(e);</span><br><span class="line">        head = tail;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        tail.next = <span class="keyword">new</span> Node(e);</span><br><span class="line">        tail = tail.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    size ++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>正常出队的时候，只需按照链表中删除第一个元素，维护 <code>size</code> 即可。但是要注意，当队列中只有一个元素，<code>head.next</code> 为空，经过 <code>head = head.next</code> 操作后，队列已经为空，此时 <code>head == null</code>，因此还需要额外维护下 <code>tail</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"队列为空。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node retNode = head;</span><br><span class="line">    head = head.next;</span><br><span class="line">    retNode.next = <span class="keyword">null</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) { </span><br><span class="line">        tail = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    size --;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retNode.e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>查看队首元素只需将 <code>head</code> 数据域中的元素返回即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"队列为空。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head.e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>最后重写 <code>toString()</code> 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    res.append(<span class="string">"Queue: front "</span>);</span><br><span class="line"></span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">        res.append(cur + <span class="string">"-&gt;"</span>);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    }</span><br><span class="line">    res.append(<span class="string">"NULL tail"</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>用链表实现栈整体实现：<a href="https://github.com/Sningning/DataStructures/tree/master/02-Stacks-and-Queues/queues" target="_blank" rel="noopener">LinkedListQueue.java</a></p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://coding.imooc.com/class/207.html" target="_blank" rel="noopener">玩转数据结构</a></li>
<li><a href="https://visualgo.net/zh" target="_blank" rel="noopener">VisuAlgo</a></li>
<li><a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">算法(第4版)</a></li>
<li><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">Algorithms(4th edition)</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构02-栈和队列</title>
    <url>/posts/f9c8b94e/</url>
    <content><![CDATA[<p><strong>栈（Stack）</strong>是一种后入先出（Last In First Out, LIFO）的线性数据结构， 只能从一端添加或取出元素，进出元素的一端称为栈顶。<br><strong>队列（Queue）</strong>是一种先入先出（First In First Out, FIFO）的线性数据结构，只能从一端添加元素，从另一端取出元素，添加元素一端称为队尾，取出元素的一端称为队首。</p>
<a id="more"></a>


<h1 id="1-栈（Stack）"><a href="#1-栈（Stack）" class="headerlink" title="1.栈（Stack）"></a>1.栈（Stack）</h1><h2 id="1-1-栈的接口中定义的几个操作"><a href="#1-1-栈的接口中定义的几个操作" class="headerlink" title="1.1 栈的接口中定义的几个操作"></a>1.1 栈的接口中定义的几个操作</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int getSize()</td>
<td align="center">获取栈中元素个数</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">判断栈是否为空</td>
</tr>
<tr>
<td align="center">void push(E e)</td>
<td align="center">入栈，向栈中压入元素 e</td>
</tr>
<tr>
<td align="center">E pop()</td>
<td align="center">出栈，弹出栈顶元素</td>
</tr>
<tr>
<td align="center">E peek()</td>
<td align="center">查看栈顶元素</td>
</tr>
</tbody></table>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/02-Stacks-and-Queues/stack.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈中元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈，向栈中压入元素 e</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈，弹出栈顶元素</span></span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="1-2-基于-Array-类的栈实现"><a href="#1-2-基于-Array-类的栈实现" class="headerlink" title="1.2 基于 Array 类的栈实现"></a>1.2 基于 Array 类的栈实现</h2><p>如果用之前实现的动态数组 Array 类来实现栈，很多方法可以直接复用。由于在数组的末尾添加元素和删除元素的复杂度为 O(1)，因此将数组的末尾作为栈顶。</p>
<p>在实现栈中 <code>push(E e)</code> 和 <code>pop()</code> 方法时，根据后入先出的原则，分别复用 Array 中的 <code>addLast(E e)</code> 和 <code>removeLast()</code> 方法。<code>peek()</code> 操作只是查看栈顶元素，并非删除，因此复用 Array 类中的 <code>getLast()</code> 方法。</p>
<p>另外再添加 <code>getCapacity()</code> 方法，返回当前栈的容量，具体实现是返回底层数组的容量。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Array&lt;E&gt; array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> array.getCapacity();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> array.getSize();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> array.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>{</span><br><span class="line">        array.addLast(e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> array.removeLast();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> array.getLast();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>为了方便打印输出，重写一下 <code>toString()</code> 方法。数组栈的整体实现：<a href="https://github.com/Sningning/DataStructures/tree/master/02-Stacks-and-Queues/stacks" target="_blank" rel="noopener">ArrayStack.java</a></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    res.append(<span class="string">"Stack: "</span>);</span><br><span class="line">    res.append(<span class="string">'['</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.getSize() ; i ++) {</span><br><span class="line"></span><br><span class="line">            res.append(array.get(i));</span><br><span class="line">            <span class="keyword">if</span> (i != array.getSize() - <span class="number">1</span>) {</span><br><span class="line">                res.append(<span class="string">", "</span>);</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">    res.append(<span class="string">"] top"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1-3-栈的复杂度分析"><a href="#1-3-栈的复杂度分析" class="headerlink" title="1.3 栈的复杂度分析"></a>1.3 栈的复杂度分析</h2><p>由于 <code>push(E e)</code> 和 <code>pop()</code> 操作都是在数组尾操作，因此时间复杂度是 <code>O(1)</code>，如果触发 <code>resize()</code> 操作，按照均摊复杂度分析，整个过程也是 <code>O(1)</code>。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int getSize()</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">void push(E e)</td>
<td align="center">O(1) 均摊</td>
</tr>
<tr>
<td align="center">E pop()</td>
<td align="center">O(1) 均摊</td>
</tr>
<tr>
<td align="center">E peek()</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<hr>
<h1 id="2-队列（Queue）"><a href="#2-队列（Queue）" class="headerlink" title="2. 队列（Queue）"></a>2. 队列（Queue）</h1><h2 id="2-1-队列的接口中定义的几个操作"><a href="#2-1-队列的接口中定义的几个操作" class="headerlink" title="2.1 队列的接口中定义的几个操作"></a>2.1 队列的接口中定义的几个操作</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void enqueue(E e)</td>
<td align="center">入队，向队列中添加新元素 e</td>
</tr>
<tr>
<td align="center">E dequeue()</td>
<td align="center">出队，从队列中删除元素</td>
</tr>
<tr>
<td align="center">E getFront()</td>
<td align="center">查看队首元素</td>
</tr>
<tr>
<td align="center">int getSize()</td>
<td align="center">获取队列中元素个数</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">判断队列是否为空</td>
</tr>
</tbody></table>
<br>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队，向队列中添加新元素 e</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队，从队列中删除元素</span></span><br><span class="line">    <span class="function">E <span class="title">dequeue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看队首元素</span></span><br><span class="line">    <span class="function">E <span class="title">getFront</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列中元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/02-Stacks-and-Queues/queue.gif" width=""> </div>

<h2 id="2-2-基于-Array-类的队列实现"><a href="#2-2-基于-Array-类的队列实现" class="headerlink" title="2.2 基于 Array 类的队列实现"></a>2.2 基于 Array 类的队列实现</h2><p>还是用之前实现的动态数组 Array 类来实现队列，很多方法可以直接复用。</p>
<p>在实现队列中 <code>enqueue(E e)</code> 和 <code>dequeue()</code> 方法时，根据先入先出的原则，分别复用 Array 中的 <code>addLast(E e)</code> 和 <code>removeFirst()</code> 方法。<code>getFront()</code> 操作只是查看队首元素，并非删除，因此复用 Array 类中的 <code>getFirst()</code> 方法。</p>
<p>另外再添加 <code>getCapacity()</code> 方法，返回当前栈的容量，具体实现是返回底层数组的容量。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Array&lt;E&gt; array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> Array&lt;&gt;(capacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> Array&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> array.getCapacity();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>{</span><br><span class="line">        array.addLast(e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> array.removeFirst();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> array.getFirst();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> array.getSize();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> array.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>为了方便打印输出，重写 <code>toString()</code> 方法。数组队列的整体实现：<a href="https://github.com/Sningning/DataStructures/tree/master/02-Stacks-and-Queues/queue" target="_blank" rel="noopener">ArrayQueue.java</a>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">    </span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    res.append(<span class="string">"Queue: "</span>);</span><br><span class="line">    res.append(<span class="string">"front ["</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.getSize() ; i ++) {</span><br><span class="line">        </span><br><span class="line">        res.append(array.get(i));</span><br><span class="line">        <span class="keyword">if</span>(i != array.getSize() - <span class="number">1</span>) {</span><br><span class="line">            res.append(<span class="string">", "</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    res.append(<span class="string">"] tail"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-3-队列的复杂度分析"><a href="#2-3-队列的复杂度分析" class="headerlink" title="2.3 队列的复杂度分析"></a>2.3 队列的复杂度分析</h2><p>由于 <code>enqueue(E e)</code> 操作是在数组尾操作，因此时间复杂度是 <code>O(1)</code>，如果触发 <code>resize()</code> 操作，按照均摊复杂度分析，入队过程也是 <code>O(1)</code>。</p>
<p>但出队操作是在数组头部进行，底层复用动态数组类中 <code>removeFirst()</code> 方法，因此时间复杂度为 O(n)。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void enqueue(E e)</td>
<td align="center">O(1) 均摊</td>
</tr>
<tr>
<td align="center">E dequeue()</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">E getFront()</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">int getSize()</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<hr>
<h1 id="3-循环队列"><a href="#3-循环队列" class="headerlink" title="3. 循环队列"></a>3. 循环队列</h1><h2 id="3-1-循环队列介绍"><a href="#3-1-循环队列介绍" class="headerlink" title="3.1 循环队列介绍"></a>3.1 循环队列介绍</h2><p>之前用动态数组实现的队列，出队操作由于复用了动态数组中 <code>removeFirst()</code> 操作，删除第一个元素后，后面的元素需要向前依次移动，因此时间复杂度为 O(n)。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/02-Stacks-and-Queues/dequeue1.gif" width=""> </div>

<p>考虑出队后，其余元素不进行移动，这样就可以使出队的时间复杂度变为 <code>O(1)</code>。</p>
<p>当删除数组第一个元素后，不进行后面元素的移动，而是用一个 <code>front</code> 变量记录下当前第一个元素的索引位置，即队首元素位置，同时用一个 <code>tail</code> 变量记录下最后一个元素的下一个索引位置，也是新元素入队时的索引位置。这样当删除数组第一个元素后，只需要维护 <code>front</code> 就可以。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/02-Stacks-and-Queues/dequeue2.gif" width=""> </div>

<p>循环队列的初始状态下，队列中没有元素，<code>front</code> 和 <code>tail</code> 均指向底层数组的第一个位置，因此当 <code>front == tail</code> 时，队列为空。</p>
<p>进行入队操作时，只需维护 <code>tail</code>；如果进行出队操作，只需维护 <code>front</code>。</p>
<p>当底层数组中最后一个位置存在元素，再进行入队操作时，<code>tail</code> 就无法进行简单的 <code>tail++</code> 操作，但是由于进行了出队操作，底层数组的前半部分是空闲的，如下图中所示，这时 <code>tail</code> 应该指向 <code>data[0]</code>，因此要实现这种循环的操作，<code>tail</code> 的维护应该变成 <code>tail = (tail + 1) % data.length</code>。</p>
<p>当底层数组中 <code>tail + 1 == front</code>时，再添加元素，此时 <code>front == tail</code>，而前面定义这种情况是队列为空的判断条件，因此在这种情况下，选择不再添加元素，即判断队列为满的条件是  <code>tail + 1 == front</code>，但由于是循环队列，这个判断条件响应改为 <code>(tail + 1) % data.length == front</code>，如同钟表一样，11 点的下一个小时我们可以说是 12 点或者是 <code>0</code> 点，钟表中的 12 个刻度对应底层数组的长度 <code>data.length</code>。这时浪费了一个数组空间，因此当前队列所能存储最多的元素个数为 <code>data.length - 1</code>。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/02-Stacks-and-Queues/LoopQueue.gif" width=""> </div>

<h2 id="3-2-循环队列中简单方法的实现"><a href="#3-2-循环队列中简单方法的实现" class="headerlink" title="3.2 循环队列中简单方法的实现"></a>3.2 循环队列中简单方法的实现</h2><p>先进行 <code>LoopQueue</code> 类中简单操作的实现，由于实现方式不同，这里不再复用之前的 <code>Array</code> 动态数组类。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front, tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoopQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>{</span><br><span class="line">      </span><br><span class="line">        data = (E[])<span class="keyword">new</span> Object[capacity + <span class="number">1</span>];</span><br><span class="line">        front = <span class="number">0</span>;  <span class="comment">// 队列中第一个元素的索引</span></span><br><span class="line">        tail = <span class="number">0</span>;   <span class="comment">// 队列中最后一个元素的下一个索引</span></span><br><span class="line">        size = <span class="number">0</span>;   <span class="comment">// 队列中元素个数</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoopQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> data.length - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> front == tail;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后面实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后面实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后面实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFront</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-3-底层数组容量调整"><a href="#3-3-底层数组容量调整" class="headerlink" title="3.3 底层数组容量调整"></a>3.3 底层数组容量调整</h2><p>底层数组的容量调整和之前 <code>Array</code> 中 <code>resize(int newCapacity)</code> 方法类似。差别在于两个地方：遍历旧数组、维护 <code>front</code> 和 <code>tail</code>。</p>
<p>为了保证元素的顺序，必须从 <code>front</code> 开始遍历旧的 <code>data</code> 数组时，但旧数组中 <code>front</code> 可能不为 <code>0</code>，即不能进行 <code>newData[i] = data[i]</code> 这种操作，这时 <code>data</code> 中元素相对于 <code>newData</code> 中元素的索引值存在 front 数量的偏移，同时由于是循环队列，有可能会产生越界，需要再对 <code>data.length</code> 进行取模。这里也有两种遍历方式。</p>
<p>方式一：终止条件从 <code>size</code> 考虑。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">    newData[i] = data[(i + front) % data.length];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>方式二：终止条件从 <code>tail</code> 考虑。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = front ; i != tail ; i = (i + <span class="number">1</span>) % data.length) {</span><br><span class="line">    newData[(i - front) % data.length] = data[i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>在容量调整后，<code>front</code> 重新指向了新数组索引为 <code>0</code> 的位置，<code>tail</code> 重新指向了新数组中索引为 <code>size</code> 的位置。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>{</span><br><span class="line"></span><br><span class="line">    E[] newData = (E[]) <span class="keyword">new</span> Object[newCapacity + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        newData[i] = data[(i + front) % data.length];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    data = newData;</span><br><span class="line">    front = <span class="number">0</span>;</span><br><span class="line">    tail = size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="3-4-循环队列入队、出队的实现"><a href="#3-4-循环队列入队、出队的实现" class="headerlink" title="3.4 循环队列入队、出队的实现"></a>3.4 循环队列入队、出队的实现</h2><p>循环队列底层数组的添加、删除和容量调整的方式和 <code>Array</code> 中的方法基本是相同的，差别主要在于维护 <code>front</code> 和 <code>tail</code> 变量时并不是简单加一，而是需要加一并取模数组长度。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (tail + <span class="number">1</span>) % data.length == front ) {</span><br><span class="line">        resize( getCapacity() * <span class="number">2</span> );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    data[tail] = e;</span><br><span class="line">    tail = (tail + <span class="number">1</span>) % data.length;</span><br><span class="line">    size++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"出队失败，队列为空。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    E ret = data[front];</span><br><span class="line">    data[front] = <span class="keyword">null</span>;</span><br><span class="line">    front = (front + <span class="number">1</span>) % data.length;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == getCapacity() / <span class="number">4</span> &amp;&amp; getCapacity() / <span class="number">2</span> != <span class="number">0</span>) {</span><br><span class="line">        resize(getCapacity() / <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>重写 <code>toString()</code> 方法，循环队列的整体实现：<a href="https://github.com/Sningning/DataStructures/tree/master/02-Stacks-and-Queues/queues" target="_blank" rel="noopener">LoopQueue.java</a></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    res.append(String.format(<span class="string">"Queue: size = %d , capacity = %d\n"</span>, size, getCapacity()));</span><br><span class="line">    res.append(<span class="string">"front ["</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = front ; i != tail ; i = (i + <span class="number">1</span>) % data.length) {</span><br><span class="line"></span><br><span class="line">        res.append(data[i]);</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % data.length != tail) {</span><br><span class="line">            res.append(<span class="string">", "</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    res.append(<span class="string">"] tail"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-5-循环队列的时间复杂度"><a href="#3-5-循环队列的时间复杂度" class="headerlink" title="3.5 循环队列的时间复杂度"></a>3.5 循环队列的时间复杂度</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void enqueue(E e)</td>
<td align="center">O(1) 均摊</td>
</tr>
<tr>
<td align="center">E dequeue()</td>
<td align="center">O(1) 均摊</td>
</tr>
<tr>
<td align="center">E getFront()</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">int getSize()</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://coding.imooc.com/class/207.html" target="_blank" rel="noopener">玩转数据结构</a></li>
<li><a href="https://visualgo.net/zh" target="_blank" rel="noopener">VisuAlgo</a></li>
<li><a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">算法(第4版)</a></li>
<li><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">Algorithms(4th edition)</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构01-数组</title>
    <url>/posts/bb3e32af/</url>
    <content><![CDATA[<blockquote>
<p>数组（Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块<strong>连续</strong>的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。<strong><em>维基百科</em></strong></p>
</blockquote>
<p>数组最大的优点就是<strong>快速查询</strong>。</p>
<a id="more"></a>

<h1 id="1-数组类中包含的方法"><a href="#1-数组类中包含的方法" class="headerlink" title="1. 数组类中包含的方法"></a>1. 数组类中包含的方法</h1><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Array( int capacity )</td>
<td align="center">构造容量为 capacity 的数组类</td>
</tr>
<tr>
<td align="center">Array()</td>
<td align="center">构造默认容量的数组类</td>
</tr>
<tr>
<td align="center">int getSize()</td>
<td align="center">获取数组中元素个数</td>
</tr>
<tr>
<td align="center">int getCapacity()</td>
<td align="center">获取数组容量</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">返回数组是否为空</td>
</tr>
<tr>
<td align="center">void add( int index, E e )</td>
<td align="center">在第 index 个位置插入一个新元素 e</td>
</tr>
<tr>
<td align="center">void addLast(E e)</td>
<td align="center">向所有元素后添加一个新元素 e</td>
</tr>
<tr>
<td align="center">void addFirst(E e)</td>
<td align="center">在所有元素前添加一个新元素 e</td>
</tr>
<tr>
<td align="center">E get(int index)</td>
<td align="center">获取 index 索引位置的元素</td>
</tr>
<tr>
<td align="center">E getLast()</td>
<td align="center">获取最后一个元素</td>
</tr>
<tr>
<td align="center">E getFirst()</td>
<td align="center">获第一个元素</td>
</tr>
<tr>
<td align="center">void set(int index, E e))</td>
<td align="center">修改 index 索引位置的为 e</td>
</tr>
<tr>
<td align="center">boolean contains(E e)</td>
<td align="center">查询数组中是否存在元素 e</td>
</tr>
<tr>
<td align="center">int find(E e)</td>
<td align="center">查询数组中元素 e 的索引位置，如果不存在，返回 -1</td>
</tr>
<tr>
<td align="center">E remove(int index)</td>
<td align="center">从数组中删除 index 位置的元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">E removeFirst()</td>
<td align="center">从数组中删除第一个元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">E removeLast()</td>
<td align="center">从数组中删除最后一个元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">void removeElement(E e)</td>
<td align="center">从数组中删除元素 e</td>
</tr>
</tbody></table>
<hr>
<h1 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h1><p>实现方法</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Array( int capacity )</td>
<td align="center">构造容量为 capacity 的数组类</td>
</tr>
<tr>
<td align="center">Array()</td>
<td align="center">构造默认容量的数组类</td>
</tr>
<tr>
<td align="center">int getSize()</td>
<td align="center">获取数组中元素个数</td>
</tr>
<tr>
<td align="center">int getCapacity()</td>
<td align="center">获取数组容量</td>
</tr>
</tbody></table>
<br>

<p>在进行数组类功能实现之前，先将基本框架搭建起来，在数组类 <code>Array</code> 的内部，定义一个私有数组 <code>data</code> 用来存放元素，定义一个 <code>int</code> 型私有变量 <code>size</code> 来表示数组元素个数。对于一些简单的方法，如获取数组元素个数、获取数组容量和判断数组是否为空，先进行实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入数组的容量 capacity 构造 Array</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">( <span class="keyword">int</span> capacity )</span> </span>{</span><br><span class="line">        data = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空参构造方法，默认数组容量 capacity = 10</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数组中元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数组容量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> data.length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数组是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="3-添加元素"><a href="#3-添加元素" class="headerlink" title="3. 添加元素"></a>3. 添加元素</h1><p>实现方法</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void add(int index, E e)</td>
<td align="center">在第 index 个位置插入一个新元素 e</td>
</tr>
<tr>
<td align="center">void addLast(E e)</td>
<td align="center">向所有元素后添加一个新元素 e</td>
</tr>
<tr>
<td align="center">void addFirst(E e)</td>
<td align="center">在所有元素前添加一个新元素 e</td>
</tr>
<tr>
<td align="center">E get(int index)</td>
<td align="center">获取 index 索引位置的元素</td>
</tr>
<tr>
<td align="center">E getLast()</td>
<td align="center">获取最后一个元素</td>
</tr>
<tr>
<td align="center">E getFirst()</td>
<td align="center">获第一个元素</td>
</tr>
<tr>
<td align="center">void set(int index, E e))</td>
<td align="center">修改 index 索引位置的为 e</td>
</tr>
</tbody></table>
<br>

<p> 由于数组中存放元素必须是连续存储，因此在某个索引位置添加元素时，索引位置处的元素以及其后所有的元素需要依次向后移动一个位置，之后，再将元素插入指定索引位置，在后移元素时，必须是最后一个元素先进行移动。</p>
<p> 在添加之前，还需注意两个情况：数组是否已经存满元素；传入的索引是否是合法的。对这两个情况检查完毕没有问题后，就可以将元素添加到指定索引位置，元素添加完毕后，还需要将数组元素个数加 1，即维护 <code>size</code>。</p>
<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/01-Array/add.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在 index 索引位置插入新元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == data.length) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"添加失败，数组已满。"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"添加失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 后移元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= index ; i--) {</span><br><span class="line">        data[i + <span class="number">1</span>] = data[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    data[index] = e;</span><br><span class="line">    <span class="comment">// 维护 size</span></span><br><span class="line">    size ++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<br>

<p>实现了在指定位置添加元素后，实现在所有元素前、在所有元素后添加元素就很简单了，只需将 <code>add(int index, E e)</code> 中的 <code>index</code> 分别设置为 <code>0</code> 和 <code>size</code> 即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在所有元素后添加一个新元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    add(size, e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在所有元素前添加一个新元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    add(<span class="number">0</span>, e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="4-查询和修改元素"><a href="#4-查询和修改元素" class="headerlink" title="4. 查询和修改元素"></a>4. 查询和修改元素</h1><p>实现方法</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">E get(int index)</td>
<td align="center">获取 index 索引位置的元素</td>
</tr>
<tr>
<td align="center">E getLast()</td>
<td align="center">获取最后一个元素</td>
</tr>
<tr>
<td align="center">E getFirst()</td>
<td align="center">获第一个元素</td>
</tr>
<tr>
<td align="center">void set(int index, E e))</td>
<td align="center">修改 index 索引位置的为 e</td>
</tr>
</tbody></table>
<br>

<p>数组最大的优点就是可以快速查询，因此想要获取某个索引位置的元素，可以直接在数组中返回相应的元素，同样在进行查询之前，要先判断给出的 index 的合法性。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 index 索引位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"获取元素失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data[index];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<br>

<p>当实现了获取指定索引位置的元素后，获取最后一个和第一个元素的方法可以直接复用 <code>get(int index)</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获取最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">return</span> get(size - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获取第一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">return</span> get(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<br>

<p>同样，修改某个索引位置的元素同获取元素类似，只不过是将新的元素 e 赋值给数组中 <code>index</code> 位置即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 修改 index 索引位置元素为 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"修改失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    data[index] = e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="5-包含、搜索和删除元素"><a href="#5-包含、搜索和删除元素" class="headerlink" title="5. 包含、搜索和删除元素"></a>5. 包含、搜索和删除元素</h1><p>实现方法</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean contains(E e)</td>
<td align="center">查询数组中是否存在元素 e</td>
</tr>
<tr>
<td align="center">int find(E e)</td>
<td align="center">查询数组中元素 e 的索引位置，如果不存在，返回 -1</td>
</tr>
<tr>
<td align="center">E remove(int index)</td>
<td align="center">从数组中删除 index 位置的元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">E removeFirst()</td>
<td align="center">从数组中删除第一个元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">E removeLast()</td>
<td align="center">从数组中删除最后一个元素，返回被删除的元素</td>
</tr>
<tr>
<td align="center">void removeElement(E e)</td>
<td align="center">从数组中删除第一个元素 e</td>
</tr>
<tr>
<td align="center">void removeAllElement(E e)</td>
<td align="center">从数组中删除所有元素 e</td>
</tr>
</tbody></table>
<h2 id="5-1-包含、搜索元素"><a href="#5-1-包含、搜索元素" class="headerlink" title="5.1 包含、搜索元素"></a>5.1 包含、搜索元素</h2><p>有时想看数组中是否包含某个元素 e，基本思路是将数组遍历，将数组元素逐一与想要查询的元素 e 进行比较，当查询到相等时，立即返回 <code>true</code>，否则，遍历完整个数组也没有查询到与 e 相等的元素，则返回 <code>false</code>。</p>
<p>查询数组中某个元素的索引位置，也是相同的思路，遍历数组，查询到相等时就返回当前索引位置，否则返回 <code>-1</code>。这里实现的 <code>find(E e)</code> 方法只是将该元素第一次出现的位置返回。</p>
<p>由于使用了泛型（Generic），因此进行元素比较时，不能使用 <code>==</code> 来判断，应该使用 <code>equals()</code> 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 查询数组中是否存在元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        <span class="keyword">if</span> (data[i].equals(e)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 查询数组中元素 e 的索引位置，如果不存在，返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        <span class="keyword">if</span> (data[i].equals(e)) {</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="5-2-删除元素"><a href="#5-2-删除元素" class="headerlink" title="5.2 删除元素"></a>5.2 删除元素</h2><p>数组中的元素都是连续存储，因此删除操作实际上也是元素移动的过程，具体执行删除操作时，直接将待删除索引位置后面的元素依次向前移动覆盖，前移过程必须是待删除索引位置后第一个位置元素先进行移动。</p>
<p>当最后的元素 56 向前移动后，维护了 <code>size</code>，此时 <code>size</code> 指向了索引为 5 位置的 56，该元素用户是访问不到的。但是由于使用了泛型，所以实际上 <code>size</code> 还是指向了一个对象的引用，Java 的垃圾回收机制无法对其进行回收， 应该手动进行释放。</p>
<div class="note primary">
            <p>Java 的垃圾收集策略是回收所有无法被访问的对象的内存。在我们对 pop() 的实现中，被弹出的元素的引用仍然存在于数组中。这个元素实际上已经是一个孤儿了——它永远不会再被访问，但 Java 的垃圾收集器无法知道这一点，除非该引用被覆盖。即使用例不再需要这个元素了，数组中的引用仍然可以让它继续存在。这种情况（保存一个不需要的对象的引用）成为<strong>游离(loitering)</strong>。在这里，避免对象游离很容易，只需将被弹出的数组元素的值设为 null 即可。这将覆盖无用的引用并使系统可以在用例使用完被弹出的元素后回收它的内存。<strong><em>算法(第4版) P85</em></strong></p>
          </div>

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/01-Array/delete.gif" width=""> </div>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组中删除 index 位置的元素, 返回被删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"删除失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    E ret = data[index];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index + <span class="number">1</span> ; i &lt; size ; i ++) {</span><br><span class="line">        data[i - <span class="number">1</span>] = data[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    size--;</span><br><span class="line">    data[size] = <span class="keyword">null</span>;  <span class="comment">// 避免对象游离</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>完成 <code>remove(int index)</code> 方法后，删除数组中第一个元素和最后一个元素，直接复用 <code>remove(int index)</code> 方法，传入相应的索引即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组中删除第一个元素, 返回被删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组中删除最后一个元素, 返回被删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> remove(size - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>要实现从数组中删除某一个元素 e，可以先调用 <code>find(E e)</code> 方法，找到其在数组中对应的索引位置，然后再调用 <code>remove(int index)</code> 方法，将其删除。如果调用 <code>find(E e)</code> 返回 <code>-1</code>，即数组中不存在该元素，这里不执行任何操作。实现的 <code>removeElement(E e)</code> 方法，由于只进行了一次 <code>find</code> 操作，因此只能删除第一次出现的 e。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组中(第一次出现 e 的位置)删除元素 e </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(E e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = find(e);</span><br><span class="line">    <span class="keyword">if</span> (index != -<span class="number">1</span>) {</span><br><span class="line">        remove(index);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="6-动态调整容量"><a href="#6-动态调整容量" class="headerlink" title="6. 动态调整容量"></a>6. 动态调整容量</h1><p>前面所有操作的实现，底层都是基于 <code>data</code> 数组，当实例化 <code>Array</code> 类后，底层 <code>data</code> 数组的容量就已经固定了。如果不断向数组中添加元素，势必会导致数组被填满，因此可以考虑，在添加完元素后，当满足一定条件时，进行底层 <code>data</code> 数组的扩容；另一方面，当删除完元素后，可以考虑当满足一定条件时，对底层 <code>data</code> 数组进行缩容。</p>
<p>数组大小的动态调整（缩容或扩容），实质上是将原来数组的元素，逐个复制到新的数组中，然后将之前的数组引用 <code>data</code> 指向新的数组，Java 的垃圾回收机制会将之前的数组进行回收。这里实现一个私有的方法 <code>resize(int newCapacity)</code> 来调整数组容量，设置成私有方法是因为，对于使用 <code>Array</code> 类的用户来说，容量调整这个过程是对其屏蔽的。</p>
<div align="center"><img width="" src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/01-Array/resize1.gif"></div>
<br>
<div align="center"><img width="" src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/01-Array/resize2.gif"></div>


<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 数组容量调整</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>{</span><br><span class="line"></span><br><span class="line">    E[] newData = (E[]) <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        newData[i] = data[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    data = newData;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="6-1-扩容"><a href="#6-1-扩容" class="headerlink" title="6.1 扩容"></a>6.1 扩容</h2><p>扩容，是在添加元素时进行的，前面实现的 <code>add(int index, int e)</code> 方法中，对于数组已满的情况是抛出了异常，现在可以将底层 <code>data</code> 数组进行扩容，扩容的大小设置为当前容量的 <code>2</code> 倍，即 <code>2 * data.length</code>，这里设置的新数组的容量是与现有元素个数相关联的，保证新数组容量和之前数组中元素的个数是一个数量级。 </p>
<div class="note primary">
            <p>在 <code>Java</code> 中，<code>ArrayList</code> 扩容是变为原来的 <strong><code>1.5</code></strong> 倍。在 <code>ArrayList</code> 类的 <code>grow(int minCapacity)</code> 私有方法中， <strong><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code></strong> 进行了新容量的设定。</p>
          </div>
<br>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在第 index 个位置插入一个新元素 e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">( <span class="keyword">int</span> index, E e )</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( index &lt; <span class="number">0</span> || index &gt; size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"添加失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    <span class="keyword">if</span> ( size == data.length ) {</span><br><span class="line">        resize(<span class="number">2</span> * data.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= index; i--) {</span><br><span class="line">        data[i + <span class="number">1</span>] = data[i];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    data[index] = e;</span><br><span class="line">    size++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<h2 id="6-2-缩容"><a href="#6-2-缩容" class="headerlink" title="6.2 缩容"></a>6.2 缩容</h2><p>在删除对象后，可以根据元素个数进行缩容操作。当元素个数小到刚好等于数组长度的一半时，即 <code>size == data.length / 2</code>，将数组缩容为原来长度的一半。暂时这样处理，后续再进行优化。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组中删除 index 位置的元素, 返回删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"删除失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    E ret = data[index];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index + <span class="number">1</span> ; i &lt; size ; i ++) {</span><br><span class="line">        data[i - <span class="number">1</span>] = data[i];</span><br><span class="line">    }</span><br><span class="line">    size--;</span><br><span class="line">    data[size] = <span class="keyword">null</span>; <span class="comment">// 避免对象游离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩容</span></span><br><span class="line">    <span class="keyword">if</span> (size == data.length / <span class="number">2</span>) {</span><br><span class="line">        resize(data.length / <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="7-简单的时间复杂度分析"><a href="#7-简单的时间复杂度分析" class="headerlink" title="7. 简单的时间复杂度分析"></a>7. 简单的时间复杂度分析</h1><h2 id="7-1-添加操作的时间复杂度"><a href="#7-1-添加操作的时间复杂度" class="headerlink" title="7.1 添加操作的时间复杂度"></a>7.1 添加操作的时间复杂度</h2><table>
<thead>
<tr>
<th align="center">添加操作</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">addLast(E e)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">addFirst(E e)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">add(int index, E e)</td>
<td align="center">O(n/2) = O(n)</td>
</tr>
</tbody></table>
<p>有时添加元素时还需要扩容，<code>resize</code> 操作的时间复杂度为 <code>O(n)</code>，因此，总体来看，添加操作的时间复杂度为 <code>O(n)</code>。</p>
<h2 id="7-2-删除操作的时间复杂度"><a href="#7-2-删除操作的时间复杂度" class="headerlink" title="7.2 删除操作的时间复杂度"></a>7.2 删除操作的时间复杂度</h2><table>
<thead>
<tr>
<th align="center">删除操作</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">removeLast(E e)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">removeFirst(E e)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">remove(int index, E e)</td>
<td align="center">O(n/2) = O(n)</td>
</tr>
</tbody></table>
<p>有时删除元素后还需要缩容，<code>resize</code> 操作的时间复杂度为 <code>O(n)</code>，因此，总体来看，删除操作的时间复杂度为 <code>O(n)</code>。</p>
<h2 id="7-3-修改、查询操作的时间复杂度"><a href="#7-3-修改、查询操作的时间复杂度" class="headerlink" title="7.3 修改、查询操作的时间复杂度"></a>7.3 修改、查询操作的时间复杂度</h2><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">set(int index, E e)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">get(int index)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">contains(E e)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">find(E e)</td>
<td align="center">O(n)</td>
</tr>
</tbody></table>
<hr>
<h1 id="8-改进缩容操作"><a href="#8-改进缩容操作" class="headerlink" title="8. 改进缩容操作"></a>8. 改进缩容操作</h1><p>假设当前数组容量为 8，即 <code>capacity = 8</code>。添加 9 个元素，每次添加操作均使用 <code>addLast()</code> ，则一共需要 <code>9</code> 次 <code>addLast()</code> 操作和 <code>1</code> 次 <code>resize(2 * 8)</code> 操作。其中， <code>resize(2 * 8)</code> 需要将已有的 <code>8</code> 个元素全部进行复制，因此总共进行了 <code>17</code> 次基本操作。平均来看，每次 <code>addLast()</code> 操作会进行 <code>2</code> 次基本操作。</p>
<p>更普遍的，假设 <code>capacity = n</code>，<code>n + 1</code> 次 <code>addLast()</code> ，触发 <code>resize</code> 操作，总共进行了 <code>n + n + 1 = 2n + 1</code> 次基本操作。平均来看，每次 <code>addLast()</code> 操作会进行 <code>2</code> 次基本操作。这里 <code>1</code> 次 <code>resize</code> 的时间<strong>平摊</strong>给了 <code>n + 1</code> 次 <code>addLast()</code> 操作，这样均摊来看，<code>addLast()</code> 的时间复杂度为 <code>O(1)</code>，因此在这里 <code>addLast()</code> 的<strong>均摊复杂度(Amortized Time Complexity)</strong> 为 <code>O(1)</code>。</p>
<p>同理，从均摊复杂度分析，<code>removeLast()</code> 的摊复杂度也是 O(1)。</p>
<p>但是，当 <code>size == data.length</code>，也就是 <code>size == capacity</code> 时，依次进行 <code>addLast()</code> 和 <code>removeLast()</code> 操作，根据之前 <code>add</code> 和 <code>remove</code> 中扩容缩容的条件，会出现<strong>复杂度振荡</strong>的情况。</p>
<div align="center"><img width="" src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/01-Array/complexity.gif"></div>
<br> 

<p>出现复杂度振荡的原因，是在进行 <code>removeLast()</code> 操作时 <code>resize</code> 过于<strong>着急(eager)</strong> ，当元素个数等于数组容量的一半时马上进行缩容，缩容完整个 <code>data</code> 数组是满的，再添加元素肯定需要再进行扩容。解决的方法就是采用 <strong>懒惰 (lazy)</strong> 的方案，当 <code>size == data.length / 4</code> 时，再进行容量减半，此时缩容完，<code>data</code> 数组还有一半的空余容量。</p>
<p>注意，因为是要缩容，<code>data.length</code> 要减小，有可能 <code>data.length == 1</code>，此时 <code>data.length / 2 == 0</code>，因此缩容前应该进行判断。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组中删除 index 位置的元素，返回被删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"删除失败，索引非法。"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    E ret = data[index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; size; i++) {</span><br><span class="line">        data[i - <span class="number">1</span>] = (data[i]);</span><br><span class="line">    }</span><br><span class="line">    size--;</span><br><span class="line">    data[size] = <span class="keyword">null</span>; <span class="comment">// 避免对象游离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩容</span></span><br><span class="line">    <span class="keyword">if</span> (size == data.length / <span class="number">4</span> &amp;&amp; data.length / <span class="number">2</span> != <span class="number">0</span>) {</span><br><span class="line">        resize(data.length / <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div align="center"><img width="" src="https://cdn.jsdelivr.net/gh/Sningning/BlogPictures/01-Array/LazyResize.gif"></div>

<hr>
<h1 id="9-数组类的整体实现"><a href="#9-数组类的整体实现" class="headerlink" title="9. 数组类的整体实现"></a>9. 数组类的整体实现</h1><p>为了方便打印输出，重写了 <code>toString()</code> 方法。整体实现：<a href="https://github.com/Sningning/DataStructures/tree/master/01-Arrays" target="_blank" rel="noopener">Array.java</a></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    res.append(String.format(<span class="string">"Array: size = %d, capacity = %d\n"</span>, size, data.length));</span><br><span class="line">    res.append(<span class="string">"["</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        res.append(data[i]);</span><br><span class="line">        <span class="keyword">if</span>(i != size - <span class="number">1</span>) {</span><br><span class="line">            res.append(<span class="string">", "</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    res.append(<span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://coding.imooc.com/class/207.html" target="_blank" rel="noopener">玩转数据结构</a></li>
<li><a href="https://visualgo.net/zh" target="_blank" rel="noopener">VisuAlgo</a></li>
<li><a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">算法(第4版)</a></li>
<li><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">Algorithms(4th edition)</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义npm包的安装位置</title>
    <url>/posts/15d73520/</url>
    <content><![CDATA[<p>nodejs 官网上下载的安装包中包含 npm，在 Windows 系统下安装完后，npm 下载模块默认安装在 <code>C:\Users\本机用户名\AppData\Roaming</code> 文件中。但在清理磁盘时容易将其清理掉，考虑将 npm 也安装在其他盘符。</p>
<p>通过以下几个步骤实现在安装 nodejs 时将 npm 也安装在自定义路径。</p>
<a id="more"></a>
<br>


<p><strong>1. 在<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网</a>下载 zip 文件</strong><br>这里不使用默认的 msi 安装包，使用 <code>zip</code> 压缩文件，之后自己配置安装路径和环境变量。<br><br></p>
<p><strong>2. 设置安装目录</strong><br>我这里将 nodejs 安装在D盘。在 <code>D:\Program Files\</code> 目录下新建 node 文件夹，然后在 node 文件夹中新建 nodejs、npm_prefix、npm_cashe 三个文件夹。将下载的压缩包中的所有文件拷贝到 nodejs 文件夹中。<br><br></p>
<p><strong>3. 设置环境变量</strong><br>① 将 node 路径加入环境变量。<br>在 Path 中添加 <code>D:\Program Files\node\nodejs</code>。或者通过以下命令将 node路径 加入环境变量。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">setx PATH "%PATH%;D:\Program Files\node\nodejs</span><br></pre></td></tr></tbody></table></figure>

<p>② 将 npm 的全局模块路径加入到环境变量。<br>在 Path 中添加 <code>D:\Program Files\node\npm_prefix</code>，或者通过以下命令将 npm 全局模块路径加入环境变量 。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">setx PATH "%PATH%;D:\Program Files\node\npm_prefix</span><br></pre></td></tr></tbody></table></figure>
<br>

<p><strong>4. 设置 npm 全局模块和缓存路径</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">npm config set prefix "D:\\Program Files\\node\\npm_prefix"</span><br><span class="line">npm config set cache "D:\\Program Files\\node\\npm_cache"</span><br></pre></td></tr></tbody></table></figure>
<br>

<p>大功告成！<br><br></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
